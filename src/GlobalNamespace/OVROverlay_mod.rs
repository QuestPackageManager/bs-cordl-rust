#[cfg(feature = "OVROverlay")]
#[repr(C)]
#[derive(Debug)]
pub struct OVROverlay {
    __cordl_parent: crate::UnityEngine::MonoBehaviour,
    pub currentOverlayType: crate::GlobalNamespace::OVROverlay_OverlayType,
    pub isDynamic: bool,
    pub isProtectedContent: bool,
    pub srcRectLeft: crate::UnityEngine::Rect,
    pub srcRectRight: crate::UnityEngine::Rect,
    pub destRectLeft: crate::UnityEngine::Rect,
    pub destRectRight: crate::UnityEngine::Rect,
    pub invertTextureRects: bool,
    pub textureRectMatrix: crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf,
    pub overrideTextureRectMatrix: bool,
    pub overridePerLayerColorScaleAndOffset: bool,
    pub colorScale: crate::UnityEngine::Vector4,
    pub colorOffset: crate::UnityEngine::Vector4,
    pub useExpensiveSuperSample: bool,
    pub useExpensiveSharpen: bool,
    pub hidden: bool,
    pub isExternalSurface: bool,
    pub externalSurfaceWidth: i32,
    pub externalSurfaceHeight: i32,
    pub compositionDepth: i32,
    pub layerCompositionDepth: i32,
    pub noDepthBufferTesting: bool,
    pub layerTextureFormat: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub currentOverlayShape: crate::GlobalNamespace::OVROverlay_OverlayShape,
    pub prevOverlayShape: crate::GlobalNamespace::OVROverlay_OverlayShape,
    pub textures: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            quest_hook::libil2cpp::Gc<crate::UnityEngine::Texture>,
        >,
    >,
    pub isAlphaPremultiplied: bool,
    pub useBicubicFiltering: bool,
    pub useLegacyCubemapRotation: bool,
    pub useEfficientSupersample: bool,
    pub useEfficientSharpen: bool,
    pub useAutomaticFiltering: bool,
    pub _previewInEditor: bool,
    pub texturePtrs: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::System::IntPtr>,
    >,
    pub externalSurfaceObject: crate::System::IntPtr,
    pub externalSurfaceObjectCreated: quest_hook::libil2cpp::Gc<
        crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated,
    >,
    pub isOverridePending: bool,
    pub _layerId_k__BackingField: i32,
    pub layerTextures: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            crate::GlobalNamespace::OVROverlay_LayerTexture,
        >,
    >,
    pub layerDesc: crate::GlobalNamespace::OVRPlugin_LayerDesc,
    pub stageCount: i32,
    pub layerIndex: i32,
    pub layerIdHandle: crate::System::Runtime::InteropServices::GCHandle,
    pub layerIdPtr: crate::System::IntPtr,
    pub frameIndex: i32,
    pub prevFrameIndex: i32,
    pub rend: quest_hook::libil2cpp::Gc<crate::UnityEngine::Renderer>,
    pub OpenVROverlayHandle: u64,
    pub OpenVRUVOffsetAndScale: crate::UnityEngine::Vector4,
    pub OpenVRMouseScale: crate::UnityEngine::Vector2,
    pub constructedOverlayXRDevice: crate::GlobalNamespace::OVRManager_XRDevice,
    pub xrDeviceConstructed: bool,
}
#[cfg(feature = "OVROverlay")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVROverlay {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVROverlay";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "OVROverlay")]
impl std::ops::Deref for crate::GlobalNamespace::OVROverlay {
    type Target = crate::UnityEngine::MonoBehaviour;
    fn deref(&self) -> &Self::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "OVROverlay")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVROverlay {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVROverlay")]
impl crate::GlobalNamespace::OVROverlay {
    pub const maxInstances: i32 = 15i32;
    #[cfg(feature = "OVROverlay+ExternalSurfaceObjectCreated")]
    pub type ExternalSurfaceObjectCreated = crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated;
    #[cfg(feature = "OVROverlay+LayerTexture")]
    pub type LayerTexture = crate::GlobalNamespace::OVROverlay_LayerTexture;
    #[cfg(feature = "OVROverlay+OverlayShape")]
    pub type OverlayShape = crate::GlobalNamespace::OVROverlay_OverlayShape;
    #[cfg(feature = "OVROverlay+OverlayType")]
    pub type OverlayType = crate::GlobalNamespace::OVROverlay_OverlayType;
    pub fn Awake(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("Awake")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "Awake", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn BlitSubImage(
        &mut self,
        src: quest_hook::libil2cpp::Gc<crate::UnityEngine::Texture>,
        dst: quest_hook::libil2cpp::Gc<crate::UnityEngine::RenderTexture>,
        mat: quest_hook::libil2cpp::Gc<crate::UnityEngine::Material>,
        rect: crate::UnityEngine::Rect,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    quest_hook::libil2cpp::Gc<crate::UnityEngine::Texture>,
                    quest_hook::libil2cpp::Gc<crate::UnityEngine::RenderTexture>,
                    quest_hook::libil2cpp::Gc<crate::UnityEngine::Material>,
                    crate::UnityEngine::Rect,
                ),
                quest_hook::libil2cpp::Void,
                4usize,
            >("BlitSubImage")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "BlitSubImage", 4usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (src, dst, mat, rect))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ComputePoseAndScale(
        &mut self,
        pose: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPose>,
        scale: quest_hook::libil2cpp::ByRefMut<crate::UnityEngine::Vector3>,
        overlay: quest_hook::libil2cpp::ByRefMut<bool>,
        headLocked: quest_hook::libil2cpp::ByRefMut<bool>,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPose>,
                    quest_hook::libil2cpp::ByRefMut<crate::UnityEngine::Vector3>,
                    quest_hook::libil2cpp::ByRefMut<bool>,
                    quest_hook::libil2cpp::ByRefMut<bool>,
                ),
                quest_hook::libil2cpp::Void,
                4usize,
            >("ComputePoseAndScale")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "ComputePoseAndScale", 4usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (pose, scale, overlay, headLocked))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ComputeSubmit(
        &mut self,
        pose: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPose>,
        scale: quest_hook::libil2cpp::ByRefMut<crate::UnityEngine::Vector3>,
        overlay: quest_hook::libil2cpp::ByRefMut<bool>,
        headLocked: quest_hook::libil2cpp::ByRefMut<bool>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPose>,
                    quest_hook::libil2cpp::ByRefMut<crate::UnityEngine::Vector3>,
                    quest_hook::libil2cpp::ByRefMut<bool>,
                    quest_hook::libil2cpp::ByRefMut<bool>,
                ),
                bool,
                4usize,
            >("ComputeSubmit")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "ComputeSubmit", 4usize
                )
            });
        let __cordl_ret: bool = unsafe {
            method.invoke_unchecked(self, (pose, scale, overlay, headLocked))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CreateLayer(
        &mut self,
        mipLevels: i32,
        sampleCount: i32,
        etFormat: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
        flags: i32,
        _cordl_size: crate::GlobalNamespace::OVRPlugin_Sizei,
        shape: crate::GlobalNamespace::OVRPlugin_OverlayShape,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    i32,
                    i32,
                    crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
                    i32,
                    crate::GlobalNamespace::OVRPlugin_Sizei,
                    crate::GlobalNamespace::OVRPlugin_OverlayShape,
                ),
                bool,
                6usize,
            >("CreateLayer")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "CreateLayer", 6usize
                )
            });
        let __cordl_ret: bool = unsafe {
            method
                .invoke_unchecked(
                    self,
                    (mipLevels, sampleCount, etFormat, flags, _cordl_size, shape),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CreateLayerTextures(
        &mut self,
        useMipmaps: bool,
        _cordl_size: crate::GlobalNamespace::OVRPlugin_Sizei,
        isHdr: bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (bool, crate::GlobalNamespace::OVRPlugin_Sizei, bool),
                bool,
                3usize,
            >("CreateLayerTextures")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "CreateLayerTextures", 3usize
                )
            });
        let __cordl_ret: bool = unsafe {
            method.invoke_unchecked(self, (useMipmaps, _cordl_size, isHdr))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroyLayer(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("DestroyLayer")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "DestroyLayer", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroyLayerTextures(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                quest_hook::libil2cpp::Void,
                0usize,
            >("DestroyLayerTextures")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "DestroyLayerTextures", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetBlitRect(
        &mut self,
        eyeId: i32,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Rect> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(i32), crate::UnityEngine::Rect, 1usize>("GetBlitRect")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "GetBlitRect", 1usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Rect = unsafe {
            method.invoke_unchecked(self, (eyeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetCurrentLayerDesc(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_LayerDesc> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::GlobalNamespace::OVRPlugin_LayerDesc,
                0usize,
            >("GetCurrentLayerDesc")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "GetCurrentLayerDesc", 0usize
                )
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_LayerDesc = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn InitOVROverlay(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("InitOVROverlay")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "InitOVROverlay", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn IsPassthroughShape(
        shape: crate::GlobalNamespace::OVROverlay_OverlayShape,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::GlobalNamespace::OVROverlay_OverlayShape),
                bool,
                1usize,
            >("IsPassthroughShape")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "IsPassthroughShape", 1usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked((), (shape))? };
        Ok(__cordl_ret.into())
    }
    pub fn LatchLayerTextures(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), bool, 0usize>("LatchLayerTextures")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "LatchLayerTextures", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn LateUpdate(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("LateUpdate")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "LateUpdate", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn NeedsTexturesForShape(
        shape: crate::GlobalNamespace::OVROverlay_OverlayShape,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::GlobalNamespace::OVROverlay_OverlayShape),
                bool,
                1usize,
            >("NeedsTexturesForShape")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "NeedsTexturesForShape", 1usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked((), (shape))? };
        Ok(__cordl_ret.into())
    }
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn OnDestroy(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("OnDestroy")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "OnDestroy", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnDisable(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("OnDisable")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "OnDisable", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnEnable(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("OnEnable")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "OnEnable", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OpenVROverlayUpdate(
        &mut self,
        scale: crate::UnityEngine::Vector3,
        pose: crate::GlobalNamespace::OVRPose,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Vector3, crate::GlobalNamespace::OVRPose),
                quest_hook::libil2cpp::Void,
                2usize,
            >("OpenVROverlayUpdate")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "OpenVROverlayUpdate", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (scale, pose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OverrideOverlayTextureInfo(
        &mut self,
        srcTexture: quest_hook::libil2cpp::Gc<crate::UnityEngine::Texture>,
        nativePtr: crate::System::IntPtr,
        node: crate::UnityEngine::XR::XRNode,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    quest_hook::libil2cpp::Gc<crate::UnityEngine::Texture>,
                    crate::System::IntPtr,
                    crate::UnityEngine::XR::XRNode,
                ),
                quest_hook::libil2cpp::Void,
                3usize,
            >("OverrideOverlayTextureInfo")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "OverrideOverlayTextureInfo", 3usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (srcTexture, nativePtr, node))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn PopulateLayer(
        &mut self,
        mipLevels: i32,
        isHdr: bool,
        _cordl_size: crate::GlobalNamespace::OVRPlugin_Sizei,
        sampleCount: i32,
        stage: i32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32, bool, crate::GlobalNamespace::OVRPlugin_Sizei, i32, i32),
                bool,
                5usize,
            >("PopulateLayer")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "PopulateLayer", 5usize
                )
            });
        let __cordl_ret: bool = unsafe {
            method
                .invoke_unchecked(
                    self,
                    (mipLevels, isHdr, _cordl_size, sampleCount, stage),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetPerLayerColorScaleAndOffset(
        &mut self,
        scale: crate::UnityEngine::Vector4,
        offset: crate::UnityEngine::Vector4,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Vector4, crate::UnityEngine::Vector4),
                quest_hook::libil2cpp::Void,
                2usize,
            >("SetPerLayerColorScaleAndOffset")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "SetPerLayerColorScaleAndOffset", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (scale, offset))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetSrcDestRects(
        &mut self,
        srcLeft: crate::UnityEngine::Rect,
        srcRight: crate::UnityEngine::Rect,
        destLeft: crate::UnityEngine::Rect,
        destRight: crate::UnityEngine::Rect,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    crate::UnityEngine::Rect,
                    crate::UnityEngine::Rect,
                    crate::UnityEngine::Rect,
                    crate::UnityEngine::Rect,
                ),
                quest_hook::libil2cpp::Void,
                4usize,
            >("SetSrcDestRects")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "SetSrcDestRects", 4usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (srcLeft, srcRight, destLeft, destRight))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetupEditorPreview(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("SetupEditorPreview")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "SetupEditorPreview", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SubmitLayer(
        &mut self,
        overlay: bool,
        headLocked: bool,
        noDepthBufferTesting: bool,
        pose: crate::GlobalNamespace::OVRPose,
        scale: crate::UnityEngine::Vector3,
        frameIndex: i32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    bool,
                    bool,
                    bool,
                    crate::GlobalNamespace::OVRPose,
                    crate::UnityEngine::Vector3,
                    i32,
                ),
                bool,
                6usize,
            >("SubmitLayer")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "SubmitLayer", 6usize
                )
            });
        let __cordl_ret: bool = unsafe {
            method
                .invoke_unchecked(
                    self,
                    (overlay, headLocked, noDepthBufferTesting, pose, scale, frameIndex),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn UpdateTextureRectMatrix(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                quest_hook::libil2cpp::Void,
                0usize,
            >("UpdateTextureRectMatrix")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "UpdateTextureRectMatrix", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), ".ctor", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_OpenVROverlayKey() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (),
                quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                0usize,
            >("get_OpenVROverlayKey")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "get_OpenVROverlayKey", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { method.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_layerId(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_layerId")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "get_layerId", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_layout(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_LayerLayout> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::GlobalNamespace::OVRPlugin_LayerLayout,
                0usize,
            >("get_layout")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "get_layout", 0usize
                )
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_LayerLayout = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_previewInEditor(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), bool, 0usize>("get_previewInEditor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "get_previewInEditor", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_texturesPerStage(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_texturesPerStage")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "get_texturesPerStage", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn set_layerId(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<(i32), quest_hook::libil2cpp::Void, 1usize>("set_layerId")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "set_layerId", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_previewInEditor(
        &mut self,
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (bool),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_previewInEditor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay as quest_hook::libil2cpp::Type >
                    ::class(), "set_previewInEditor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "OVROverlay")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVROverlay {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "OVROverlay+ExternalSurfaceObjectCreated")]
#[repr(C)]
#[derive(Debug)]
pub struct OVROverlay_ExternalSurfaceObjectCreated {
    __cordl_parent: crate::System::MulticastDelegate,
}
#[cfg(feature = "OVROverlay+ExternalSurfaceObjectCreated")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVROverlay/ExternalSurfaceObjectCreated";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "OVROverlay+ExternalSurfaceObjectCreated")]
impl std::ops::Deref
for crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated {
    type Target = crate::System::MulticastDelegate;
    fn deref(&self) -> &Self::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "OVROverlay+ExternalSurfaceObjectCreated")]
impl std::ops::DerefMut
for crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVROverlay+ExternalSurfaceObjectCreated")]
impl crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated {
    pub fn BeginInvoke(
        &mut self,
        callback: quest_hook::libil2cpp::Gc<crate::System::AsyncCallback>,
        object: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<crate::System::IAsyncResult>,
    > {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    quest_hook::libil2cpp::Gc<crate::System::AsyncCallback>,
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                ),
                quest_hook::libil2cpp::Gc<crate::System::IAsyncResult>,
                2usize,
            >("BeginInvoke")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated as
                    quest_hook::libil2cpp::Type > ::class(), "BeginInvoke", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<crate::System::IAsyncResult> = unsafe {
            method.invoke_unchecked(self, (callback, object))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn EndInvoke(
        &mut self,
        result: quest_hook::libil2cpp::Gc<crate::System::IAsyncResult>,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (quest_hook::libil2cpp::Gc<crate::System::IAsyncResult>),
                quest_hook::libil2cpp::Void,
                1usize,
            >("EndInvoke")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated as
                    quest_hook::libil2cpp::Type > ::class(), "EndInvoke", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (result))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Invoke(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("Invoke")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated as
                    quest_hook::libil2cpp::Type > ::class(), "Invoke", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn New(
        object: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        method: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", (object, method))?;
        Ok(__cordl_object.into())
    }
    pub fn _ctor(
        &mut self,
        object: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        method: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::System::IntPtr,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >(".ctor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated as
                    quest_hook::libil2cpp::Type > ::class(), ".ctor", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (object, method))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "OVROverlay+ExternalSurfaceObjectCreated")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVROverlay_ExternalSurfaceObjectCreated {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "OVROverlay+LayerTexture")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVROverlay_LayerTexture {
    pub appTexture: quest_hook::libil2cpp::Gc<crate::UnityEngine::Texture>,
    pub appTexturePtr: crate::System::IntPtr,
    pub swapChain: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            quest_hook::libil2cpp::Gc<crate::UnityEngine::Texture>,
        >,
    >,
    pub swapChainPtr: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::System::IntPtr>,
    >,
}
#[cfg(feature = "OVROverlay+LayerTexture")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVROverlay_LayerTexture {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVROverlay/LayerTexture";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "OVROverlay+LayerTexture")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVROverlay_LayerTexture {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "OVROverlay+LayerTexture")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVROverlay_LayerTexture {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "OVROverlay+LayerTexture")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVROverlay_LayerTexture {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "OVROverlay+LayerTexture")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVROverlay_LayerTexture {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "OVROverlay+LayerTexture")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVROverlay_LayerTexture {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVROverlay+LayerTexture")]
impl crate::GlobalNamespace::OVROverlay_LayerTexture {}
#[cfg(feature = "OVROverlay+OverlayShape")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVROverlay_OverlayShape {
    #[default]
    Cubemap = 2i32,
    Cylinder = 1i32,
    Equirect = 5i32,
    Fisheye = 9i32,
    KeyboardHandsPassthrough = 10i32,
    KeyboardMaskedHandsPassthrough = 11i32,
    OffcenterCubemap = 4i32,
    Quad = 0i32,
    ReconstructionPassthrough = 7i32,
    SurfaceProjectedPassthrough = 8i32,
}
#[cfg(feature = "OVROverlay+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVROverlay_OverlayShape {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVROverlay/OverlayShape";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "OVROverlay+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVROverlay_OverlayShape {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "OVROverlay+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVROverlay_OverlayShape {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "OVROverlay+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVROverlay_OverlayShape {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "OVROverlay+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVROverlay_OverlayShape {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "OVROverlay+OverlayType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVROverlay_OverlayType {
    #[default]
    None = 0i32,
    Overlay = 2i32,
    Underlay = 1i32,
}
#[cfg(feature = "OVROverlay+OverlayType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVROverlay_OverlayType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVROverlay/OverlayType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "OVROverlay+OverlayType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVROverlay_OverlayType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "OVROverlay+OverlayType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVROverlay_OverlayType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "OVROverlay+OverlayType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVROverlay_OverlayType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "OVROverlay+OverlayType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVROverlay_OverlayType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
