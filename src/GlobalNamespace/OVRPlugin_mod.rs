#[cfg(feature = "cordl_class_OVRPlugin+Media+InputVideoBufferType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Media_OVRPlugin_InputVideoBufferType {
    #[default]
    EnumSize = 2147483647i32,
    Memory = 0i32,
    TextureHandle = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+InputVideoBufferType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Media/InputVideoBufferType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+InputVideoBufferType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+InputVideoBufferType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+InputVideoBufferType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+InputVideoBufferType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+MrcActivationMode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Media_OVRPlugin_MrcActivationMode {
    #[default]
    Automatic = 0i32,
    Disabled = 1i32,
    EnumSize = 2147483647i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+MrcActivationMode")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Media/MrcActivationMode";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+MrcActivationMode")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+MrcActivationMode")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+MrcActivationMode")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+MrcActivationMode")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+PlatformCameraMode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Media_OVRPlugin_PlatformCameraMode {
    #[default]
    Disabled = -1i32,
    EnumSize = 2147483647i32,
    Initialized = 0i32,
    MobileMRC = 7i32,
    RemoteDroneControlled = 4i32,
    RemoteSpatialMapped = 5i32,
    SmartNavigated = 2i32,
    SpectatorMode = 6i32,
    StabilizedPoV = 3i32,
    UserControlled = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+PlatformCameraMode")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Media/PlatformCameraMode";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+PlatformCameraMode")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+PlatformCameraMode")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+PlatformCameraMode")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media+PlatformCameraMode")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin")]
impl crate::GlobalNamespace::OVRPlugin {
    pub const AppPerfFrameStatsMaxCount: i32 = 5i32;
    pub const EventDataBufferSize: i32 = 4000i32;
    pub const OverlayShapeFlagShift: i32 = 4i32;
    pub const RENDER_MODEL_NULL_KEY: i32 = 0i32;
    pub const SpaceFilterInfoComponentsMaxSize: i32 = 16i32;
    pub const SpaceFilterInfoIdsMaxSize: i32 = 1024i32;
    pub const SpatialEntityMaxQueryResultsPerEvent: i32 = 128i32;
    pub const isSupportedPlatform: bool = true;
    pub const pluginName: &'static str = "OVRPlugin";
    #[cfg(feature = "OVRPlugin+AppPerfFrameStats")]
    pub type AppPerfFrameStats = crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats;
    #[cfg(feature = "OVRPlugin+AppPerfStats")]
    pub type AppPerfStats = crate::GlobalNamespace::OVRPlugin_AppPerfStats;
    #[cfg(feature = "OVRPlugin+BatteryStatus")]
    pub type BatteryStatus = crate::GlobalNamespace::OVRPlugin_BatteryStatus;
    #[cfg(feature = "OVRPlugin+BlendFactor")]
    pub type BlendFactor = crate::GlobalNamespace::OVRPlugin_BlendFactor;
    #[cfg(feature = "OVRPlugin+BodyJointLocation")]
    pub type BodyJointLocation = crate::GlobalNamespace::OVRPlugin_BodyJointLocation;
    #[cfg(feature = "OVRPlugin+BodyState")]
    pub type BodyState = crate::GlobalNamespace::OVRPlugin_BodyState;
    #[cfg(feature = "OVRPlugin+BodyStateInternal")]
    pub type BodyStateInternal = crate::GlobalNamespace::OVRPlugin_BodyStateInternal;
    #[cfg(feature = "OVRPlugin+Bone")]
    pub type Bone = crate::GlobalNamespace::OVRPlugin_Bone;
    #[cfg(feature = "OVRPlugin+BoneCapsule")]
    pub type BoneCapsule = crate::GlobalNamespace::OVRPlugin_BoneCapsule;
    #[cfg(feature = "OVRPlugin+BoneId")]
    pub type BoneId = crate::GlobalNamespace::OVRPlugin_BoneId;
    #[cfg(feature = "OVRPlugin+Bool")]
    pub type Bool = crate::GlobalNamespace::OVRPlugin_Bool;
    #[cfg(feature = "OVRPlugin+BoundaryGeometry")]
    pub type BoundaryGeometry = crate::GlobalNamespace::OVRPlugin_BoundaryGeometry;
    #[cfg(feature = "OVRPlugin+BoundaryTestResult")]
    pub type BoundaryTestResult = crate::GlobalNamespace::OVRPlugin_BoundaryTestResult;
    #[cfg(feature = "OVRPlugin+BoundaryType")]
    pub type BoundaryType = crate::GlobalNamespace::OVRPlugin_BoundaryType;
    #[cfg(feature = "OVRPlugin+Boundsf")]
    pub type Boundsf = crate::GlobalNamespace::OVRPlugin_Boundsf;
    #[cfg(feature = "OVRPlugin+CameraAnchorType")]
    pub type CameraAnchorType = crate::GlobalNamespace::OVRPlugin_CameraAnchorType;
    #[cfg(feature = "OVRPlugin+CameraDevice")]
    pub type CameraDevice = crate::GlobalNamespace::OVRPlugin_CameraDevice;
    #[cfg(feature = "OVRPlugin+CameraDeviceDepthQuality")]
    pub type CameraDeviceDepthQuality = crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthQuality;
    #[cfg(feature = "OVRPlugin+CameraDeviceDepthSensingMode")]
    pub type CameraDeviceDepthSensingMode = crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthSensingMode;
    #[cfg(feature = "OVRPlugin+CameraDeviceIntrinsicsParameters")]
    pub type CameraDeviceIntrinsicsParameters = crate::GlobalNamespace::OVRPlugin_CameraDeviceIntrinsicsParameters;
    #[cfg(feature = "OVRPlugin+CameraExtrinsics")]
    pub type CameraExtrinsics = crate::GlobalNamespace::OVRPlugin_CameraExtrinsics;
    #[cfg(feature = "OVRPlugin+CameraIntrinsics")]
    pub type CameraIntrinsics = crate::GlobalNamespace::OVRPlugin_CameraIntrinsics;
    #[cfg(feature = "OVRPlugin+CameraStatus")]
    pub type CameraStatus = crate::GlobalNamespace::OVRPlugin_CameraStatus;
    #[cfg(feature = "OVRPlugin+ColorSpace")]
    pub type ColorSpace = crate::GlobalNamespace::OVRPlugin_ColorSpace;
    #[cfg(feature = "OVRPlugin+Colorf")]
    pub type Colorf = crate::GlobalNamespace::OVRPlugin_Colorf;
    #[cfg(feature = "OVRPlugin+Controller")]
    pub type Controller = crate::GlobalNamespace::OVRPlugin_Controller;
    #[cfg(feature = "OVRPlugin+ControllerState")]
    pub type ControllerState = crate::GlobalNamespace::OVRPlugin_ControllerState;
    #[cfg(feature = "OVRPlugin+ControllerState2")]
    pub type ControllerState2 = crate::GlobalNamespace::OVRPlugin_ControllerState2;
    #[cfg(feature = "OVRPlugin+ControllerState4")]
    pub type ControllerState4 = crate::GlobalNamespace::OVRPlugin_ControllerState4;
    #[cfg(feature = "OVRPlugin+ControllerState5")]
    pub type ControllerState5 = crate::GlobalNamespace::OVRPlugin_ControllerState5;
    #[cfg(feature = "OVRPlugin+ControllerState6")]
    pub type ControllerState6 = crate::GlobalNamespace::OVRPlugin_ControllerState6;
    #[cfg(feature = "OVRPlugin+EventDataBuffer")]
    pub type EventDataBuffer = crate::GlobalNamespace::OVRPlugin_EventDataBuffer;
    #[cfg(feature = "OVRPlugin+EventType")]
    pub type EventType = crate::GlobalNamespace::OVRPlugin_EventType;
    #[cfg(feature = "OVRPlugin+Eye")]
    pub type Eye = crate::GlobalNamespace::OVRPlugin_Eye;
    #[cfg(feature = "OVRPlugin+EyeGazeState")]
    pub type EyeGazeState = crate::GlobalNamespace::OVRPlugin_EyeGazeState;
    #[cfg(feature = "OVRPlugin+EyeGazesState")]
    pub type EyeGazesState = crate::GlobalNamespace::OVRPlugin_EyeGazesState;
    #[cfg(feature = "OVRPlugin+EyeGazesStateInternal")]
    pub type EyeGazesStateInternal = crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal;
    #[cfg(feature = "OVRPlugin+EyeTextureFormat")]
    pub type EyeTextureFormat = crate::GlobalNamespace::OVRPlugin_EyeTextureFormat;
    #[cfg(feature = "OVRPlugin+FaceConstants")]
    pub type FaceConstants = crate::GlobalNamespace::OVRPlugin_FaceConstants;
    #[cfg(feature = "OVRPlugin+FaceExpression")]
    pub type FaceExpression = crate::GlobalNamespace::OVRPlugin_FaceExpression;
    #[cfg(feature = "OVRPlugin+FaceExpressionStatus")]
    pub type FaceExpressionStatus = crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus;
    #[cfg(feature = "OVRPlugin+FaceExpressionStatusInternal")]
    pub type FaceExpressionStatusInternal = crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal;
    #[cfg(feature = "OVRPlugin+FaceRegionConfidence")]
    pub type FaceRegionConfidence = crate::GlobalNamespace::OVRPlugin_FaceRegionConfidence;
    #[cfg(feature = "OVRPlugin+FaceState")]
    pub type FaceState = crate::GlobalNamespace::OVRPlugin_FaceState;
    #[cfg(feature = "OVRPlugin+FaceState2Internal")]
    pub type FaceState2Internal = crate::GlobalNamespace::OVRPlugin_FaceState2Internal;
    #[cfg(feature = "OVRPlugin+FaceStateInternal")]
    pub type FaceStateInternal = crate::GlobalNamespace::OVRPlugin_FaceStateInternal;
    #[cfg(feature = "OVRPlugin+FeatureType")]
    pub type FeatureType = crate::GlobalNamespace::OVRPlugin_FeatureType;
    #[cfg(feature = "OVRPlugin+FixedFoveatedRenderingLevel")]
    pub type FixedFoveatedRenderingLevel = crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel;
    #[cfg(feature = "OVRPlugin+FoveatedRenderingLevel")]
    pub type FoveatedRenderingLevel = crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel;
    #[cfg(feature = "OVRPlugin+Fovf")]
    pub type Fovf = crate::GlobalNamespace::OVRPlugin_Fovf;
    #[cfg(feature = "OVRPlugin+Frustumf")]
    pub type Frustumf = crate::GlobalNamespace::OVRPlugin_Frustumf;
    #[cfg(feature = "OVRPlugin+Frustumf2")]
    pub type Frustumf2 = crate::GlobalNamespace::OVRPlugin_Frustumf2;
    #[cfg(feature = "OVRPlugin+GUID")]
    pub type GUID = crate::GlobalNamespace::OVRPlugin_GUID;
    #[cfg(feature = "OVRPlugin+Hand")]
    pub type Hand = crate::GlobalNamespace::OVRPlugin_Hand;
    #[cfg(feature = "OVRPlugin+HandFinger")]
    pub type HandFinger = crate::GlobalNamespace::OVRPlugin_HandFinger;
    #[cfg(feature = "OVRPlugin+HandFingerPinch")]
    pub type HandFingerPinch = crate::GlobalNamespace::OVRPlugin_HandFingerPinch;
    #[cfg(feature = "OVRPlugin+HandState")]
    pub type HandState = crate::GlobalNamespace::OVRPlugin_HandState;
    #[cfg(feature = "OVRPlugin+HandStateInternal")]
    pub type HandStateInternal = crate::GlobalNamespace::OVRPlugin_HandStateInternal;
    #[cfg(feature = "OVRPlugin+HandStatus")]
    pub type HandStatus = crate::GlobalNamespace::OVRPlugin_HandStatus;
    #[cfg(feature = "OVRPlugin+Handedness")]
    pub type Handedness = crate::GlobalNamespace::OVRPlugin_Handedness;
    #[cfg(feature = "OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
    pub type HapticsAmplitudeEnvelopeVibration = crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration;
    #[cfg(feature = "OVRPlugin+HapticsBuffer")]
    pub type HapticsBuffer = crate::GlobalNamespace::OVRPlugin_HapticsBuffer;
    #[cfg(feature = "OVRPlugin+HapticsConstants")]
    pub type HapticsConstants = crate::GlobalNamespace::OVRPlugin_HapticsConstants;
    #[cfg(feature = "OVRPlugin+HapticsDesc")]
    pub type HapticsDesc = crate::GlobalNamespace::OVRPlugin_HapticsDesc;
    #[cfg(feature = "OVRPlugin+HapticsLocation")]
    pub type HapticsLocation = crate::GlobalNamespace::OVRPlugin_HapticsLocation;
    #[cfg(feature = "OVRPlugin+HapticsPcmVibration")]
    pub type HapticsPcmVibration = crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration;
    #[cfg(feature = "OVRPlugin+HapticsState")]
    pub type HapticsState = crate::GlobalNamespace::OVRPlugin_HapticsState;
    #[cfg(feature = "OVRPlugin+InsightPassthroughColorMapType")]
    pub type InsightPassthroughColorMapType = crate::GlobalNamespace::OVRPlugin_InsightPassthroughColorMapType;
    #[cfg(feature = "OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
    pub type InsightPassthroughKeyboardHandsIntensity = crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity;
    #[cfg(feature = "OVRPlugin+InsightPassthroughStyle")]
    pub type InsightPassthroughStyle = crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle;
    #[cfg(feature = "OVRPlugin+InsightPassthroughStyle2")]
    pub type InsightPassthroughStyle2 = crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2;
    #[cfg(feature = "OVRPlugin+InsightPassthroughStyleFlags")]
    pub type InsightPassthroughStyleFlags = crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyleFlags;
    #[cfg(feature = "OVRPlugin+InteractionProfile")]
    pub type InteractionProfile = crate::GlobalNamespace::OVRPlugin_InteractionProfile;
    #[cfg(feature = "OVRPlugin+KeyboardDescription")]
    pub type KeyboardDescription = crate::GlobalNamespace::OVRPlugin_KeyboardDescription;
    #[cfg(feature = "OVRPlugin+KeyboardDescriptionConstants")]
    pub type KeyboardDescriptionConstants = crate::GlobalNamespace::OVRPlugin_KeyboardDescriptionConstants;
    #[cfg(feature = "OVRPlugin+KeyboardState")]
    pub type KeyboardState = crate::GlobalNamespace::OVRPlugin_KeyboardState;
    #[cfg(feature = "OVRPlugin+Ktx")]
    pub type Ktx = crate::GlobalNamespace::OVRPlugin_Ktx;
    #[cfg(feature = "OVRPlugin+LayerDesc")]
    pub type LayerDesc = crate::GlobalNamespace::OVRPlugin_LayerDesc;
    #[cfg(feature = "OVRPlugin+LayerDescInternal")]
    pub type LayerDescInternal = crate::GlobalNamespace::OVRPlugin_LayerDescInternal;
    #[cfg(feature = "OVRPlugin+LayerFlags")]
    pub type LayerFlags = crate::GlobalNamespace::OVRPlugin_LayerFlags;
    #[cfg(feature = "OVRPlugin+LayerLayout")]
    pub type LayerLayout = crate::GlobalNamespace::OVRPlugin_LayerLayout;
    #[cfg(feature = "OVRPlugin+LayerSharpenType")]
    pub type LayerSharpenType = crate::GlobalNamespace::OVRPlugin_LayerSharpenType;
    #[cfg(feature = "OVRPlugin+LayerSubmit")]
    pub type LayerSubmit = crate::GlobalNamespace::OVRPlugin_LayerSubmit;
    #[cfg(feature = "OVRPlugin+LayerSuperSamplingType")]
    pub type LayerSuperSamplingType = crate::GlobalNamespace::OVRPlugin_LayerSuperSamplingType;
    #[cfg(feature = "OVRPlugin+LogCallback2DelegateType")]
    pub type LogCallback2DelegateType = crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType;
    #[cfg(feature = "OVRPlugin+LogLevel")]
    pub type LogLevel = crate::GlobalNamespace::OVRPlugin_LogLevel;
    #[cfg(feature = "OVRPlugin+Media")]
    pub type Media = crate::GlobalNamespace::OVRPlugin_Media;
    #[cfg(feature = "OVRPlugin+Mesh")]
    pub type Mesh = crate::GlobalNamespace::OVRPlugin_Mesh;
    #[cfg(feature = "OVRPlugin+MeshConstants")]
    pub type MeshConstants = crate::GlobalNamespace::OVRPlugin_MeshConstants;
    #[cfg(feature = "OVRPlugin+MeshType")]
    pub type MeshType = crate::GlobalNamespace::OVRPlugin_MeshType;
    #[cfg(feature = "OVRPlugin+Node")]
    pub type Node = crate::GlobalNamespace::OVRPlugin_Node;
    #[cfg(feature = "OVRPlugin+OVRP_0_1_0")]
    pub type OVRP_0_1_0 = crate::GlobalNamespace::OVRPlugin_OVRP_0_1_0;
    #[cfg(feature = "OVRPlugin+OVRP_0_1_1")]
    pub type OVRP_0_1_1 = crate::GlobalNamespace::OVRPlugin_OVRP_0_1_1;
    #[cfg(feature = "OVRPlugin+OVRP_0_1_2")]
    pub type OVRP_0_1_2 = crate::GlobalNamespace::OVRPlugin_OVRP_0_1_2;
    #[cfg(feature = "OVRPlugin+OVRP_0_1_3")]
    pub type OVRP_0_1_3 = crate::GlobalNamespace::OVRPlugin_OVRP_0_1_3;
    #[cfg(feature = "OVRPlugin+OVRP_0_5_0")]
    pub type OVRP_0_5_0 = crate::GlobalNamespace::OVRPlugin_OVRP_0_5_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_0_0")]
    pub type OVRP_1_0_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_0_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_10_0")]
    pub type OVRP_1_10_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_10_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_11_0")]
    pub type OVRP_1_11_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_11_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_12_0")]
    pub type OVRP_1_12_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_12_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_15_0")]
    pub type OVRP_1_15_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_15_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_16_0")]
    pub type OVRP_1_16_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_16_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_17_0")]
    pub type OVRP_1_17_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_17_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_18_0")]
    pub type OVRP_1_18_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_18_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_19_0")]
    pub type OVRP_1_19_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_19_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_1_0")]
    pub type OVRP_1_1_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_1_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_21_0")]
    pub type OVRP_1_21_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_21_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_28_0")]
    pub type OVRP_1_28_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_28_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_29_0")]
    pub type OVRP_1_29_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_29_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_2_0")]
    pub type OVRP_1_2_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_2_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_30_0")]
    pub type OVRP_1_30_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_30_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_31_0")]
    pub type OVRP_1_31_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_31_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_32_0")]
    pub type OVRP_1_32_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_32_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_34_0")]
    pub type OVRP_1_34_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_34_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_35_0")]
    pub type OVRP_1_35_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_35_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_36_0")]
    pub type OVRP_1_36_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_36_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_37_0")]
    pub type OVRP_1_37_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_37_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_38_0")]
    pub type OVRP_1_38_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_38_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_39_0")]
    pub type OVRP_1_39_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_39_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_3_0")]
    pub type OVRP_1_3_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_3_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_40_0")]
    pub type OVRP_1_40_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_40_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_41_0")]
    pub type OVRP_1_41_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_41_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_42_0")]
    pub type OVRP_1_42_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_42_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_43_0")]
    pub type OVRP_1_43_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_43_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_44_0")]
    pub type OVRP_1_44_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_44_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_45_0")]
    pub type OVRP_1_45_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_45_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_46_0")]
    pub type OVRP_1_46_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_46_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_47_0")]
    pub type OVRP_1_47_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_47_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_48_0")]
    pub type OVRP_1_48_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_48_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_49_0")]
    pub type OVRP_1_49_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_49_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_50_0")]
    pub type OVRP_1_50_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_50_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_51_0")]
    pub type OVRP_1_51_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_51_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_52_0")]
    pub type OVRP_1_52_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_52_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_53_0")]
    pub type OVRP_1_53_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_53_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_54_0")]
    pub type OVRP_1_54_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_54_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_55_0")]
    pub type OVRP_1_55_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_55_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_55_1")]
    pub type OVRP_1_55_1 = crate::GlobalNamespace::OVRPlugin_OVRP_1_55_1;
    #[cfg(feature = "OVRPlugin+OVRP_1_56_0")]
    pub type OVRP_1_56_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_56_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_57_0")]
    pub type OVRP_1_57_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_57_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_58_0")]
    pub type OVRP_1_58_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_58_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_59_0")]
    pub type OVRP_1_59_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_59_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_5_0")]
    pub type OVRP_1_5_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_5_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_60_0")]
    pub type OVRP_1_60_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_60_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_61_0")]
    pub type OVRP_1_61_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_61_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_62_0")]
    pub type OVRP_1_62_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_62_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_63_0")]
    pub type OVRP_1_63_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_63_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_64_0")]
    pub type OVRP_1_64_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_64_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_65_0")]
    pub type OVRP_1_65_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_65_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_66_0")]
    pub type OVRP_1_66_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_66_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_67_0")]
    pub type OVRP_1_67_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_67_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_68_0")]
    pub type OVRP_1_68_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_68_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_69_0")]
    pub type OVRP_1_69_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_69_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_6_0")]
    pub type OVRP_1_6_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_6_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_70_0")]
    pub type OVRP_1_70_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_70_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_71_0")]
    pub type OVRP_1_71_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_71_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_72_0")]
    pub type OVRP_1_72_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_72_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_73_0")]
    pub type OVRP_1_73_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_73_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_74_0")]
    pub type OVRP_1_74_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_74_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_75_0")]
    pub type OVRP_1_75_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_75_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_76_0")]
    pub type OVRP_1_76_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_76_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_78_0")]
    pub type OVRP_1_78_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_78_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_79_0")]
    pub type OVRP_1_79_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_79_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_7_0")]
    pub type OVRP_1_7_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_7_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_81_0")]
    pub type OVRP_1_81_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_81_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_82_0")]
    pub type OVRP_1_82_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_82_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_83_0")]
    pub type OVRP_1_83_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_83_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_84_0")]
    pub type OVRP_1_84_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_84_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_85_0")]
    pub type OVRP_1_85_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_85_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_86_0")]
    pub type OVRP_1_86_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_86_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_87_0")]
    pub type OVRP_1_87_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_87_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_88_0")]
    pub type OVRP_1_88_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_88_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_8_0")]
    pub type OVRP_1_8_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_8_0;
    #[cfg(feature = "OVRPlugin+OVRP_1_9_0")]
    pub type OVRP_1_9_0 = crate::GlobalNamespace::OVRPlugin_OVRP_1_9_0;
    #[cfg(feature = "OVRPlugin+OverlayFlag")]
    pub type OverlayFlag = crate::GlobalNamespace::OVRPlugin_OverlayFlag;
    #[cfg(feature = "OVRPlugin+OverlayShape")]
    pub type OverlayShape = crate::GlobalNamespace::OVRPlugin_OverlayShape;
    #[cfg(feature = "OVRPlugin+PassthroughCapabilities")]
    pub type PassthroughCapabilities = crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities;
    #[cfg(feature = "OVRPlugin+PassthroughCapabilityFields")]
    pub type PassthroughCapabilityFields = crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFields;
    #[cfg(feature = "OVRPlugin+PassthroughCapabilityFlags")]
    pub type PassthroughCapabilityFlags = crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags;
    #[cfg(feature = "OVRPlugin+PassthroughColorLutChannels")]
    pub type PassthroughColorLutChannels = crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels;
    #[cfg(feature = "OVRPlugin+PassthroughColorLutData")]
    pub type PassthroughColorLutData = crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData;
    #[cfg(feature = "OVRPlugin+PassthroughPreferenceFields")]
    pub type PassthroughPreferenceFields = crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFields;
    #[cfg(feature = "OVRPlugin+PassthroughPreferenceFlags")]
    pub type PassthroughPreferenceFlags = crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFlags;
    #[cfg(feature = "OVRPlugin+PassthroughPreferences")]
    pub type PassthroughPreferences = crate::GlobalNamespace::OVRPlugin_PassthroughPreferences;
    #[cfg(feature = "OVRPlugin+PerfMetrics")]
    pub type PerfMetrics = crate::GlobalNamespace::OVRPlugin_PerfMetrics;
    #[cfg(feature = "OVRPlugin+PinnedArray_1")]
    pub type PinnedArray_1<T: quest_hook::libil2cpp::Type> = crate::GlobalNamespace::OVRPlugin_PinnedArray_1<
        T,
    >;
    #[cfg(feature = "OVRPlugin+PlatformUI")]
    pub type PlatformUI = crate::GlobalNamespace::OVRPlugin_PlatformUI;
    #[cfg(feature = "OVRPlugin+PolygonalBoundary2DInternal")]
    pub type PolygonalBoundary2DInternal = crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal;
    #[cfg(feature = "OVRPlugin+PoseStatef")]
    pub type PoseStatef = crate::GlobalNamespace::OVRPlugin_PoseStatef;
    #[cfg(feature = "OVRPlugin+Posef")]
    pub type Posef = crate::GlobalNamespace::OVRPlugin_Posef;
    #[cfg(feature = "OVRPlugin+ProcessorPerformanceLevel")]
    pub type ProcessorPerformanceLevel = crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel;
    #[cfg(feature = "OVRPlugin+Qpl")]
    pub type Qpl = crate::GlobalNamespace::OVRPlugin_Qpl;
    #[cfg(feature = "OVRPlugin+Quatf")]
    pub type Quatf = crate::GlobalNamespace::OVRPlugin_Quatf;
    #[cfg(feature = "OVRPlugin+RecenterFlags")]
    pub type RecenterFlags = crate::GlobalNamespace::OVRPlugin_RecenterFlags;
    #[cfg(feature = "OVRPlugin+Rectf")]
    pub type Rectf = crate::GlobalNamespace::OVRPlugin_Rectf;
    #[cfg(feature = "OVRPlugin+Recti")]
    pub type Recti = crate::GlobalNamespace::OVRPlugin_Recti;
    #[cfg(feature = "OVRPlugin+RenderModelFlags")]
    pub type RenderModelFlags = crate::GlobalNamespace::OVRPlugin_RenderModelFlags;
    #[cfg(feature = "OVRPlugin+RenderModelProperties")]
    pub type RenderModelProperties = crate::GlobalNamespace::OVRPlugin_RenderModelProperties;
    #[cfg(feature = "OVRPlugin+RenderModelPropertiesInternal")]
    pub type RenderModelPropertiesInternal = crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal;
    #[cfg(feature = "OVRPlugin+Result")]
    pub type Result = crate::GlobalNamespace::OVRPlugin_Result;
    #[cfg(feature = "OVRPlugin+RoomLayout")]
    pub type RoomLayout = crate::GlobalNamespace::OVRPlugin_RoomLayout;
    #[cfg(feature = "OVRPlugin+RoomLayoutInternal")]
    pub type RoomLayoutInternal = crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal;
    #[cfg(feature = "OVRPlugin+SceneCaptureRequestInternal")]
    pub type SceneCaptureRequestInternal = crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal;
    #[cfg(feature = "OVRPlugin+Size3f")]
    pub type Size3f = crate::GlobalNamespace::OVRPlugin_Size3f;
    #[cfg(feature = "OVRPlugin+Sizef")]
    pub type Sizef = crate::GlobalNamespace::OVRPlugin_Sizef;
    #[cfg(feature = "OVRPlugin+Sizei")]
    pub type Sizei = crate::GlobalNamespace::OVRPlugin_Sizei;
    #[cfg(feature = "OVRPlugin+Skeleton")]
    pub type Skeleton = crate::GlobalNamespace::OVRPlugin_Skeleton;
    #[cfg(feature = "OVRPlugin+Skeleton2")]
    pub type Skeleton2 = crate::GlobalNamespace::OVRPlugin_Skeleton2;
    #[cfg(feature = "OVRPlugin+Skeleton2Internal")]
    pub type Skeleton2Internal = crate::GlobalNamespace::OVRPlugin_Skeleton2Internal;
    #[cfg(feature = "OVRPlugin+SkeletonConstants")]
    pub type SkeletonConstants = crate::GlobalNamespace::OVRPlugin_SkeletonConstants;
    #[cfg(feature = "OVRPlugin+SkeletonType")]
    pub type SkeletonType = crate::GlobalNamespace::OVRPlugin_SkeletonType;
    #[cfg(feature = "OVRPlugin+SpaceComponentType")]
    pub type SpaceComponentType = crate::GlobalNamespace::OVRPlugin_SpaceComponentType;
    #[cfg(feature = "OVRPlugin+SpaceContainerInternal")]
    pub type SpaceContainerInternal = crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal;
    #[cfg(feature = "OVRPlugin+SpaceFilterInfoComponents")]
    pub type SpaceFilterInfoComponents = crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents;
    #[cfg(feature = "OVRPlugin+SpaceFilterInfoIds")]
    pub type SpaceFilterInfoIds = crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds;
    #[cfg(feature = "OVRPlugin+SpaceLocationFlags")]
    pub type SpaceLocationFlags = crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags;
    #[cfg(feature = "OVRPlugin+SpaceLocationf")]
    pub type SpaceLocationf = crate::GlobalNamespace::OVRPlugin_SpaceLocationf;
    #[cfg(feature = "OVRPlugin+SpaceQueryActionType")]
    pub type SpaceQueryActionType = crate::GlobalNamespace::OVRPlugin_SpaceQueryActionType;
    #[cfg(feature = "OVRPlugin+SpaceQueryFilterType")]
    pub type SpaceQueryFilterType = crate::GlobalNamespace::OVRPlugin_SpaceQueryFilterType;
    #[cfg(feature = "OVRPlugin+SpaceQueryInfo")]
    pub type SpaceQueryInfo = crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo;
    #[cfg(feature = "OVRPlugin+SpaceQueryResult")]
    pub type SpaceQueryResult = crate::GlobalNamespace::OVRPlugin_SpaceQueryResult;
    #[cfg(feature = "OVRPlugin+SpaceQueryType")]
    pub type SpaceQueryType = crate::GlobalNamespace::OVRPlugin_SpaceQueryType;
    #[cfg(feature = "OVRPlugin+SpaceSemanticLabelInternal")]
    pub type SpaceSemanticLabelInternal = crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal;
    #[cfg(feature = "OVRPlugin+SpaceStorageLocation")]
    pub type SpaceStorageLocation = crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation;
    #[cfg(feature = "OVRPlugin+SpaceStoragePersistenceMode")]
    pub type SpaceStoragePersistenceMode = crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode;
    #[cfg(feature = "OVRPlugin+SpatialAnchorCreateInfo")]
    pub type SpatialAnchorCreateInfo = crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo;
    #[cfg(feature = "OVRPlugin+Step")]
    pub type Step = crate::GlobalNamespace::OVRPlugin_Step;
    #[cfg(feature = "OVRPlugin+SystemHeadset")]
    pub type SystemHeadset = crate::GlobalNamespace::OVRPlugin_SystemHeadset;
    #[cfg(feature = "OVRPlugin+SystemRegion")]
    pub type SystemRegion = crate::GlobalNamespace::OVRPlugin_SystemRegion;
    #[cfg(feature = "OVRPlugin+TextureRectMatrixf")]
    pub type TextureRectMatrixf = crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf;
    #[cfg(feature = "OVRPlugin+TiledMultiResLevel")]
    pub type TiledMultiResLevel = crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel;
    #[cfg(feature = "OVRPlugin+TrackedKeyboardFlags")]
    pub type TrackedKeyboardFlags = crate::GlobalNamespace::OVRPlugin_TrackedKeyboardFlags;
    #[cfg(feature = "OVRPlugin+TrackedKeyboardPresentationStyles")]
    pub type TrackedKeyboardPresentationStyles = crate::GlobalNamespace::OVRPlugin_TrackedKeyboardPresentationStyles;
    #[cfg(feature = "OVRPlugin+TrackedKeyboardQueryFlags")]
    pub type TrackedKeyboardQueryFlags = crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags;
    #[cfg(feature = "OVRPlugin+Tracker")]
    pub type Tracker = crate::GlobalNamespace::OVRPlugin_Tracker;
    #[cfg(feature = "OVRPlugin+TrackingConfidence")]
    pub type TrackingConfidence = crate::GlobalNamespace::OVRPlugin_TrackingConfidence;
    #[cfg(feature = "OVRPlugin+TrackingOrigin")]
    pub type TrackingOrigin = crate::GlobalNamespace::OVRPlugin_TrackingOrigin;
    #[cfg(feature = "OVRPlugin+TriangleMeshInternal")]
    pub type TriangleMeshInternal = crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal;
    #[cfg(feature = "OVRPlugin+UnityOpenXR")]
    pub type UnityOpenXR = crate::GlobalNamespace::OVRPlugin_UnityOpenXR;
    #[cfg(feature = "OVRPlugin+Vector2f")]
    pub type Vector2f = crate::GlobalNamespace::OVRPlugin_Vector2f;
    #[cfg(feature = "OVRPlugin+Vector2i")]
    pub type Vector2i = crate::GlobalNamespace::OVRPlugin_Vector2i;
    #[cfg(feature = "OVRPlugin+Vector3f")]
    pub type Vector3f = crate::GlobalNamespace::OVRPlugin_Vector3f;
    #[cfg(feature = "OVRPlugin+Vector4f")]
    pub type Vector4f = crate::GlobalNamespace::OVRPlugin_Vector4f;
    #[cfg(feature = "OVRPlugin+Vector4s")]
    pub type Vector4s = crate::GlobalNamespace::OVRPlugin_Vector4s;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardCreateInfo")]
    pub type VirtualKeyboardCreateInfo = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardInputInfo")]
    pub type VirtualKeyboardInputInfo = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardInputSource")]
    pub type VirtualKeyboardInputSource = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputSource;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardInputStateFlags")]
    pub type VirtualKeyboardInputStateFlags = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputStateFlags;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardLocationInfo")]
    pub type VirtualKeyboardLocationInfo = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardLocationType")]
    pub type VirtualKeyboardLocationType = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationType;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardModelAnimationState")]
    pub type VirtualKeyboardModelAnimationState = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardModelAnimationStates")]
    pub type VirtualKeyboardModelAnimationStates = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
    pub type VirtualKeyboardModelAnimationStatesInternal = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardModelVisibility")]
    pub type VirtualKeyboardModelVisibility = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
    pub type VirtualKeyboardSpaceCreateInfo = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardTextureData")]
    pub type VirtualKeyboardTextureData = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardTextureIds")]
    pub type VirtualKeyboardTextureIds = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds;
    #[cfg(feature = "OVRPlugin+VirtualKeyboardTextureIdsInternal")]
    pub type VirtualKeyboardTextureIdsInternal = crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal;
    #[cfg(feature = "OVRPlugin+XrApi")]
    pub type XrApi = crate::GlobalNamespace::OVRPlugin_XrApi;
    pub fn AddCustomMetadata(
        name: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        param: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                        ),
                        bool,
                        2usize,
                    >("AddCustomMetadata")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "AddCustomMetadata", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (name, param))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn AddInsightPassthroughSurfaceGeometry(
        layerId: i32,
        meshHandle: u64,
        T_world_model: crate::UnityEngine::Matrix4x4,
        geometryInstanceHandle: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            u64,
                            crate::UnityEngine::Matrix4x4,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        4usize,
                    >("AddInsightPassthroughSurfaceGeometry")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "AddInsightPassthroughSurfaceGeometry", 4usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (layerId, meshHandle, T_world_model, geometryInstanceHandle),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn AreControllerDrivenHandPosesNatural() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("AreControllerDrivenHandPosesNatural")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "AreControllerDrivenHandPosesNatural", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn AreHandPosesGeneratedByControllerData(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            crate::GlobalNamespace::OVRPlugin_Node,
                        ),
                        bool,
                        2usize,
                    >("AreHandPosesGeneratedByControllerData")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "AreHandPosesGeneratedByControllerData", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CalculateLayerDesc(
        shape: crate::GlobalNamespace::OVRPlugin_OverlayShape,
        layout: crate::GlobalNamespace::OVRPlugin_LayerLayout,
        textureSize: crate::GlobalNamespace::OVRPlugin_Sizei,
        mipLevels: i32,
        sampleCount: i32,
        format: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
        layerFlags: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_LayerDesc> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_OverlayShape,
                            crate::GlobalNamespace::OVRPlugin_LayerLayout,
                            crate::GlobalNamespace::OVRPlugin_Sizei,
                            i32,
                            i32,
                            crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
                            i32,
                        ),
                        crate::GlobalNamespace::OVRPlugin_LayerDesc,
                        7usize,
                    >("CalculateLayerDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "CalculateLayerDesc", 7usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_LayerDesc = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        shape,
                        layout,
                        textureSize,
                        mipLevels,
                        sampleCount,
                        format,
                        layerFlags,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ChangeVirtualKeyboardTextContext(
        textContext: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ChangeVirtualKeyboardTextContext")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ChangeVirtualKeyboardTextContext", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (textContext))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CreateInsightTriangleMesh(
        layerId: i32,
        vertices: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppArray<crate::UnityEngine::Vector3>,
        >,
        triangles: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<i32>>,
        meshHandle: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppArray<
                                    crate::UnityEngine::Vector3,
                                >,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppArray<i32>,
                            >,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        4usize,
                    >("CreateInsightTriangleMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "CreateInsightTriangleMesh", 4usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (layerId, vertices, triangles, meshHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CreatePassthroughColorLut(
        channels: crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels,
        resolution: u32,
        data: crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData,
        colorLut: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels,
                            u32,
                            crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        4usize,
                    >("CreatePassthroughColorLut")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "CreatePassthroughColorLut", 4usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (channels, resolution, data, colorLut))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CreateSpaceUser(
        spaceUserId: u64,
        spaceUserHandle: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, quest_hook::libil2cpp::ByRefMut<u64>),
                        bool,
                        2usize,
                    >("CreateSpaceUser")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "CreateSpaceUser", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (spaceUserId, spaceUserHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CreateSpatialAnchor(
        createInfo: crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        2usize,
                    >("CreateSpatialAnchor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "CreateSpatialAnchor", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (createInfo, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CreateVirtualKeyboard(
        createInfo: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("CreateVirtualKeyboard")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "CreateVirtualKeyboard", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (createInfo))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CreateVirtualKeyboardSpace(
        createInfo: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo,
        keyboardSpace: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("CreateVirtualKeyboardSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "CreateVirtualKeyboardSpace", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (createInfo, keyboardSpace))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroyInsightPassthroughGeometryInstance(
        geometryInstanceHandle: u64,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        bool,
                        1usize,
                    >("DestroyInsightPassthroughGeometryInstance")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "DestroyInsightPassthroughGeometryInstance", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (geometryInstanceHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroyInsightTriangleMesh(
        meshHandle: u64,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        bool,
                        1usize,
                    >("DestroyInsightTriangleMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "DestroyInsightTriangleMesh", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (meshHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroyPassthroughColorLut(
        colorLut: u64,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        bool,
                        1usize,
                    >("DestroyPassthroughColorLut")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "DestroyPassthroughColorLut", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (colorLut))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroySpace(space: u64) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), bool, 1usize>("DestroySpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "DestroySpace", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroySpaceUser(
        spaceUserHandle: u64,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), bool, 1usize>("DestroySpaceUser")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "DestroySpaceUser", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (spaceUserHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroyVirtualKeyboard() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("DestroyVirtualKeyboard")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "DestroyVirtualKeyboard", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn EnqueueDestroyLayer(
        layerID: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        bool,
                        1usize,
                    >("EnqueueDestroyLayer")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "EnqueueDestroyLayer", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (layerID))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn EnqueueSetupLayer(
        desc: crate::GlobalNamespace::OVRPlugin_LayerDesc,
        compositionDepth: i32,
        layerID: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_LayerDesc,
                            i32,
                            crate::System::IntPtr,
                        ),
                        bool,
                        3usize,
                    >("EnqueueSetupLayer")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "EnqueueSetupLayer", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (desc, compositionDepth, layerID))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn EnqueueSubmitLayer(
        onTop: bool,
        headLocked: bool,
        noDepthBufferTesting: bool,
        leftTexture: crate::System::IntPtr,
        rightTexture: crate::System::IntPtr,
        layerId: i32,
        frameIndex: i32,
        pose: crate::GlobalNamespace::OVRPlugin_Posef,
        scale: crate::GlobalNamespace::OVRPlugin_Vector3f,
        layerIndex: i32,
        shape: crate::GlobalNamespace::OVRPlugin_OverlayShape,
        overrideTextureRectMatrix: bool,
        textureRectMatrix: crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf,
        overridePerLayerColorScaleAndOffset: bool,
        colorScale: crate::UnityEngine::Vector4,
        colorOffset: crate::UnityEngine::Vector4,
        expensiveSuperSample: bool,
        bicubic: bool,
        efficientSuperSample: bool,
        efficientSharpen: bool,
        expensiveSharpen: bool,
        hidden: bool,
        secureContent: bool,
        automaticFiltering: bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            bool,
                            bool,
                            bool,
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            i32,
                            i32,
                            crate::GlobalNamespace::OVRPlugin_Posef,
                            crate::GlobalNamespace::OVRPlugin_Vector3f,
                            i32,
                            crate::GlobalNamespace::OVRPlugin_OverlayShape,
                            bool,
                            crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf,
                            bool,
                            crate::UnityEngine::Vector4,
                            crate::UnityEngine::Vector4,
                            bool,
                            bool,
                            bool,
                            bool,
                            bool,
                            bool,
                            bool,
                            bool,
                        ),
                        bool,
                        24usize,
                    >("EnqueueSubmitLayer")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "EnqueueSubmitLayer", 24usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        onTop,
                        headLocked,
                        noDepthBufferTesting,
                        leftTexture,
                        rightTexture,
                        layerId,
                        frameIndex,
                        pose,
                        scale,
                        layerIndex,
                        shape,
                        overrideTextureRectMatrix,
                        textureRectMatrix,
                        overridePerLayerColorScaleAndOffset,
                        colorScale,
                        colorOffset,
                        expensiveSuperSample,
                        bicubic,
                        efficientSuperSample,
                        efficientSharpen,
                        expensiveSharpen,
                        hidden,
                        secureContent,
                        automaticFiltering,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn EnumerateSpaceSupportedComponents(
        space: u64,
        numSupportedComponents: quest_hook::libil2cpp::ByRefMut<u32>,
        supportedComponents: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppArray<
                crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
            >,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<u32>,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppArray<
                                    crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
                                >,
                            >,
                        ),
                        bool,
                        3usize,
                    >("EnumerateSpaceSupportedComponents")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "EnumerateSpaceSupportedComponents", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (space, numSupportedComponents, supportedComponents),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn EraseSpace(
        space: u64,
        location: crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        3usize,
                    >("EraseSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "EraseSpace", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, location, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetActiveController() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Controller,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Controller,
                        0usize,
                    >("GetActiveController")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetActiveController", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Controller = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetAdaptiveGPUPerformanceScale() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        f32,
                        0usize,
                    >("GetAdaptiveGPUPerformanceScale")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetAdaptiveGPUPerformanceScale", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetAppCpuStartToGpuEndTime() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("GetAppCpuStartToGpuEndTime")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetAppCpuStartToGpuEndTime", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetAppFramerate() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("GetAppFramerate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetAppFramerate", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetAppPerfStats() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_AppPerfStats,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_AppPerfStats,
                        0usize,
                    >("GetAppPerfStats")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetAppPerfStats", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_AppPerfStats = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetBodyState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        bodyState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_BodyState,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_BodyState,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetBodyState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetBodyState", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, bodyState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetBoundaryConfigured() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("GetBoundaryConfigured")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetBoundaryConfigured", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetBoundaryDimensions(
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Vector3f> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_BoundaryType),
                        crate::GlobalNamespace::OVRPlugin_Vector3f,
                        1usize,
                    >("GetBoundaryDimensions")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetBoundaryDimensions", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Vector3f = unsafe {
            cordl_method_info.invoke_unchecked((), (boundaryType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetBoundaryGeometry(
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_BoundaryGeometry,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_BoundaryType),
                        crate::GlobalNamespace::OVRPlugin_BoundaryGeometry,
                        1usize,
                    >("GetBoundaryGeometry")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetBoundaryGeometry", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_BoundaryGeometry = unsafe {
            cordl_method_info.invoke_unchecked((), (boundaryType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetBoundaryGeometry2(
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
        points: crate::System::IntPtr,
        pointsCount: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_BoundaryType,
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        bool,
                        3usize,
                    >("GetBoundaryGeometry2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetBoundaryGeometry2", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (boundaryType, points, pointsCount))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetBoundaryVisible() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("GetBoundaryVisible")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetBoundaryVisible", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetConnectedControllers() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Controller,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Controller,
                        0usize,
                    >("GetConnectedControllers")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetConnectedControllers", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Controller = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerHapticsDesc(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_HapticsDesc> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_HapticsDesc,
                        1usize,
                    >("GetControllerHapticsDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerHapticsDesc", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_HapticsDesc = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerHapticsState(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_HapticsState> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_HapticsState,
                        1usize,
                    >("GetControllerHapticsState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerHapticsState", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_HapticsState = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerIsInHand(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            crate::GlobalNamespace::OVRPlugin_Node,
                        ),
                        bool,
                        2usize,
                    >("GetControllerIsInHand")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerIsInHand", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerSampleRateHz(
        controllerMask: crate::GlobalNamespace::OVRPlugin_Controller,
        sampleRateHz: quest_hook::libil2cpp::ByRefMut<f32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Controller,
                            quest_hook::libil2cpp::ByRefMut<f32>,
                        ),
                        bool,
                        2usize,
                    >("GetControllerSampleRateHz")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerSampleRateHz", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, sampleRateHz))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerState(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ControllerState,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_ControllerState,
                        1usize,
                    >("GetControllerState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerState", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ControllerState = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerState2(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ControllerState2,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_ControllerState2,
                        1usize,
                    >("GetControllerState2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerState2", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ControllerState2 = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerState4(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ControllerState4,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_ControllerState4,
                        1usize,
                    >("GetControllerState4")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerState4", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ControllerState4 = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerState5(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ControllerState5,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_ControllerState5,
                        1usize,
                    >("GetControllerState5")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerState5", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ControllerState5 = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetControllerState6(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ControllerState6,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_ControllerState6,
                        1usize,
                    >("GetControllerState6")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetControllerState6", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ControllerState6 = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetCurrentDetachedInteractionProfile(
        hand: crate::GlobalNamespace::OVRPlugin_Hand,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_InteractionProfile,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Hand),
                        crate::GlobalNamespace::OVRPlugin_InteractionProfile,
                        1usize,
                    >("GetCurrentDetachedInteractionProfile")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetCurrentDetachedInteractionProfile", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_InteractionProfile = unsafe {
            cordl_method_info.invoke_unchecked((), (hand))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetCurrentInteractionProfile(
        hand: crate::GlobalNamespace::OVRPlugin_Hand,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_InteractionProfile,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Hand),
                        crate::GlobalNamespace::OVRPlugin_InteractionProfile,
                        1usize,
                    >("GetCurrentInteractionProfile")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetCurrentInteractionProfile", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_InteractionProfile = unsafe {
            cordl_method_info.invoke_unchecked((), (hand))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetCurrentTrackingTransformPose() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Posef,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        0usize,
                    >("GetCurrentTrackingTransformPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetCurrentTrackingTransformPose", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetDesiredEyeTextureFormat() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
                        0usize,
                    >("GetDesiredEyeTextureFormat")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetDesiredEyeTextureFormat", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetDominantHand() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Handedness,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Handedness,
                        0usize,
                    >("GetDominantHand")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetDominantHand", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Handedness = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetExternalCameraCount() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("GetExternalCameraCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetExternalCameraCount", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetEyeFrustum(
        eyeId: crate::GlobalNamespace::OVRPlugin_Eye,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Frustumf> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Eye),
                        crate::GlobalNamespace::OVRPlugin_Frustumf,
                        1usize,
                    >("GetEyeFrustum")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetEyeFrustum", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Frustumf = unsafe {
            cordl_method_info.invoke_unchecked((), (eyeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetEyeGazesState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        frameIndex: i32,
        eyeGazesState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_EyeGazesState,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_EyeGazesState,
                            >,
                        ),
                        bool,
                        3usize,
                    >("GetEyeGazesState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetEyeGazesState", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, frameIndex, eyeGazesState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetEyeLayerRecommendedResolution(
        recommendedSize: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Sizei,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Sizei,
                        >),
                        bool,
                        1usize,
                    >("GetEyeLayerRecommendedResolution")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetEyeLayerRecommendedResolution", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (recommendedSize))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetEyeRecommendedResolutionScale() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        f32,
                        0usize,
                    >("GetEyeRecommendedResolutionScale")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetEyeRecommendedResolutionScale", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetEyeTextureSize(
        eyeId: crate::GlobalNamespace::OVRPlugin_Eye,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Sizei> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Eye),
                        crate::GlobalNamespace::OVRPlugin_Sizei,
                        1usize,
                    >("GetEyeTextureSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetEyeTextureSize", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Sizei = unsafe {
            cordl_method_info.invoke_unchecked((), (eyeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetFaceState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        frameIndex: i32,
        faceState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_FaceState,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_FaceState,
                            >,
                        ),
                        bool,
                        3usize,
                    >("GetFaceState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetFaceState", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, frameIndex, faceState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetFaceStateInternal(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        frameIndex: i32,
        faceState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_FaceState,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_FaceState,
                            >,
                        ),
                        bool,
                        3usize,
                    >("GetFaceStateInternal")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetFaceStateInternal", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, frameIndex, faceState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetHandNodePoseStateLatency() -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f64, 0usize>("GetHandNodePoseStateLatency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetHandNodePoseStateLatency", 0usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetHandState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        hand: crate::GlobalNamespace::OVRPlugin_Hand,
        handState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_HandState,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            crate::GlobalNamespace::OVRPlugin_Hand,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_HandState,
                            >,
                        ),
                        bool,
                        3usize,
                    >("GetHandState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetHandState", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, hand, handState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetHandTrackingEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("GetHandTrackingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetHandTrackingEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetHeadPoseModifier(
        relativeRotation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Quatf,
        >,
        relativeTranslation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Vector3f,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Quatf,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Vector3f,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetHeadPoseModifier")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetHeadPoseModifier", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (relativeRotation, relativeTranslation))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetHmdColorDesc() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ColorSpace,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_ColorSpace,
                        0usize,
                    >("GetHmdColorDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetHmdColorDesc", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ColorSpace = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetInsightPassthroughInitializationState() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("GetInsightPassthroughInitializationState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetInsightPassthroughInitializationState", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetKeyboardState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        keyboardState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_KeyboardState,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_KeyboardState,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetKeyboardState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetKeyboardState", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, keyboardState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetLayerAndroidSurfaceObject(
        layerId: i32,
    ) -> quest_hook::libil2cpp::Result<crate::System::IntPtr> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::System::IntPtr,
                        1usize,
                    >("GetLayerAndroidSurfaceObject")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetLayerAndroidSurfaceObject", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetLayerRecommendedResolution(
        layerId: i32,
        recommendedSize: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Sizei,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Sizei,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetLayerRecommendedResolution")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetLayerRecommendedResolution", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, recommendedSize))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetLayerTexture(
        layerId: i32,
        stage: i32,
        eyeId: crate::GlobalNamespace::OVRPlugin_Eye,
    ) -> quest_hook::libil2cpp::Result<crate::System::IntPtr> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, crate::GlobalNamespace::OVRPlugin_Eye),
                        crate::System::IntPtr,
                        3usize,
                    >("GetLayerTexture")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetLayerTexture", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, stage, eyeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetLayerTextureStageCount(
        layerId: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        i32,
                        1usize,
                    >("GetLayerTextureStageCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetLayerTextureStageCount", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetLocalTrackingSpaceRecenterCount() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        i32,
                        0usize,
                    >("GetLocalTrackingSpaceRecenterCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetLocalTrackingSpaceRecenterCount", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetMesh(
        meshType: crate::GlobalNamespace::OVRPlugin_MeshType,
        mesh: quest_hook::libil2cpp::ByRefMut<
            quest_hook::libil2cpp::Gc<crate::GlobalNamespace::OVRPlugin_Mesh>,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_MeshType,
                            quest_hook::libil2cpp::ByRefMut<
                                quest_hook::libil2cpp::Gc<
                                    crate::GlobalNamespace::OVRPlugin_Mesh,
                                >,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "GetMesh",
                            2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (meshType, mesh))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetMixedRealityCameraInfo(
        cameraId: i32,
        cameraExtrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
        >,
        cameraIntrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
                            >,
                        ),
                        bool,
                        3usize,
                    >("GetMixedRealityCameraInfo")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetMixedRealityCameraInfo", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (cameraId, cameraExtrinsics, cameraIntrinsics))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNativeOpenXRInstance() -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), u64, 0usize>("GetNativeOpenXRInstance")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNativeOpenXRInstance", 0usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetNativeOpenXRSession() -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), u64, 0usize>("GetNativeOpenXRSession")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNativeOpenXRSession", 0usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodeAcceleration(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Vector3f> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            crate::GlobalNamespace::OVRPlugin_Step,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Vector3f,
                        2usize,
                    >("GetNodeAcceleration")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodeAcceleration", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Vector3f = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, stepId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodeAngularAcceleration(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Vector3f> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            crate::GlobalNamespace::OVRPlugin_Step,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Vector3f,
                        2usize,
                    >("GetNodeAngularAcceleration")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodeAngularAcceleration", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Vector3f = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, stepId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodeAngularVelocity(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Vector3f> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            crate::GlobalNamespace::OVRPlugin_Step,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Vector3f,
                        2usize,
                    >("GetNodeAngularVelocity")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodeAngularVelocity", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Vector3f = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, stepId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodeFrustum2(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        frustum: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Frustumf2,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Frustumf2,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetNodeFrustum2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodeFrustum2", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, frustum))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodeOrientationTracked(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        bool,
                        1usize,
                    >("GetNodeOrientationTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodeOrientationTracked", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodeOrientationValid(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        bool,
                        1usize,
                    >("GetNodeOrientationValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodeOrientationValid", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodePose(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            crate::GlobalNamespace::OVRPlugin_Step,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        2usize,
                    >("GetNodePose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodePose", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, stepId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodePoseStateAtTime(
        _cordl_time: f64,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_PoseStatef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_PoseStatef,
                        2usize,
                    >("GetNodePoseStateAtTime")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodePoseStateAtTime", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_PoseStatef = unsafe {
            cordl_method_info.invoke_unchecked((), (_cordl_time, nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodePoseStateImmediate(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_PoseStatef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_PoseStatef,
                        1usize,
                    >("GetNodePoseStateImmediate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodePoseStateImmediate", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_PoseStatef = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodePoseStateRaw(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_PoseStatef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            crate::GlobalNamespace::OVRPlugin_Step,
                        ),
                        crate::GlobalNamespace::OVRPlugin_PoseStatef,
                        2usize,
                    >("GetNodePoseStateRaw")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodePoseStateRaw", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_PoseStatef = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, stepId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodePositionTracked(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        bool,
                        1usize,
                    >("GetNodePositionTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodePositionTracked", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodePositionValid(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        bool,
                        1usize,
                    >("GetNodePositionValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodePositionValid", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodePresent(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        bool,
                        1usize,
                    >("GetNodePresent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodePresent", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetNodeVelocity(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Vector3f> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            crate::GlobalNamespace::OVRPlugin_Step,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Vector3f,
                        2usize,
                    >("GetNodeVelocity")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetNodeVelocity", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Vector3f = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, stepId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetPassthroughCapabilities(
        outCapabilities: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("GetPassthroughCapabilities")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetPassthroughCapabilities", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (outCapabilities))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetPassthroughCapabilityFlags() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags,
                        0usize,
                    >("GetPassthroughCapabilityFlags")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetPassthroughCapabilityFlags", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetPassthroughPreferences(
        preferences: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PassthroughPreferences,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_PassthroughPreferences,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("GetPassthroughPreferences")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetPassthroughPreferences", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (preferences))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetPerfMetricsFloat(
        perfMetrics: crate::GlobalNamespace::OVRPlugin_PerfMetrics,
    ) -> quest_hook::libil2cpp::Result<crate::System::Nullable_1<f32>> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_PerfMetrics),
                        crate::System::Nullable_1<f32>,
                        1usize,
                    >("GetPerfMetricsFloat")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetPerfMetricsFloat", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::System::Nullable_1<f32> = unsafe {
            cordl_method_info.invoke_unchecked((), (perfMetrics))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetPerfMetricsInt(
        perfMetrics: crate::GlobalNamespace::OVRPlugin_PerfMetrics,
    ) -> quest_hook::libil2cpp::Result<crate::System::Nullable_1<i32>> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_PerfMetrics),
                        crate::System::Nullable_1<i32>,
                        1usize,
                    >("GetPerfMetricsInt")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetPerfMetricsInt", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::System::Nullable_1<i32> = unsafe {
            cordl_method_info.invoke_unchecked((), (perfMetrics))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetRenderModelPaths() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppArray<
                quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
            >,
        >,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<
                            quest_hook::libil2cpp::Il2CppArray<
                                quest_hook::libil2cpp::Gc<
                                    quest_hook::libil2cpp::Il2CppString,
                                >,
                            >,
                        >,
                        0usize,
                    >("GetRenderModelPaths")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetRenderModelPaths", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppArray<
                quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
            >,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetRenderModelProperties(
        modelPath: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        modelProperties: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_RenderModelProperties,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_RenderModelProperties,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetRenderModelProperties")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetRenderModelProperties", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (modelPath, modelProperties))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSkeleton(
        skeletonType: crate::GlobalNamespace::OVRPlugin_SkeletonType,
        skeleton: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Skeleton,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_SkeletonType,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Skeleton,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSkeleton")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSkeleton", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (skeletonType, skeleton))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSkeleton2(
        skeletonType: crate::GlobalNamespace::OVRPlugin_SkeletonType,
        skeleton: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Skeleton2,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_SkeletonType,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Skeleton2,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSkeleton2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSkeleton2", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (skeletonType, skeleton))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceBoundary2DCount(
        space: u64,
        count: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, quest_hook::libil2cpp::ByRefMut<i32>),
                        bool,
                        2usize,
                    >("GetSpaceBoundary2DCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceBoundary2DCount", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, count))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceBoundary2D_Allocator2(
        space: u64,
        allocator: crate::Unity::Collections::Allocator,
    ) -> quest_hook::libil2cpp::Result<
        crate::Unity::Collections::NativeArray_1<crate::UnityEngine::Vector2>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::Unity::Collections::Allocator),
                        crate::Unity::Collections::NativeArray_1<
                            crate::UnityEngine::Vector2,
                        >,
                        2usize,
                    >("GetSpaceBoundary2D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceBoundary2D", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Collections::NativeArray_1<
            crate::UnityEngine::Vector2,
        > = unsafe { cordl_method_info.invoke_unchecked((), (space, allocator))? };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceBoundary2D_ByRefMut3(
        space: u64,
        boundary: quest_hook::libil2cpp::ByRefMut<
            quest_hook::libil2cpp::Gc<
                quest_hook::libil2cpp::Il2CppArray<crate::UnityEngine::Vector2>,
            >,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                quest_hook::libil2cpp::Gc<
                                    quest_hook::libil2cpp::Il2CppArray<
                                        crate::UnityEngine::Vector2,
                                    >,
                                >,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSpaceBoundary2D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceBoundary2D", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, boundary))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceBoundary2D_NativeArray_1_0(
        space: u64,
        boundary: crate::Unity::Collections::NativeArray_1<crate::UnityEngine::Vector2>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::Unity::Collections::NativeArray_1<
                                crate::UnityEngine::Vector2,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSpaceBoundary2D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceBoundary2D", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, boundary))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceBoundary2D_NativeArray_1_ByRefMut1(
        space: u64,
        boundary: crate::Unity::Collections::NativeArray_1<crate::UnityEngine::Vector2>,
        count: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::Unity::Collections::NativeArray_1<
                                crate::UnityEngine::Vector2,
                            >,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        bool,
                        3usize,
                    >("GetSpaceBoundary2D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceBoundary2D", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, boundary, count))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceBoundingBox2D(
        space: u64,
        rect: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Rectf>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Rectf,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSpaceBoundingBox2D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceBoundingBox2D", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, rect))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceBoundingBox3D(
        space: u64,
        bounds: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Boundsf,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Boundsf,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSpaceBoundingBox3D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceBoundingBox3D", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, bounds))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceComponentStatus(
        space: u64,
        componentType: crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
        enabled: quest_hook::libil2cpp::ByRefMut<bool>,
        changePending: quest_hook::libil2cpp::ByRefMut<bool>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
                            quest_hook::libil2cpp::ByRefMut<bool>,
                            quest_hook::libil2cpp::ByRefMut<bool>,
                        ),
                        bool,
                        4usize,
                    >("GetSpaceComponentStatus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceComponentStatus", 4usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (space, componentType, enabled, changePending))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceComponentStatusInternal(
        space: u64,
        componentType: crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
        enabled: quest_hook::libil2cpp::ByRefMut<bool>,
        changePending: quest_hook::libil2cpp::ByRefMut<bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
                            quest_hook::libil2cpp::ByRefMut<bool>,
                            quest_hook::libil2cpp::ByRefMut<bool>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("GetSpaceComponentStatusInternal")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceComponentStatusInternal", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (space, componentType, enabled, changePending))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceContainer(
        space: u64,
        containerUuids: quest_hook::libil2cpp::ByRefMut<
            quest_hook::libil2cpp::Gc<
                quest_hook::libil2cpp::Il2CppArray<crate::System::Guid>,
            >,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                quest_hook::libil2cpp::Gc<
                                    quest_hook::libil2cpp::Il2CppArray<crate::System::Guid>,
                                >,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSpaceContainer")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceContainer", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, containerUuids))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceRoomLayout(
        space: u64,
        roomLayout: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_RoomLayout,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_RoomLayout,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSpaceRoomLayout")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceRoomLayout", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, roomLayout))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceSemanticLabels(
        space: u64,
        labels: quest_hook::libil2cpp::ByRefMut<
            quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                quest_hook::libil2cpp::Gc<
                                    quest_hook::libil2cpp::Il2CppString,
                                >,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSpaceSemanticLabels")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceSemanticLabels", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, labels))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceTriangleMesh(
        space: u64,
        vertices: crate::Unity::Collections::NativeArray_1<crate::UnityEngine::Vector3>,
        triangles: crate::Unity::Collections::NativeArray_1<i32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::Unity::Collections::NativeArray_1<
                                crate::UnityEngine::Vector3,
                            >,
                            crate::Unity::Collections::NativeArray_1<i32>,
                        ),
                        bool,
                        3usize,
                    >("GetSpaceTriangleMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceTriangleMesh", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, vertices, triangles))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceTriangleMeshCounts(
        space: u64,
        vertexCount: quest_hook::libil2cpp::ByRefMut<i32>,
        triangleCount: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        bool,
                        3usize,
                    >("GetSpaceTriangleMeshCounts")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceTriangleMeshCounts", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, vertexCount, triangleCount))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceUserId(
        spaceUserHandle: u64,
        spaceUserId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, quest_hook::libil2cpp::ByRefMut<u64>),
                        bool,
                        2usize,
                    >("GetSpaceUserId")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceUserId", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (spaceUserHandle, spaceUserId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSpaceUuid(
        space: u64,
        uuid: quest_hook::libil2cpp::ByRefMut<crate::System::Guid>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, quest_hook::libil2cpp::ByRefMut<crate::System::Guid>),
                        bool,
                        2usize,
                    >("GetSpaceUuid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSpaceUuid", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, uuid))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSystemHeadsetType() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_SystemHeadset,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_SystemHeadset,
                        0usize,
                    >("GetSystemHeadsetType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSystemHeadsetType", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_SystemHeadset = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetSystemHmd3DofModeEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("GetSystemHmd3DofModeEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSystemHmd3DofModeEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetSystemKeyboardDescription(
        keyboardQueryFlags: crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags,
        keyboardDescription: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_KeyboardDescription,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_KeyboardDescription,
                            >,
                        ),
                        bool,
                        2usize,
                    >("GetSystemKeyboardDescription")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetSystemKeyboardDescription", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (keyboardQueryFlags, keyboardDescription))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetTimeInSeconds() -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f64, 0usize>("GetTimeInSeconds")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetTimeInSeconds", 0usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetTrackerFrustum(
        trackerId: crate::GlobalNamespace::OVRPlugin_Tracker,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Frustumf> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Tracker),
                        crate::GlobalNamespace::OVRPlugin_Frustumf,
                        1usize,
                    >("GetTrackerFrustum")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetTrackerFrustum", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Frustumf = unsafe {
            cordl_method_info.invoke_unchecked((), (trackerId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetTrackerPose(
        trackerId: crate::GlobalNamespace::OVRPlugin_Tracker,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Tracker),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        1usize,
                    >("GetTrackerPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetTrackerPose", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (trackerId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetTrackingCalibratedOrigin() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Posef,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        0usize,
                    >("GetTrackingCalibratedOrigin")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetTrackingCalibratedOrigin", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetTrackingOriginType() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
                        0usize,
                    >("GetTrackingOriginType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetTrackingOriginType", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_TrackingOrigin = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetTrackingTransformRawPose() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Posef,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        0usize,
                    >("GetTrackingTransformRawPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetTrackingTransformRawPose", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetTrackingTransformRelativePose(
        trackingOrigin: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_TrackingOrigin),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        1usize,
                    >("GetTrackingTransformRelativePose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetTrackingTransformRelativePose", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (trackingOrigin))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetUseOverriddenExternalCameraFov(
        cameraId: i32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        bool,
                        1usize,
                    >("GetUseOverriddenExternalCameraFov")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetUseOverriddenExternalCameraFov", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetUseOverriddenExternalCameraStaticPose(
        cameraId: i32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        bool,
                        1usize,
                    >("GetUseOverriddenExternalCameraStaticPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetUseOverriddenExternalCameraStaticPose", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetVirtualKeyboardDirtyTextures(
        textureIds: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("GetVirtualKeyboardDirtyTextures")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetVirtualKeyboardDirtyTextures", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (textureIds))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetVirtualKeyboardModelAnimationStates(
        animationStates: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("GetVirtualKeyboardModelAnimationStates")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetVirtualKeyboardModelAnimationStates", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (animationStates))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetVirtualKeyboardScale(
        scale: quest_hook::libil2cpp::ByRefMut<f32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<f32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("GetVirtualKeyboardScale")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetVirtualKeyboardScale", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (scale))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetVirtualKeyboardTextureData(
        textureId: u64,
        textureData: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("GetVirtualKeyboardTextureData")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetVirtualKeyboardTextureData", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (textureId, textureData))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GuidToUuidString(
        guid: crate::System::Guid,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::Guid),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        1usize,
                    >("GuidToUuidString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GuidToUuidString", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), (guid))? };
        Ok(__cordl_ret.into())
    }
    pub fn InitializeInsightPassthrough() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("InitializeInsightPassthrough")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "InitializeInsightPassthrough", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn InitializeMixedReality() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("InitializeMixedReality")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "InitializeMixedReality", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsControllerDrivenHandPosesEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("IsControllerDrivenHandPosesEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsControllerDrivenHandPosesEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsInsightPassthroughInitialized() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("IsInsightPassthroughInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsInsightPassthroughInitialized", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsInsightPassthroughSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("IsInsightPassthroughSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsInsightPassthroughSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsMixedRealityInitialized() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("IsMixedRealityInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsMixedRealityInitialized", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsMultimodalHandsControllersSupported() -> quest_hook::libil2cpp::Result<
        bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("IsMultimodalHandsControllersSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsMultimodalHandsControllersSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsOrientationTracked(
        value: crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags),
                        bool,
                        1usize,
                    >("IsOrientationTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsOrientationTracked", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn IsOrientationValid(
        value: crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags),
                        bool,
                        1usize,
                    >("IsOrientationValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsOrientationValid", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn IsPassthroughShape(
        shape: crate::GlobalNamespace::OVRPlugin_OverlayShape,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_OverlayShape),
                        bool,
                        1usize,
                    >("IsPassthroughShape")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsPassthroughShape", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (shape))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn IsPerfMetricsSupported(
        perfMetrics: crate::GlobalNamespace::OVRPlugin_PerfMetrics,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_PerfMetrics),
                        bool,
                        1usize,
                    >("IsPerfMetricsSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsPerfMetricsSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (perfMetrics))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn IsPositionTracked(
        value: crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags),
                        bool,
                        1usize,
                    >("IsPositionTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsPositionTracked", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn IsPositionValid(
        value: crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags),
                        bool,
                        1usize,
                    >("IsPositionValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsPositionValid", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn IsSuccess(
        result: crate::GlobalNamespace::OVRPlugin_Result,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Result),
                        bool,
                        1usize,
                    >("IsSuccess")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsSuccess", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (result))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn IsValidBone(
        bone: crate::GlobalNamespace::OVRPlugin_BoneId,
        skeletonType: crate::GlobalNamespace::OVRPlugin_SkeletonType,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_BoneId,
                            crate::GlobalNamespace::OVRPlugin_SkeletonType,
                        ),
                        bool,
                        2usize,
                    >("IsValidBone")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsValidBone", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (bone, skeletonType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn LoadRenderModel(
        modelKey: u64,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<u8>>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Gc<
                            quest_hook::libil2cpp::Il2CppArray<u8>,
                        >,
                        1usize,
                    >("LoadRenderModel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "LoadRenderModel", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppArray<u8>,
        > = unsafe { cordl_method_info.invoke_unchecked((), (modelKey))? };
        Ok(__cordl_ret.into())
    }
    pub fn LocateSpace(
        space: u64,
        baseOrigin: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::GlobalNamespace::OVRPlugin_TrackingOrigin),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        2usize,
                    >("LocateSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "LocateSpace", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (space, baseOrigin))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnEditorShutdown() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Void,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Void,
                        0usize,
                    >("OnEditorShutdown")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnEditorShutdown", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OverrideExternalCameraFov(
        cameraId: i32,
        useOverriddenFov: bool,
        fov: crate::GlobalNamespace::OVRPlugin_Fovf,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, bool, crate::GlobalNamespace::OVRPlugin_Fovf),
                        bool,
                        3usize,
                    >("OverrideExternalCameraFov")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OverrideExternalCameraFov", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId, useOverriddenFov, fov))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OverrideExternalCameraStaticPose(
        cameraId: i32,
        useOverriddenPose: bool,
        poseInStageOrigin: crate::GlobalNamespace::OVRPlugin_Posef,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, bool, crate::GlobalNamespace::OVRPlugin_Posef),
                        bool,
                        3usize,
                    >("OverrideExternalCameraStaticPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OverrideExternalCameraStaticPose", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (cameraId, useOverriddenPose, poseInStageOrigin))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn PollEvent(
        eventDataBuffer: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_EventDataBuffer,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_EventDataBuffer,
                        >),
                        bool,
                        1usize,
                    >("PollEvent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "PollEvent", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (eventDataBuffer))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn QuerySpaces(
        queryInfo: crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        2usize,
                    >("QuerySpaces")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "QuerySpaces", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (queryInfo, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn RecenterTrackingOrigin(
        flags: crate::GlobalNamespace::OVRPlugin_RecenterFlags,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_RecenterFlags),
                        bool,
                        1usize,
                    >("RecenterTrackingOrigin")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "RecenterTrackingOrigin", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (flags))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn RequestSceneCapture(
        requestString: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        2usize,
                    >("RequestSceneCapture")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "RequestSceneCapture", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (requestString, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ResetAppPerfStats() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("ResetAppPerfStats")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ResetAppPerfStats", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ResetDefaultExternalCamera() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("ResetDefaultExternalCamera")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ResetDefaultExternalCamera", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn RetrieveSpaceQueryResults_Allocator0(
        requestId: u64,
        results: quest_hook::libil2cpp::ByRefMut<
            crate::Unity::Collections::NativeArray_1<
                crate::GlobalNamespace::OVRPlugin_SpaceQueryResult,
            >,
        >,
        allocator: crate::Unity::Collections::Allocator,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::Unity::Collections::NativeArray_1<
                                    crate::GlobalNamespace::OVRPlugin_SpaceQueryResult,
                                >,
                            >,
                            crate::Unity::Collections::Allocator,
                        ),
                        bool,
                        3usize,
                    >("RetrieveSpaceQueryResults")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "RetrieveSpaceQueryResults", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (requestId, results, allocator))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn RetrieveSpaceQueryResults_u64_ByRefMut1(
        requestId: u64,
        results: quest_hook::libil2cpp::ByRefMut<
            quest_hook::libil2cpp::Gc<
                quest_hook::libil2cpp::Il2CppArray<
                    crate::GlobalNamespace::OVRPlugin_SpaceQueryResult,
                >,
            >,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                quest_hook::libil2cpp::Gc<
                                    quest_hook::libil2cpp::Il2CppArray<
                                        crate::GlobalNamespace::OVRPlugin_SpaceQueryResult,
                                    >,
                                >,
                            >,
                        ),
                        bool,
                        2usize,
                    >("RetrieveSpaceQueryResults")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "RetrieveSpaceQueryResults", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (requestId, results))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SaveSpace(
        space: u64,
        location: crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
        mode: crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
                            crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        4usize,
                    >("SaveSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SaveSpace", 4usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, location, mode, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SaveSpaceList(
        spaces: crate::Unity::Collections::NativeArray_1<u64>,
        location: crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Collections::NativeArray_1<u64>,
                            crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("SaveSpaceList")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SaveSpaceList", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (spaces, location, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SendEvent(
        name: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        param: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        source: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                        ),
                        bool,
                        3usize,
                    >("SendEvent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SendEvent", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (name, param, source))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SendVirtualKeyboardInput(
        inputInfo: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo,
        interactorRootPose: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Posef,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("SendVirtualKeyboardInput")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SendVirtualKeyboardInput", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (inputInfo, interactorRootPose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetBoundaryVisible(value: bool) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(bool), bool, 1usize>("SetBoundaryVisible")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetBoundaryVisible", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetClientColorDesc(
        colorSpace: crate::GlobalNamespace::OVRPlugin_ColorSpace,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_ColorSpace),
                        bool,
                        1usize,
                    >("SetClientColorDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetClientColorDesc", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (colorSpace))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetColorScaleAndOffset(
        colorScale: crate::UnityEngine::Vector4,
        colorOffset: crate::UnityEngine::Vector4,
        applyToAllLayers: bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::UnityEngine::Vector4, crate::UnityEngine::Vector4, bool),
                        bool,
                        3usize,
                    >("SetColorScaleAndOffset")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetColorScaleAndOffset", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (colorScale, colorOffset, applyToAllLayers))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetControllerDrivenHandPoses(
        controllerDrivenHandPoses: bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        bool,
                        1usize,
                    >("SetControllerDrivenHandPoses")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetControllerDrivenHandPoses", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerDrivenHandPoses))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetControllerDrivenHandPosesAreNatural(
        controllerDrivenHandPosesAreNatural: bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        bool,
                        1usize,
                    >("SetControllerDrivenHandPosesAreNatural")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetControllerDrivenHandPosesAreNatural", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (controllerDrivenHandPosesAreNatural))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetControllerHaptics(
        controllerMask: u32,
        hapticsBuffer: crate::GlobalNamespace::OVRPlugin_HapticsBuffer,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, crate::GlobalNamespace::OVRPlugin_HapticsBuffer),
                        bool,
                        2usize,
                    >("SetControllerHaptics")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetControllerHaptics", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, hapticsBuffer))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetControllerHapticsAmplitudeEnvelope(
        controllerMask: crate::GlobalNamespace::OVRPlugin_Controller,
        hapticsVibration: crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Controller,
                            crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration,
                        ),
                        bool,
                        2usize,
                    >("SetControllerHapticsAmplitudeEnvelope")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetControllerHapticsAmplitudeEnvelope", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, hapticsVibration))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetControllerHapticsPcm(
        controllerMask: crate::GlobalNamespace::OVRPlugin_Controller,
        hapticsVibration: crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Controller,
                            crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration,
                        ),
                        bool,
                        2usize,
                    >("SetControllerHapticsPcm")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetControllerHapticsPcm", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, hapticsVibration))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetControllerLocalizedVibration(
        controllerMask: crate::GlobalNamespace::OVRPlugin_Controller,
        hapticsLocationMask: crate::GlobalNamespace::OVRPlugin_HapticsLocation,
        frequency: f32,
        amplitude: f32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Controller,
                            crate::GlobalNamespace::OVRPlugin_HapticsLocation,
                            f32,
                            f32,
                        ),
                        bool,
                        4usize,
                    >("SetControllerLocalizedVibration")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetControllerLocalizedVibration", 4usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (controllerMask, hapticsLocationMask, frequency, amplitude),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetControllerVibration(
        controllerMask: u32,
        frequency: f32,
        amplitude: f32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, f32, f32),
                        bool,
                        3usize,
                    >("SetControllerVibration")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetControllerVibration", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (controllerMask, frequency, amplitude))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetDefaultExternalCamera(
        cameraName: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        cameraIntrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
        >,
        cameraExtrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
                            >,
                        ),
                        bool,
                        3usize,
                    >("SetDefaultExternalCamera")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetDefaultExternalCamera", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (cameraName, cameraIntrinsics, cameraExtrinsics))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetDesiredEyeTextureFormat(
        value: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_EyeTextureFormat),
                        bool,
                        1usize,
                    >("SetDesiredEyeTextureFormat")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetDesiredEyeTextureFormat", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetDeveloperMode(
        active: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        bool,
                        1usize,
                    >("SetDeveloperMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetDeveloperMode", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (active))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetExternalCameraProperties(
        cameraName: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        cameraIntrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
        >,
        cameraExtrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
                            >,
                        ),
                        bool,
                        3usize,
                    >("SetExternalCameraProperties")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetExternalCameraProperties", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (cameraName, cameraIntrinsics, cameraExtrinsics))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetEyeBufferSharpenType(
        sharpenType: crate::GlobalNamespace::OVRPlugin_LayerSharpenType,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_LayerSharpenType),
                        bool,
                        1usize,
                    >("SetEyeBufferSharpenType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetEyeBufferSharpenType", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (sharpenType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetHandNodePoseStateLatency(
        latencyInSeconds: f64,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64),
                        bool,
                        1usize,
                    >("SetHandNodePoseStateLatency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetHandNodePoseStateLatency", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (latencyInSeconds))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetHeadPoseModifier(
        relativeRotation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Quatf,
        >,
        relativeTranslation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Vector3f,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Quatf,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Vector3f,
                            >,
                        ),
                        bool,
                        2usize,
                    >("SetHeadPoseModifier")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetHeadPoseModifier", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (relativeRotation, relativeTranslation))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetInsightPassthroughKeyboardHandsIntensity(
        layerId: i32,
        intensity: crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity,
                        ),
                        bool,
                        2usize,
                    >("SetInsightPassthroughKeyboardHandsIntensity")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetInsightPassthroughKeyboardHandsIntensity", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, intensity))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetInsightPassthroughStyle_OVRPlugin_InsightPassthroughStyle1(
        layerId: i32,
        style: crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle),
                        bool,
                        2usize,
                    >("SetInsightPassthroughStyle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetInsightPassthroughStyle", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, style))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetInsightPassthroughStyle_OVRPlugin_InsightPassthroughStyle2_0(
        layerId: i32,
        style: crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2,
                        ),
                        bool,
                        2usize,
                    >("SetInsightPassthroughStyle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetInsightPassthroughStyle", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, style))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetKeyboardOverlayUV(
        uv: crate::GlobalNamespace::OVRPlugin_Vector2f,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Vector2f),
                        bool,
                        1usize,
                    >("SetKeyboardOverlayUV")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetKeyboardOverlayUV", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), (uv))? };
        Ok(__cordl_ret.into())
    }
    pub fn SetLogCallback2(
        logCallback: quest_hook::libil2cpp::Gc<
            crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType,
        >,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<
                            crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType,
                        >),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("SetLogCallback2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetLogCallback2", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (logCallback))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetMultimodalHandsControllersSupported(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        bool,
                        1usize,
                    >("SetMultimodalHandsControllersSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetMultimodalHandsControllersSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetSimultaneousHandsAndControllersEnabled(
        enabled: bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        bool,
                        1usize,
                    >("SetSimultaneousHandsAndControllersEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetSimultaneousHandsAndControllersEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (enabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetSpaceComponentStatus(
        space: u64,
        componentType: crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
        enable: bool,
        timeout: f64,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
                            bool,
                            f64,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        bool,
                        5usize,
                    >("SetSpaceComponentStatus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetSpaceComponentStatus", 5usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (space, componentType, enable, timeout, requestId),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetTrackingCalibratedOrigin() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("SetTrackingCalibratedOrigin")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetTrackingCalibratedOrigin", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn SetTrackingOriginType(
        originType: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_TrackingOrigin),
                        bool,
                        1usize,
                    >("SetTrackingOriginType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetTrackingOriginType", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (originType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetVirtualKeyboardModelVisibility(
        visibility: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("SetVirtualKeyboardModelVisibility")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetVirtualKeyboardModelVisibility", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (visibility))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ShareSpaces(
        spaces: crate::Unity::Collections::NativeArray_1<u64>,
        userHandles: crate::Unity::Collections::NativeArray_1<u64>,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Collections::NativeArray_1<u64>,
                            crate::Unity::Collections::NativeArray_1<u64>,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ShareSpaces")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ShareSpaces", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (spaces, userHandles, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ShowUI(
        ui: crate::GlobalNamespace::OVRPlugin_PlatformUI,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_PlatformUI),
                        bool,
                        1usize,
                    >("ShowUI")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "ShowUI",
                            1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), (ui))? };
        Ok(__cordl_ret.into())
    }
    pub fn ShutdownInsightPassthrough() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("ShutdownInsightPassthrough")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ShutdownInsightPassthrough", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ShutdownMixedReality() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("ShutdownMixedReality")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ShutdownMixedReality", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn StartBodyTracking() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("StartBodyTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "StartBodyTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn StartEyeTracking() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("StartEyeTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "StartEyeTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn StartFaceTracking() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("StartFaceTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "StartFaceTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn StartKeyboardTracking(
        trackedKeyboardId: u64,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), bool, 1usize>("StartKeyboardTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "StartKeyboardTracking", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (trackedKeyboardId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn StopBodyTracking() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("StopBodyTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "StopBodyTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn StopEyeTracking() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("StopEyeTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "StopEyeTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn StopFaceTracking() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("StopFaceTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "StopFaceTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn StopKeyboardTracking() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("StopKeyboardTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "StopKeyboardTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn SuggestVirtualKeyboardLocation(
        locationInfo: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("SuggestVirtualKeyboardLocation")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SuggestVirtualKeyboardLocation", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (locationInfo))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn TestBoundaryNode(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_BoundaryTestResult,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            crate::GlobalNamespace::OVRPlugin_BoundaryType,
                        ),
                        crate::GlobalNamespace::OVRPlugin_BoundaryTestResult,
                        2usize,
                    >("TestBoundaryNode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "TestBoundaryNode", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_BoundaryTestResult = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, boundaryType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn TestBoundaryPoint(
        point: crate::GlobalNamespace::OVRPlugin_Vector3f,
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_BoundaryTestResult,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Vector3f,
                            crate::GlobalNamespace::OVRPlugin_BoundaryType,
                        ),
                        crate::GlobalNamespace::OVRPlugin_BoundaryTestResult,
                        2usize,
                    >("TestBoundaryPoint")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "TestBoundaryPoint", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_BoundaryTestResult = unsafe {
            cordl_method_info.invoke_unchecked((), (point, boundaryType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ToBool(
        b: bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ToBool")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "ToBool",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (b))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn TryLocateSpace_ByRefMut1(
        space: u64,
        baseOrigin: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
        pose: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Posef>,
        locationFlags: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags,
        >,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags,
                            >,
                        ),
                        bool,
                        4usize,
                    >("TryLocateSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "TryLocateSpace", 4usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (space, baseOrigin, pose, locationFlags))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn TryLocateSpace_u64_OVRPlugin_TrackingOrigin_ByRefMut0(
        space: u64,
        baseOrigin: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
        pose: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Posef>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                        ),
                        bool,
                        3usize,
                    >("TryLocateSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "TryLocateSpace", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (space, baseOrigin, pose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn UpdateExternalCamera() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("UpdateExternalCamera")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "UpdateExternalCamera", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn UpdateInsightPassthroughGeometryTransform(
        geometryInstanceHandle: u64,
        transform: crate::UnityEngine::Matrix4x4,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::UnityEngine::Matrix4x4),
                        bool,
                        2usize,
                    >("UpdateInsightPassthroughGeometryTransform")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "UpdateInsightPassthroughGeometryTransform", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (geometryInstanceHandle, transform))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn UpdateNodePhysicsPoses(
        frameIndex: i32,
        predictionSeconds: f64,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, f64),
                        bool,
                        2usize,
                    >("UpdateNodePhysicsPoses")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "UpdateNodePhysicsPoses", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (frameIndex, predictionSeconds))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn UpdatePassthroughColorLut(
        colorLut: u64,
        data: crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData),
                        bool,
                        2usize,
                    >("UpdatePassthroughColorLut")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "UpdatePassthroughColorLut", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (colorLut, data))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_AsymmetricFovEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_AsymmetricFovEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_AsymmetricFovEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_EyeTextureArrayEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_EyeTextureArrayEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_EyeTextureArrayEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_audioInId() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("get_audioInId")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_audioInId", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_audioOutId() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("get_audioOutId")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_audioOutId", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_batteryLevel() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("get_batteryLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_batteryLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_batteryStatus() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_BatteryStatus,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_BatteryStatus,
                        0usize,
                    >("get_batteryStatus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_batteryStatus", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_BatteryStatus = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_batteryTemperature() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("get_batteryTemperature")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_batteryTemperature", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_bodyTrackingEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_bodyTrackingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_bodyTrackingEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_bodyTrackingSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_bodyTrackingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_bodyTrackingSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_chromatic() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_chromatic")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_chromatic", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_cpuLevel() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("get_cpuLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_cpuLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_eyeDepth() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("get_eyeDepth")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_eyeDepth", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_eyeFovPremultipliedAlphaModeEnabled() -> quest_hook::libil2cpp::Result<
        bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_eyeFovPremultipliedAlphaModeEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_eyeFovPremultipliedAlphaModeEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_eyeHeight() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("get_eyeHeight")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_eyeHeight", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_eyeTrackedFoveatedRenderingEnabled() -> quest_hook::libil2cpp::Result<
        bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_eyeTrackedFoveatedRenderingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_eyeTrackedFoveatedRenderingEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_eyeTrackedFoveatedRenderingSupported() -> quest_hook::libil2cpp::Result<
        bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_eyeTrackedFoveatedRenderingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_eyeTrackedFoveatedRenderingSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_eyeTrackingEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_eyeTrackingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_eyeTrackingEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_eyeTrackingSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_eyeTrackingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_eyeTrackingSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_faceTrackingEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_faceTrackingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_faceTrackingEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_faceTrackingSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_faceTrackingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_faceTrackingSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_fixedFoveatedRenderingLevel() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel,
                        0usize,
                    >("get_fixedFoveatedRenderingLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_fixedFoveatedRenderingLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_fixedFoveatedRenderingSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_fixedFoveatedRenderingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_fixedFoveatedRenderingSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_foveatedRenderingLevel() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel,
                        0usize,
                    >("get_foveatedRenderingLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_foveatedRenderingLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_foveatedRenderingSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_foveatedRenderingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_foveatedRenderingSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_gpuLevel() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("get_gpuLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_gpuLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_gpuUtilLevel() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("get_gpuUtilLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_gpuUtilLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_gpuUtilSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_gpuUtilSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_gpuUtilSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_hasInputFocus() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_hasInputFocus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_hasInputFocus", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_hasVrFocus() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_hasVrFocus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_hasVrFocus", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_headphonesPresent() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_headphonesPresent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_headphonesPresent", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_hmdPresent() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_hmdPresent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_hmdPresent", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_initialized() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_initialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_initialized", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_ipd() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("get_ipd")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "get_ipd",
                            0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_latency() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("get_latency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_latency", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_localDimming() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_localDimming")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_localDimming", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_localDimmingSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_localDimmingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_localDimmingSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_monoscopic() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_monoscopic")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_monoscopic", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_nativeSDKVersion() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<crate::System::Version>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<crate::System::Version>,
                        0usize,
                    >("get_nativeSDKVersion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_nativeSDKVersion", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<crate::System::Version> = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_nativeXrApi() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_XrApi,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_XrApi,
                        0usize,
                    >("get_nativeXrApi")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_nativeXrApi", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_XrApi = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_occlusionMesh() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_occlusionMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_occlusionMesh", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_position() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_position")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_position", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_positionSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_positionSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_positionSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_positionTracked() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_positionTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_positionTracked", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_powerSaving() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_powerSaving")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_powerSaving", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_productName() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("get_productName")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_productName", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_recommendedMSAALevel() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("get_recommendedMSAALevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_recommendedMSAALevel", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_rotation() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_rotation")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_rotation", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_shouldQuit() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_shouldQuit")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_shouldQuit", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_shouldRecenter() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_shouldRecenter")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_shouldRecenter", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_suggestedCpuPerfLevel() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
                        0usize,
                    >("get_suggestedCpuPerfLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_suggestedCpuPerfLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_suggestedGpuPerfLevel() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
                        0usize,
                    >("get_suggestedGpuPerfLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_suggestedGpuPerfLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_systemDisplayFrequenciesAvailable() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<f32>>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<
                            quest_hook::libil2cpp::Il2CppArray<f32>,
                        >,
                        0usize,
                    >("get_systemDisplayFrequenciesAvailable")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_systemDisplayFrequenciesAvailable", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppArray<f32>,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_systemDisplayFrequency() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("get_systemDisplayFrequency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_systemDisplayFrequency", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_systemRegion() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_SystemRegion,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_SystemRegion,
                        0usize,
                    >("get_systemRegion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_systemRegion", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_SystemRegion = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_systemVolume() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("get_systemVolume")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_systemVolume", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_tiledMultiResLevel() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel,
                        0usize,
                    >("get_tiledMultiResLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_tiledMultiResLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_tiledMultiResSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_tiledMultiResSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_tiledMultiResSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_useDynamicFixedFoveatedRendering() -> quest_hook::libil2cpp::Result<
        bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_useDynamicFixedFoveatedRendering")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_useDynamicFixedFoveatedRendering", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_useDynamicFoveatedRendering() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_useDynamicFoveatedRendering")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_useDynamicFoveatedRendering", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_useIPDInPositionTracking() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_useIPDInPositionTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_useIPDInPositionTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_userPresent() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_userPresent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_userPresent", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_version() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<crate::System::Version>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<crate::System::Version>,
                        0usize,
                    >("get_version")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_version", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<crate::System::Version> = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_vsyncCount() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("get_vsyncCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_vsyncCount", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn set_chromatic(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_chromatic")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_chromatic", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_cpuLevel(
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_cpuLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_cpuLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_eyeDepth(
        value: f32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_eyeDepth")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_eyeDepth", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_eyeFovPremultipliedAlphaModeEnabled(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_eyeFovPremultipliedAlphaModeEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_eyeFovPremultipliedAlphaModeEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_eyeHeight(
        value: f32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_eyeHeight")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_eyeHeight", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_eyeTrackedFoveatedRenderingEnabled(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_eyeTrackedFoveatedRenderingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_eyeTrackedFoveatedRenderingEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_fixedFoveatedRenderingLevel(
        value: crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_fixedFoveatedRenderingLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_fixedFoveatedRenderingLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_foveatedRenderingLevel(
        value: crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_foveatedRenderingLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_foveatedRenderingLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_gpuLevel(
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_gpuLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_gpuLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_ipd(
        value: f32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_ipd")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "set_ipd",
                            1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_localDimming(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_localDimming")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_localDimming", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_monoscopic(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_monoscopic")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_monoscopic", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_occlusionMesh(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_occlusionMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_occlusionMesh", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_position(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_position")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_position", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_rotation(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_rotation")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_rotation", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_suggestedCpuPerfLevel(
        value: crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_suggestedCpuPerfLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_suggestedCpuPerfLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_suggestedGpuPerfLevel(
        value: crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_suggestedGpuPerfLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_suggestedGpuPerfLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_systemDisplayFrequency(
        value: f32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_systemDisplayFrequency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_systemDisplayFrequency", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_tiledMultiResLevel(
        value: crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_tiledMultiResLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_tiledMultiResLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_useDynamicFixedFoveatedRendering(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_useDynamicFixedFoveatedRendering")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_useDynamicFixedFoveatedRendering", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_useDynamicFoveatedRendering(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_useDynamicFoveatedRendering")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_useDynamicFoveatedRendering", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_useIPDInPositionTracking(
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_useIPDInPositionTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_useIPDInPositionTracking", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_vsyncCount(
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_vsyncCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_vsyncCount", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfFrameStats")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_AppPerfFrameStats {
    pub HmdVsyncIndex: i32,
    pub AppFrameIndex: i32,
    pub AppDroppedFrameCount: i32,
    pub AppMotionToPhotonLatency: f32,
    pub AppQueueAheadTime: f32,
    pub AppCpuElapsedTime: f32,
    pub AppGpuElapsedTime: f32,
    pub CompositorFrameIndex: i32,
    pub CompositorDroppedFrameCount: i32,
    pub CompositorLatency: f32,
    pub CompositorCpuElapsedTime: f32,
    pub CompositorGpuElapsedTime: f32,
    pub CompositorCpuStartToGpuEndElapsedTime: f32,
    pub CompositorGpuEndToVsyncElapsedTime: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfFrameStats")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/AppPerfFrameStats";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfFrameStats")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfFrameStats")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfFrameStats")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfFrameStats")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfFrameStats")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+AppPerfFrameStats")]
impl crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats {}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfStats")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_AppPerfStats {
    pub FrameStats: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            crate::GlobalNamespace::OVRPlugin_AppPerfFrameStats,
        >,
    >,
    pub FrameStatsCount: i32,
    pub AnyFrameStatsDropped: crate::GlobalNamespace::OVRPlugin_Bool,
    pub AdaptiveGpuPerformanceScale: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfStats")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_AppPerfStats {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/AppPerfStats";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfStats")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_AppPerfStats {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfStats")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_AppPerfStats {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfStats")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_AppPerfStats {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfStats")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_AppPerfStats {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+AppPerfStats")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_AppPerfStats {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+AppPerfStats")]
impl crate::GlobalNamespace::OVRPlugin_AppPerfStats {}
#[cfg(feature = "cordl_class_OVRPlugin+BatteryStatus")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_BatteryStatus {
    #[default]
    Charging = 0i32,
    Discharging = 1i32,
    Full = 2i32,
    NotCharging = 3i32,
    Unknown = 4i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+BatteryStatus")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_BatteryStatus {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BatteryStatus";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BatteryStatus")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BatteryStatus {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BatteryStatus")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BatteryStatus {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BatteryStatus")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BatteryStatus {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BatteryStatus")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BatteryStatus {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BlendFactor")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_BlendFactor {
    #[default]
    DstAlpha = 4i32,
    One = 1i32,
    OneMinusDstAlpha = 5i32,
    OneMinusSrcAlpha = 3i32,
    SrcAlpha = 2i32,
    Zero = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+BlendFactor")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_BlendFactor {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BlendFactor";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BlendFactor")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BlendFactor {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BlendFactor")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BlendFactor {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BlendFactor")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BlendFactor {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BlendFactor")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BlendFactor {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyJointLocation")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_BodyJointLocation {
    pub LocationFlags: crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags,
    pub Pose: crate::GlobalNamespace::OVRPlugin_Posef,
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyJointLocation")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_BodyJointLocation {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BodyJointLocation";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyJointLocation")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BodyJointLocation {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyJointLocation")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BodyJointLocation {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyJointLocation")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BodyJointLocation {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyJointLocation")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BodyJointLocation {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyJointLocation")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_BodyJointLocation {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+BodyJointLocation")]
impl crate::GlobalNamespace::OVRPlugin_BodyJointLocation {
    pub fn get_OrientationTracked(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), bool, 0usize>("get_OrientationTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_OrientationTracked", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_OrientationValid(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), bool, 0usize>("get_OrientationValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_OrientationValid", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_PositionTracked(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), bool, 0usize>("get_PositionTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_PositionTracked", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_PositionValid(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), bool, 0usize>("get_PositionValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_PositionValid", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_BodyState {
    pub JointLocations: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
        >,
    >,
    pub Confidence: f32,
    pub SkeletonChangedCount: u32,
    pub Time: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyState")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_BodyState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BodyState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BodyState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BodyState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BodyState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BodyState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_BodyState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+BodyState")]
impl crate::GlobalNamespace::OVRPlugin_BodyState {}
#[cfg(feature = "cordl_class_OVRPlugin+BodyStateInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_BodyStateInternal {
    pub IsActive: crate::GlobalNamespace::OVRPlugin_Bool,
    pub Confidence: f32,
    pub SkeletonChangedCount: u32,
    pub Time: f64,
    pub JointLocation_0: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_1: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_2: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_3: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_4: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_5: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_6: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_7: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_8: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_9: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_10: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_11: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_12: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_13: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_14: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_15: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_16: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_17: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_18: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_19: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_20: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_21: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_22: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_23: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_24: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_25: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_26: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_27: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_28: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_29: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_30: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_31: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_32: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_33: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_34: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_35: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_36: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_37: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_38: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_39: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_40: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_41: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_42: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_43: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_44: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_45: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_46: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_47: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_48: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_49: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_50: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_51: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_52: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_53: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_54: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_55: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_56: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_57: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_58: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_59: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_60: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_61: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_62: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_63: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_64: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_65: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_66: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_67: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_68: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
    pub JointLocation_69: crate::GlobalNamespace::OVRPlugin_BodyJointLocation,
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyStateInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_BodyStateInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BodyStateInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyStateInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BodyStateInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyStateInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BodyStateInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyStateInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BodyStateInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyStateInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BodyStateInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BodyStateInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_BodyStateInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+BodyStateInternal")]
impl crate::GlobalNamespace::OVRPlugin_BodyStateInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+Bone")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Bone {
    pub Id: crate::GlobalNamespace::OVRPlugin_BoneId,
    pub ParentBoneIndex: i16,
    pub Pose: crate::GlobalNamespace::OVRPlugin_Posef,
}
#[cfg(feature = "cordl_class_OVRPlugin+Bone")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Bone {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Bone";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bone")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Bone {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bone")]
unsafe impl quest_hook::libil2cpp::Parameter for crate::GlobalNamespace::OVRPlugin_Bone {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bone")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Bone {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bone")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Bone {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bone")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Bone {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Bone")]
impl crate::GlobalNamespace::OVRPlugin_Bone {}
#[cfg(feature = "cordl_class_OVRPlugin+BoneCapsule")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_BoneCapsule {
    pub BoneIndex: i16,
    pub StartPoint: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub EndPoint: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub Radius: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneCapsule")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_BoneCapsule {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BoneCapsule";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneCapsule")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BoneCapsule {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneCapsule")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BoneCapsule {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneCapsule")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BoneCapsule {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneCapsule")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BoneCapsule {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneCapsule")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_BoneCapsule {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+BoneCapsule")]
impl crate::GlobalNamespace::OVRPlugin_BoneCapsule {}
#[cfg(feature = "cordl_class_OVRPlugin+BoneId")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_BoneId {
    #[default]
    Body_Chest = 5i32,
    Body_End = 70i32,
    Body_Head = 7i32,
    Body_Hips = 1i32,
    Body_LeftArmLower = 11i32,
    Body_LeftArmUpper = 10i32,
    Body_LeftHandIndexDistal = 27i32,
    Body_LeftHandIndexIntermediate = 26i32,
    Body_LeftHandIndexMetacarpal = 24i32,
    Body_LeftHandIndexProximal = 25i32,
    Body_LeftHandIndexTip = 28i32,
    Body_LeftHandLittleDistal = 42i32,
    Body_LeftHandLittleIntermediate = 41i32,
    Body_LeftHandLittleMetacarpal = 39i32,
    Body_LeftHandLittleProximal = 40i32,
    Body_LeftHandLittleTip = 43i32,
    Body_LeftHandMiddleDistal = 32i32,
    Body_LeftHandMiddleIntermediate = 31i32,
    Body_LeftHandMiddleMetacarpal = 29i32,
    Body_LeftHandMiddleProximal = 30i32,
    Body_LeftHandMiddleTip = 33i32,
    Body_LeftHandPalm = 18i32,
    Body_LeftHandRingDistal = 37i32,
    Body_LeftHandRingIntermediate = 36i32,
    Body_LeftHandRingMetacarpal = 34i32,
    Body_LeftHandRingProximal = 35i32,
    Body_LeftHandRingTip = 38i32,
    Body_LeftHandThumbDistal = 22i32,
    Body_LeftHandThumbMetacarpal = 20i32,
    Body_LeftHandThumbProximal = 21i32,
    Body_LeftHandThumbTip = 23i32,
    Body_LeftHandWrist = 19i32,
    Body_LeftHandWristTwist = 12i32,
    Body_LeftScapula = 9i32,
    Body_LeftShoulder = 8i32,
    Body_Neck = 6i32,
    Body_RightArmLower = 16i32,
    Body_RightArmUpper = 15i32,
    Body_RightHandIndexDistal = 53i32,
    Body_RightHandIndexIntermediate = 52i32,
    Body_RightHandIndexMetacarpal = 50i32,
    Body_RightHandIndexProximal = 51i32,
    Body_RightHandIndexTip = 54i32,
    Body_RightHandLittleDistal = 68i32,
    Body_RightHandLittleIntermediate = 67i32,
    Body_RightHandLittleMetacarpal = 65i32,
    Body_RightHandLittleProximal = 66i32,
    Body_RightHandLittleTip = 69i32,
    Body_RightHandMiddleDistal = 58i32,
    Body_RightHandMiddleIntermediate = 57i32,
    Body_RightHandMiddleMetacarpal = 55i32,
    Body_RightHandMiddleProximal = 56i32,
    Body_RightHandMiddleTip = 59i32,
    Body_RightHandPalm = 44i32,
    Body_RightHandRingDistal = 63i32,
    Body_RightHandRingIntermediate = 62i32,
    Body_RightHandRingMetacarpal = 60i32,
    Body_RightHandRingProximal = 61i32,
    Body_RightHandRingTip = 64i32,
    Body_RightHandThumbDistal = 48i32,
    Body_RightHandThumbMetacarpal = 46i32,
    Body_RightHandThumbProximal = 47i32,
    Body_RightHandThumbTip = 49i32,
    Body_RightHandWrist = 45i32,
    Body_RightHandWristTwist = 17i32,
    Body_RightScapula = 14i32,
    Body_RightShoulder = 13i32,
    Body_Root = 0i32,
    Body_SpineLower = 2i32,
    Body_SpineMiddle = 3i32,
    Body_SpineUpper = 4i32,
    Invalid = -1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneId")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_BoneId {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BoneId";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneId")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BoneId {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneId")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BoneId {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneId")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BoneId {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoneId")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_BoneId {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bool")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Bool {
    #[default]
    False = 0i32,
    True = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Bool")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Bool {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Bool";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bool")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Bool {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bool")]
unsafe impl quest_hook::libil2cpp::Parameter for crate::GlobalNamespace::OVRPlugin_Bool {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bool")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Bool {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Bool")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Bool {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryGeometry")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_BoundaryGeometry {
    pub BoundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    pub Points: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Vector3f>,
    >,
    pub PointsCount: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryGeometry")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_BoundaryGeometry {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BoundaryGeometry";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryGeometry")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BoundaryGeometry {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryGeometry")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BoundaryGeometry {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryGeometry")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BoundaryGeometry {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryGeometry")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BoundaryGeometry {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryGeometry")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_BoundaryGeometry {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+BoundaryGeometry")]
impl crate::GlobalNamespace::OVRPlugin_BoundaryGeometry {}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryTestResult")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_BoundaryTestResult {
    pub IsTriggering: crate::GlobalNamespace::OVRPlugin_Bool,
    pub ClosestDistance: f32,
    pub ClosestPoint: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub ClosestPointNormal: crate::GlobalNamespace::OVRPlugin_Vector3f,
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryTestResult")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_BoundaryTestResult {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BoundaryTestResult";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryTestResult")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BoundaryTestResult {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryTestResult")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BoundaryTestResult {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryTestResult")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BoundaryTestResult {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryTestResult")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BoundaryTestResult {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryTestResult")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_BoundaryTestResult {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+BoundaryTestResult")]
impl crate::GlobalNamespace::OVRPlugin_BoundaryTestResult {}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_BoundaryType {
    #[default]
    OuterBoundary = 1i32,
    PlayArea = 256i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_BoundaryType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/BoundaryType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_BoundaryType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_BoundaryType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_BoundaryType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+BoundaryType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_BoundaryType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Boundsf")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Boundsf {
    pub Pos: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub Size: crate::GlobalNamespace::OVRPlugin_Size3f,
}
#[cfg(feature = "cordl_class_OVRPlugin+Boundsf")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Boundsf {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Boundsf";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Boundsf")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Boundsf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Boundsf")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Boundsf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Boundsf")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Boundsf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Boundsf")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Boundsf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Boundsf")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Boundsf {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Boundsf")]
impl crate::GlobalNamespace::OVRPlugin_Boundsf {}
#[cfg(feature = "cordl_class_OVRPlugin+CameraAnchorType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_CameraAnchorType {
    #[default]
    CameraAnchorType_Count = 2i32,
    CameraAnchorType_Custom = 1i32,
    CameraAnchorType_EnumSize = 2147483647i32,
    CameraAnchorType_PreDefined = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraAnchorType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_CameraAnchorType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/CameraAnchorType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraAnchorType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_CameraAnchorType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraAnchorType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_CameraAnchorType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraAnchorType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_CameraAnchorType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraAnchorType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_CameraAnchorType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDevice")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_CameraDevice {
    #[default]
    None = 0i32,
    WebCamera0 = 100i32,
    WebCamera1 = 101i32,
    ZEDCamera = 300i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDevice")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_CameraDevice {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/CameraDevice";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDevice")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_CameraDevice {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDevice")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_CameraDevice {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDevice")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_CameraDevice {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDevice")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_CameraDevice {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthQuality")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_CameraDeviceDepthQuality {
    #[default]
    High = 2i32,
    Low = 0i32,
    Medium = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthQuality")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthQuality {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/CameraDeviceDepthQuality";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthQuality")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthQuality {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthQuality")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthQuality {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthQuality")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthQuality {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthQuality")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthQuality {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthSensingMode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_CameraDeviceDepthSensingMode {
    #[default]
    Fill = 1i32,
    Standard = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthSensingMode")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthSensingMode {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/CameraDeviceDepthSensingMode";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthSensingMode")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthSensingMode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthSensingMode")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthSensingMode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthSensingMode")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthSensingMode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceDepthSensingMode")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_CameraDeviceDepthSensingMode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceIntrinsicsParameters")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_CameraDeviceIntrinsicsParameters {
    pub fx: f32,
    pub fy: f32,
    pub cx: f32,
    pub cy: f32,
    pub disto0: f64,
    pub disto1: f64,
    pub disto2: f64,
    pub disto3: f64,
    pub disto4: f64,
    pub v_fov: f32,
    pub h_fov: f32,
    pub d_fov: f32,
    pub w: i32,
    pub h: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceIntrinsicsParameters")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_CameraDeviceIntrinsicsParameters {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/CameraDeviceIntrinsicsParameters";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceIntrinsicsParameters")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_CameraDeviceIntrinsicsParameters {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceIntrinsicsParameters")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_CameraDeviceIntrinsicsParameters {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceIntrinsicsParameters")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_CameraDeviceIntrinsicsParameters {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceIntrinsicsParameters")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_CameraDeviceIntrinsicsParameters {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraDeviceIntrinsicsParameters")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_CameraDeviceIntrinsicsParameters {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+CameraDeviceIntrinsicsParameters")]
impl crate::GlobalNamespace::OVRPlugin_CameraDeviceIntrinsicsParameters {}
#[cfg(feature = "cordl_class_OVRPlugin+CameraExtrinsics")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_CameraExtrinsics {
    pub IsValid: crate::GlobalNamespace::OVRPlugin_Bool,
    pub LastChangedTimeSeconds: f64,
    pub CameraStatusData: crate::GlobalNamespace::OVRPlugin_CameraStatus,
    pub AttachedToNode: crate::GlobalNamespace::OVRPlugin_Node,
    pub RelativePose: crate::GlobalNamespace::OVRPlugin_Posef,
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraExtrinsics")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_CameraExtrinsics {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/CameraExtrinsics";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraExtrinsics")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_CameraExtrinsics {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraExtrinsics")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_CameraExtrinsics {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraExtrinsics")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_CameraExtrinsics {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraExtrinsics")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_CameraExtrinsics {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraExtrinsics")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_CameraExtrinsics {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+CameraExtrinsics")]
impl crate::GlobalNamespace::OVRPlugin_CameraExtrinsics {}
#[cfg(feature = "cordl_class_OVRPlugin+CameraIntrinsics")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_CameraIntrinsics {
    pub IsValid: crate::GlobalNamespace::OVRPlugin_Bool,
    pub LastChangedTimeSeconds: f64,
    pub FOVPort: crate::GlobalNamespace::OVRPlugin_Fovf,
    pub VirtualNearPlaneDistanceMeters: f32,
    pub VirtualFarPlaneDistanceMeters: f32,
    pub ImageSensorPixelResolution: crate::GlobalNamespace::OVRPlugin_Sizei,
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraIntrinsics")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_CameraIntrinsics {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/CameraIntrinsics";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraIntrinsics")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_CameraIntrinsics {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraIntrinsics")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_CameraIntrinsics {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraIntrinsics")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_CameraIntrinsics {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraIntrinsics")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_CameraIntrinsics {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraIntrinsics")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_CameraIntrinsics {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+CameraIntrinsics")]
impl crate::GlobalNamespace::OVRPlugin_CameraIntrinsics {}
#[cfg(feature = "cordl_class_OVRPlugin+CameraStatus")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_CameraStatus {
    #[default]
    CameraStatus_Calibrated = 4i32,
    CameraStatus_Calibrating = 2i32,
    CameraStatus_CalibrationFailed = 3i32,
    CameraStatus_Connected = 1i32,
    CameraStatus_EnumSize = 2147483647i32,
    CameraStatus_None = 0i32,
    CameraStatus_ThirdPerson = 5i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraStatus")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_CameraStatus {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/CameraStatus";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraStatus")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_CameraStatus {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraStatus")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_CameraStatus {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraStatus")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_CameraStatus {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+CameraStatus")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_CameraStatus {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ColorSpace")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_ColorSpace {
    #[default]
    Adobe_RGB = 8i32,
    P3 = 7i32,
    Quest = 6i32,
    Rec_2020 = 2i32,
    Rec_709 = 3i32,
    Rift_CV1 = 4i32,
    Rift_S = 5i32,
    Unknown = 0i32,
    Unmanaged = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+ColorSpace")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_ColorSpace {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/ColorSpace";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ColorSpace")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_ColorSpace {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ColorSpace")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_ColorSpace {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ColorSpace")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_ColorSpace {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ColorSpace")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_ColorSpace {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Colorf")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Colorf {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Colorf")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Colorf {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Colorf";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Colorf")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Colorf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Colorf")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Colorf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Colorf")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Colorf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Colorf")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Colorf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Colorf")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Colorf {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Colorf")]
impl crate::GlobalNamespace::OVRPlugin_Colorf {
    pub fn ToString(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ToString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToString", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Controller")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Controller {
    #[default]
    Active = -2147483648i32,
    All = -1i32,
    Gamepad = 16i32,
    Hands = 96i32,
    LHand = 32i32,
    LTouch = 1i32,
    None = 0i32,
    RHand = 64i32,
    RTouch = 2i32,
    Remote = 4i32,
    Touch = 3i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Controller")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_Controller {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Controller";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Controller")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Controller {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Controller")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Controller {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Controller")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Controller {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Controller")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Controller {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_ControllerState {
    pub ConnectedControllers: u32,
    pub Buttons: u32,
    pub Touches: u32,
    pub NearTouches: u32,
    pub LIndexTrigger: f32,
    pub RIndexTrigger: f32,
    pub LHandTrigger: f32,
    pub RHandTrigger: f32,
    pub LThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_ControllerState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/ControllerState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_ControllerState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_ControllerState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_ControllerState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_ControllerState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_ControllerState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+ControllerState")]
impl crate::GlobalNamespace::OVRPlugin_ControllerState {}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState2")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_ControllerState2 {
    pub ConnectedControllers: u32,
    pub Buttons: u32,
    pub Touches: u32,
    pub NearTouches: u32,
    pub LIndexTrigger: f32,
    pub RIndexTrigger: f32,
    pub LHandTrigger: f32,
    pub RHandTrigger: f32,
    pub LThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub LTouchpad: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RTouchpad: crate::GlobalNamespace::OVRPlugin_Vector2f,
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState2")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_ControllerState2 {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/ControllerState2";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState2")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_ControllerState2 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState2")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_ControllerState2 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState2")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_ControllerState2 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState2")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_ControllerState2 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState2")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_ControllerState2 {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+ControllerState2")]
impl crate::GlobalNamespace::OVRPlugin_ControllerState2 {
    pub fn _ctor(
        &mut self,
        cs: crate::GlobalNamespace::OVRPlugin_ControllerState,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (crate::GlobalNamespace::OVRPlugin_ControllerState),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (cs))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState4")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_ControllerState4 {
    pub ConnectedControllers: u32,
    pub Buttons: u32,
    pub Touches: u32,
    pub NearTouches: u32,
    pub LIndexTrigger: f32,
    pub RIndexTrigger: f32,
    pub LHandTrigger: f32,
    pub RHandTrigger: f32,
    pub LThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub LTouchpad: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RTouchpad: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub LBatteryPercentRemaining: u8,
    pub RBatteryPercentRemaining: u8,
    pub LRecenterCount: u8,
    pub RRecenterCount: u8,
    pub Reserved_27: u8,
    pub Reserved_26: u8,
    pub Reserved_25: u8,
    pub Reserved_24: u8,
    pub Reserved_23: u8,
    pub Reserved_22: u8,
    pub Reserved_21: u8,
    pub Reserved_20: u8,
    pub Reserved_19: u8,
    pub Reserved_18: u8,
    pub Reserved_17: u8,
    pub Reserved_16: u8,
    pub Reserved_15: u8,
    pub Reserved_14: u8,
    pub Reserved_13: u8,
    pub Reserved_12: u8,
    pub Reserved_11: u8,
    pub Reserved_10: u8,
    pub Reserved_09: u8,
    pub Reserved_08: u8,
    pub Reserved_07: u8,
    pub Reserved_06: u8,
    pub Reserved_05: u8,
    pub Reserved_04: u8,
    pub Reserved_03: u8,
    pub Reserved_02: u8,
    pub Reserved_01: u8,
    pub Reserved_00: u8,
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState4")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_ControllerState4 {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/ControllerState4";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState4")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_ControllerState4 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState4")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_ControllerState4 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState4")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_ControllerState4 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState4")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_ControllerState4 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState4")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_ControllerState4 {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+ControllerState4")]
impl crate::GlobalNamespace::OVRPlugin_ControllerState4 {
    pub fn _ctor(
        &mut self,
        cs: crate::GlobalNamespace::OVRPlugin_ControllerState2,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (crate::GlobalNamespace::OVRPlugin_ControllerState2),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (cs))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState5")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_ControllerState5 {
    pub ConnectedControllers: u32,
    pub Buttons: u32,
    pub Touches: u32,
    pub NearTouches: u32,
    pub LIndexTrigger: f32,
    pub RIndexTrigger: f32,
    pub LHandTrigger: f32,
    pub RHandTrigger: f32,
    pub LThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub LTouchpad: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RTouchpad: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub LBatteryPercentRemaining: u8,
    pub RBatteryPercentRemaining: u8,
    pub LRecenterCount: u8,
    pub RRecenterCount: u8,
    pub LThumbRestForce: f32,
    pub RThumbRestForce: f32,
    pub LStylusForce: f32,
    pub RStylusForce: f32,
    pub LIndexTriggerCurl: f32,
    pub RIndexTriggerCurl: f32,
    pub LIndexTriggerSlide: f32,
    pub RIndexTriggerSlide: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState5")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_ControllerState5 {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/ControllerState5";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState5")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_ControllerState5 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState5")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_ControllerState5 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState5")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_ControllerState5 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState5")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_ControllerState5 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState5")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_ControllerState5 {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+ControllerState5")]
impl crate::GlobalNamespace::OVRPlugin_ControllerState5 {
    pub fn _ctor(
        &mut self,
        cs: crate::GlobalNamespace::OVRPlugin_ControllerState4,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (crate::GlobalNamespace::OVRPlugin_ControllerState4),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (cs))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState6")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_ControllerState6 {
    pub ConnectedControllers: u32,
    pub Buttons: u32,
    pub Touches: u32,
    pub NearTouches: u32,
    pub LIndexTrigger: f32,
    pub RIndexTrigger: f32,
    pub LHandTrigger: f32,
    pub RHandTrigger: f32,
    pub LThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RThumbstick: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub LTouchpad: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub RTouchpad: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub LBatteryPercentRemaining: u8,
    pub RBatteryPercentRemaining: u8,
    pub LRecenterCount: u8,
    pub RRecenterCount: u8,
    pub LThumbRestForce: f32,
    pub RThumbRestForce: f32,
    pub LStylusForce: f32,
    pub RStylusForce: f32,
    pub LIndexTriggerCurl: f32,
    pub RIndexTriggerCurl: f32,
    pub LIndexTriggerSlide: f32,
    pub RIndexTriggerSlide: f32,
    pub LIndexTriggerForce: f32,
    pub RIndexTriggerForce: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState6")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_ControllerState6 {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/ControllerState6";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState6")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_ControllerState6 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState6")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_ControllerState6 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState6")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_ControllerState6 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState6")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_ControllerState6 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ControllerState6")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_ControllerState6 {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+ControllerState6")]
impl crate::GlobalNamespace::OVRPlugin_ControllerState6 {
    pub fn _ctor(
        &mut self,
        cs: crate::GlobalNamespace::OVRPlugin_ControllerState5,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (crate::GlobalNamespace::OVRPlugin_ControllerState5),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (cs))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventDataBuffer")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_EventDataBuffer {
    pub EventType: crate::GlobalNamespace::OVRPlugin_EventType,
    pub EventData: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<u8>>,
}
#[cfg(feature = "cordl_class_OVRPlugin+EventDataBuffer")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_EventDataBuffer {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/EventDataBuffer";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventDataBuffer")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_EventDataBuffer {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventDataBuffer")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_EventDataBuffer {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventDataBuffer")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_EventDataBuffer {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventDataBuffer")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_EventDataBuffer {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventDataBuffer")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_EventDataBuffer {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+EventDataBuffer")]
impl crate::GlobalNamespace::OVRPlugin_EventDataBuffer {}
#[cfg(feature = "cordl_class_OVRPlugin+EventType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_EventType {
    #[default]
    DisplayRefreshRateChanged = 1i32,
    SceneCaptureComplete = 100i32,
    SpaceEraseComplete = 54i32,
    SpaceListSaveResult = 57i32,
    SpaceQueryComplete = 52i32,
    SpaceQueryResults = 51i32,
    SpaceSaveComplete = 53i32,
    SpaceSetComponentStatusComplete = 50i32,
    SpaceShareResult = 56i32,
    SpatialAnchorCreateComplete = 49i32,
    Unknown = 0i32,
    VirtualKeyboardBackspace = 202i32,
    VirtualKeyboardCommitText = 201i32,
    VirtualKeyboardEnter = 203i32,
    VirtualKeyboardHidden = 205i32,
    VirtualKeyboardShown = 204i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+EventType")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_EventType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/EventType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_EventType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_EventType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_EventType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EventType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_EventType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Eye")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Eye {
    #[default]
    Count = 2i32,
    Left = 0i32,
    None = -1i32,
    Right = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Eye")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Eye {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Eye";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Eye")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Eye {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Eye")]
unsafe impl quest_hook::libil2cpp::Parameter for crate::GlobalNamespace::OVRPlugin_Eye {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Eye")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Eye {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Eye")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Eye {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazeState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_EyeGazeState {
    pub Pose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub Confidence: f32,
    pub _isValid: crate::GlobalNamespace::OVRPlugin_Bool,
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazeState")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_EyeGazeState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/EyeGazeState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazeState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_EyeGazeState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazeState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_EyeGazeState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazeState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_EyeGazeState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazeState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_EyeGazeState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazeState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_EyeGazeState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+EyeGazeState")]
impl crate::GlobalNamespace::OVRPlugin_EyeGazeState {
    pub fn get_IsValid(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), bool, 0usize>("get_IsValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_IsValid", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_EyeGazesState {
    pub EyeGazes: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            crate::GlobalNamespace::OVRPlugin_EyeGazeState,
        >,
    >,
    pub Time: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesState")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_EyeGazesState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/EyeGazesState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_EyeGazesState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_EyeGazesState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_EyeGazesState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_EyeGazesState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_EyeGazesState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+EyeGazesState")]
impl crate::GlobalNamespace::OVRPlugin_EyeGazesState {}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesStateInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_EyeGazesStateInternal {
    pub EyeGazes_0: crate::GlobalNamespace::OVRPlugin_EyeGazeState,
    pub EyeGazes_1: crate::GlobalNamespace::OVRPlugin_EyeGazeState,
    pub Time: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesStateInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/EyeGazesStateInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesStateInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesStateInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesStateInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesStateInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeGazesStateInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+EyeGazesStateInternal")]
impl crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+EyeTextureFormat")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_EyeTextureFormat {
    #[default]
    B8G8R8A8 = 5i32,
    B8G8R8A8_sRGB = 4i32,
    Default = 0i32,
    EnumSize = 2147483647i32,
    R11G11B10_FP = 3i32,
    R16G16B16A16_FP = 2i32,
    R5G6B5 = 11i32,
    R8G8B8A8 = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeTextureFormat")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_EyeTextureFormat {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/EyeTextureFormat";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeTextureFormat")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_EyeTextureFormat {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeTextureFormat")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_EyeTextureFormat {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeTextureFormat")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_EyeTextureFormat {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+EyeTextureFormat")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_EyeTextureFormat {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceConstants")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_FaceConstants {
    #[default]
    MaxFaceExpressions = 63i32,
    MaxFaceRegionConfidences = 2i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceConstants")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FaceConstants {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FaceConstants";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceConstants")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FaceConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceConstants")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FaceConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceConstants")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FaceConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceConstants")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FaceConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpression")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_FaceExpression {
    #[default]
    Brow_Lowerer_L = 0i32,
    Brow_Lowerer_R = 1i32,
    Cheek_Puff_L = 2i32,
    Cheek_Puff_R = 3i32,
    Cheek_Raiser_L = 4i32,
    Cheek_Raiser_R = 5i32,
    Cheek_Suck_L = 6i32,
    Cheek_Suck_R = 7i32,
    Chin_Raiser_B = 8i32,
    Chin_Raiser_T = 9i32,
    Dimpler_L = 10i32,
    Dimpler_R = 11i32,
    Eyes_Closed_L = 12i32,
    Eyes_Closed_R = 13i32,
    Eyes_Look_Down_L = 14i32,
    Eyes_Look_Down_R = 15i32,
    Eyes_Look_Left_L = 16i32,
    Eyes_Look_Left_R = 17i32,
    Eyes_Look_Right_L = 18i32,
    Eyes_Look_Right_R = 19i32,
    Eyes_Look_Up_L = 20i32,
    Eyes_Look_Up_R = 21i32,
    Inner_Brow_Raiser_L = 22i32,
    Inner_Brow_Raiser_R = 23i32,
    Invalid = -1i32,
    Jaw_Drop = 24i32,
    Jaw_Sideways_Left = 25i32,
    Jaw_Sideways_Right = 26i32,
    Jaw_Thrust = 27i32,
    Lid_Tightener_L = 28i32,
    Lid_Tightener_R = 29i32,
    Lip_Corner_Depressor_L = 30i32,
    Lip_Corner_Depressor_R = 31i32,
    Lip_Corner_Puller_L = 32i32,
    Lip_Corner_Puller_R = 33i32,
    Lip_Funneler_LB = 34i32,
    Lip_Funneler_LT = 35i32,
    Lip_Funneler_RB = 36i32,
    Lip_Funneler_RT = 37i32,
    Lip_Pressor_L = 38i32,
    Lip_Pressor_R = 39i32,
    Lip_Pucker_L = 40i32,
    Lip_Pucker_R = 41i32,
    Lip_Stretcher_L = 42i32,
    Lip_Stretcher_R = 43i32,
    Lip_Suck_LB = 44i32,
    Lip_Suck_LT = 45i32,
    Lip_Suck_RB = 46i32,
    Lip_Suck_RT = 47i32,
    Lip_Tightener_L = 48i32,
    Lip_Tightener_R = 49i32,
    Lips_Toward = 50i32,
    Lower_Lip_Depressor_L = 51i32,
    Lower_Lip_Depressor_R = 52i32,
    Max = 63i32,
    Mouth_Left = 53i32,
    Mouth_Right = 54i32,
    Nose_Wrinkler_L = 55i32,
    Nose_Wrinkler_R = 56i32,
    Outer_Brow_Raiser_L = 57i32,
    Outer_Brow_Raiser_R = 58i32,
    Upper_Lid_Raiser_L = 59i32,
    Upper_Lid_Raiser_R = 60i32,
    Upper_Lip_Raiser_L = 61i32,
    Upper_Lip_Raiser_R = 62i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpression")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FaceExpression {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FaceExpression";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpression")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FaceExpression {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpression")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FaceExpression {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpression")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FaceExpression {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpression")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FaceExpression {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatus")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_FaceExpressionStatus {
    pub IsValid: bool,
    pub IsEyeFollowingBlendshapesValid: bool,
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatus")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FaceExpressionStatus";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatus")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatus")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatus")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatus")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatus")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+FaceExpressionStatus")]
impl crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus {}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatusInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_FaceExpressionStatusInternal {
    pub IsValid: crate::GlobalNamespace::OVRPlugin_Bool,
    pub IsEyeFollowingBlendshapesValid: crate::GlobalNamespace::OVRPlugin_Bool,
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatusInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FaceExpressionStatusInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatusInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatusInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatusInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatusInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceExpressionStatusInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+FaceExpressionStatusInternal")]
impl crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal {
    pub fn ToFaceExpressionStatus(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus,
                        0usize,
                    >("ToFaceExpressionStatus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToFaceExpressionStatus", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceRegionConfidence")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_FaceRegionConfidence {
    #[default]
    Lower = 0i32,
    Max = 2i32,
    Upper = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceRegionConfidence")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FaceRegionConfidence {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FaceRegionConfidence";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceRegionConfidence")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FaceRegionConfidence {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceRegionConfidence")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FaceRegionConfidence {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceRegionConfidence")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FaceRegionConfidence {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceRegionConfidence")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FaceRegionConfidence {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_FaceState {
    pub ExpressionWeights: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<f32>,
    >,
    pub ExpressionWeightConfidences: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<f32>,
    >,
    pub Status: crate::GlobalNamespace::OVRPlugin_FaceExpressionStatus,
    pub Time: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_FaceState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FaceState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FaceState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FaceState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FaceState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FaceState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_FaceState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+FaceState")]
impl crate::GlobalNamespace::OVRPlugin_FaceState {}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState2Internal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_FaceState2Internal {
    pub ExpressionWeights_0: f32,
    pub ExpressionWeights_1: f32,
    pub ExpressionWeights_2: f32,
    pub ExpressionWeights_3: f32,
    pub ExpressionWeights_4: f32,
    pub ExpressionWeights_5: f32,
    pub ExpressionWeights_6: f32,
    pub ExpressionWeights_7: f32,
    pub ExpressionWeights_8: f32,
    pub ExpressionWeights_9: f32,
    pub ExpressionWeights_10: f32,
    pub ExpressionWeights_11: f32,
    pub ExpressionWeights_12: f32,
    pub ExpressionWeights_13: f32,
    pub ExpressionWeights_14: f32,
    pub ExpressionWeights_15: f32,
    pub ExpressionWeights_16: f32,
    pub ExpressionWeights_17: f32,
    pub ExpressionWeights_18: f32,
    pub ExpressionWeights_19: f32,
    pub ExpressionWeights_20: f32,
    pub ExpressionWeights_21: f32,
    pub ExpressionWeights_22: f32,
    pub ExpressionWeights_23: f32,
    pub ExpressionWeights_24: f32,
    pub ExpressionWeights_25: f32,
    pub ExpressionWeights_26: f32,
    pub ExpressionWeights_27: f32,
    pub ExpressionWeights_28: f32,
    pub ExpressionWeights_29: f32,
    pub ExpressionWeights_30: f32,
    pub ExpressionWeights_31: f32,
    pub ExpressionWeights_32: f32,
    pub ExpressionWeights_33: f32,
    pub ExpressionWeights_34: f32,
    pub ExpressionWeights_35: f32,
    pub ExpressionWeights_36: f32,
    pub ExpressionWeights_37: f32,
    pub ExpressionWeights_38: f32,
    pub ExpressionWeights_39: f32,
    pub ExpressionWeights_40: f32,
    pub ExpressionWeights_41: f32,
    pub ExpressionWeights_42: f32,
    pub ExpressionWeights_43: f32,
    pub ExpressionWeights_44: f32,
    pub ExpressionWeights_45: f32,
    pub ExpressionWeights_46: f32,
    pub ExpressionWeights_47: f32,
    pub ExpressionWeights_48: f32,
    pub ExpressionWeights_49: f32,
    pub ExpressionWeights_50: f32,
    pub ExpressionWeights_51: f32,
    pub ExpressionWeights_52: f32,
    pub ExpressionWeights_53: f32,
    pub ExpressionWeights_54: f32,
    pub ExpressionWeights_55: f32,
    pub ExpressionWeights_56: f32,
    pub ExpressionWeights_57: f32,
    pub ExpressionWeights_58: f32,
    pub ExpressionWeights_59: f32,
    pub ExpressionWeights_60: f32,
    pub ExpressionWeights_61: f32,
    pub ExpressionWeights_62: f32,
    pub ExpressionWeightConfidences_0: f32,
    pub ExpressionWeightConfidences_1: f32,
    pub Status: crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal,
    pub Time: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState2Internal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FaceState2Internal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FaceState2Internal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState2Internal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FaceState2Internal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState2Internal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FaceState2Internal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState2Internal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FaceState2Internal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState2Internal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FaceState2Internal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceState2Internal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_FaceState2Internal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+FaceState2Internal")]
impl crate::GlobalNamespace::OVRPlugin_FaceState2Internal {}
#[cfg(feature = "cordl_class_OVRPlugin+FaceStateInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_FaceStateInternal {
    pub ExpressionWeights_0: f32,
    pub ExpressionWeights_1: f32,
    pub ExpressionWeights_2: f32,
    pub ExpressionWeights_3: f32,
    pub ExpressionWeights_4: f32,
    pub ExpressionWeights_5: f32,
    pub ExpressionWeights_6: f32,
    pub ExpressionWeights_7: f32,
    pub ExpressionWeights_8: f32,
    pub ExpressionWeights_9: f32,
    pub ExpressionWeights_10: f32,
    pub ExpressionWeights_11: f32,
    pub ExpressionWeights_12: f32,
    pub ExpressionWeights_13: f32,
    pub ExpressionWeights_14: f32,
    pub ExpressionWeights_15: f32,
    pub ExpressionWeights_16: f32,
    pub ExpressionWeights_17: f32,
    pub ExpressionWeights_18: f32,
    pub ExpressionWeights_19: f32,
    pub ExpressionWeights_20: f32,
    pub ExpressionWeights_21: f32,
    pub ExpressionWeights_22: f32,
    pub ExpressionWeights_23: f32,
    pub ExpressionWeights_24: f32,
    pub ExpressionWeights_25: f32,
    pub ExpressionWeights_26: f32,
    pub ExpressionWeights_27: f32,
    pub ExpressionWeights_28: f32,
    pub ExpressionWeights_29: f32,
    pub ExpressionWeights_30: f32,
    pub ExpressionWeights_31: f32,
    pub ExpressionWeights_32: f32,
    pub ExpressionWeights_33: f32,
    pub ExpressionWeights_34: f32,
    pub ExpressionWeights_35: f32,
    pub ExpressionWeights_36: f32,
    pub ExpressionWeights_37: f32,
    pub ExpressionWeights_38: f32,
    pub ExpressionWeights_39: f32,
    pub ExpressionWeights_40: f32,
    pub ExpressionWeights_41: f32,
    pub ExpressionWeights_42: f32,
    pub ExpressionWeights_43: f32,
    pub ExpressionWeights_44: f32,
    pub ExpressionWeights_45: f32,
    pub ExpressionWeights_46: f32,
    pub ExpressionWeights_47: f32,
    pub ExpressionWeights_48: f32,
    pub ExpressionWeights_49: f32,
    pub ExpressionWeights_50: f32,
    pub ExpressionWeights_51: f32,
    pub ExpressionWeights_52: f32,
    pub ExpressionWeights_53: f32,
    pub ExpressionWeights_54: f32,
    pub ExpressionWeights_55: f32,
    pub ExpressionWeights_56: f32,
    pub ExpressionWeights_57: f32,
    pub ExpressionWeights_58: f32,
    pub ExpressionWeights_59: f32,
    pub ExpressionWeights_60: f32,
    pub ExpressionWeights_61: f32,
    pub ExpressionWeights_62: f32,
    pub ExpressionWeightConfidences_0: f32,
    pub ExpressionWeightConfidences_1: f32,
    pub Status: crate::GlobalNamespace::OVRPlugin_FaceExpressionStatusInternal,
    pub Time: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceStateInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FaceStateInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FaceStateInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceStateInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FaceStateInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceStateInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FaceStateInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceStateInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FaceStateInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceStateInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FaceStateInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FaceStateInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_FaceStateInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+FaceStateInternal")]
impl crate::GlobalNamespace::OVRPlugin_FaceStateInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+FeatureType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_FeatureType {
    #[default]
    BodyTracking = 4i32,
    Count = 7i32,
    EnumSize = 2147483647i32,
    EyeTracking = 2i32,
    FaceTracking = 3i32,
    GazeBasedFoveatedRendering = 6i32,
    HandTracking = 0i32,
    KeyboardTracking = 1i32,
    Passthrough = 5i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+FeatureType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FeatureType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FeatureType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FeatureType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FeatureType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FeatureType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FeatureType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FeatureType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FeatureType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FeatureType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FeatureType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FixedFoveatedRenderingLevel")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_FixedFoveatedRenderingLevel {
    #[default]
    EnumSize = 2147483647i32,
    High = 3i32,
    HighTop = 4i32,
    Low = 1i32,
    Medium = 2i32,
    Off = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+FixedFoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FixedFoveatedRenderingLevel";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FixedFoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FixedFoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FixedFoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FixedFoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FixedFoveatedRenderingLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FoveatedRenderingLevel")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_FoveatedRenderingLevel {
    #[default]
    EnumSize = 2147483647i32,
    High = 3i32,
    HighTop = 4i32,
    Low = 1i32,
    Medium = 2i32,
    Off = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+FoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/FoveatedRenderingLevel";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+FoveatedRenderingLevel")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Fovf")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Fovf {
    pub UpTan: f32,
    pub DownTan: f32,
    pub LeftTan: f32,
    pub RightTan: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Fovf")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Fovf {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Fovf";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Fovf")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Fovf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Fovf")]
unsafe impl quest_hook::libil2cpp::Parameter for crate::GlobalNamespace::OVRPlugin_Fovf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Fovf")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Fovf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Fovf")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Fovf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Fovf")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Fovf {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Fovf")]
impl crate::GlobalNamespace::OVRPlugin_Fovf {}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Frustumf {
    pub zNear: f32,
    pub zFar: f32,
    pub fovX: f32,
    pub fovY: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Frustumf {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Frustumf";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Frustumf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Frustumf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Frustumf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Frustumf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Frustumf {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Frustumf")]
impl crate::GlobalNamespace::OVRPlugin_Frustumf {}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf2")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Frustumf2 {
    pub zNear: f32,
    pub zFar: f32,
    pub Fov: crate::GlobalNamespace::OVRPlugin_Fovf,
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf2")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Frustumf2 {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Frustumf2";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf2")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Frustumf2 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf2")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Frustumf2 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf2")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Frustumf2 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf2")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Frustumf2 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Frustumf2")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Frustumf2 {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Frustumf2")]
impl crate::GlobalNamespace::OVRPlugin_Frustumf2 {}
#[cfg(feature = "cordl_class_OVRPlugin+GUID")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_GUID {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
    pub a: i32,
    pub b: i16,
    pub c: i16,
    pub d0: u8,
    pub d1: u8,
    pub d2: u8,
    pub d3: u8,
    pub d4: u8,
    pub d5: u8,
    pub d6: u8,
    pub d7: u8,
}
#[cfg(feature = "cordl_class_OVRPlugin+GUID")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_GUID {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/GUID";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+GUID")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_GUID {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+GUID")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_GUID {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+GUID")]
impl crate::GlobalNamespace::OVRPlugin_GUID {
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+GUID")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_GUID {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Hand")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Hand {
    #[default]
    HandLeft = 0i32,
    HandRight = 1i32,
    None = -1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Hand")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Hand {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Hand";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Hand")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Hand {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Hand")]
unsafe impl quest_hook::libil2cpp::Parameter for crate::GlobalNamespace::OVRPlugin_Hand {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Hand")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Hand {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Hand")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Hand {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFinger")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_HandFinger {
    #[default]
    Index = 1i32,
    Max = 5i32,
    Middle = 2i32,
    Pinky = 4i32,
    Ring = 3i32,
    Thumb = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFinger")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HandFinger {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HandFinger";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFinger")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HandFinger {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFinger")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HandFinger {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFinger")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HandFinger {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFinger")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HandFinger {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFingerPinch")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_HandFingerPinch {
    #[default]
    Index = 2i32,
    Middle = 4i32,
    Pinky = 16i32,
    Ring = 8i32,
    Thumb = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFingerPinch")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HandFingerPinch {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HandFingerPinch";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFingerPinch")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HandFingerPinch {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFingerPinch")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HandFingerPinch {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFingerPinch")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HandFingerPinch {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandFingerPinch")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HandFingerPinch {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_HandState {
    pub Status: crate::GlobalNamespace::OVRPlugin_HandStatus,
    pub RootPose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub BoneRotations: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Quatf>,
    >,
    pub Pinches: crate::GlobalNamespace::OVRPlugin_HandFingerPinch,
    pub PinchStrength: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<f32>,
    >,
    pub PointerPose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub HandScale: f32,
    pub HandConfidence: crate::GlobalNamespace::OVRPlugin_TrackingConfidence,
    pub FingerConfidences: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            crate::GlobalNamespace::OVRPlugin_TrackingConfidence,
        >,
    >,
    pub RequestedTimeStamp: f64,
    pub SampleTimeStamp: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+HandState")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_HandState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HandState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HandState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HandState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HandState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HandState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_HandState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+HandState")]
impl crate::GlobalNamespace::OVRPlugin_HandState {}
#[cfg(feature = "cordl_class_OVRPlugin+HandStateInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_HandStateInternal {
    pub Status: crate::GlobalNamespace::OVRPlugin_HandStatus,
    pub RootPose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub BoneRotations_0: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_1: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_2: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_3: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_4: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_5: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_6: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_7: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_8: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_9: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_10: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_11: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_12: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_13: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_14: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_15: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_16: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_17: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_18: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_19: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_20: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_21: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_22: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub BoneRotations_23: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub Pinches: crate::GlobalNamespace::OVRPlugin_HandFingerPinch,
    pub PinchStrength_0: f32,
    pub PinchStrength_1: f32,
    pub PinchStrength_2: f32,
    pub PinchStrength_3: f32,
    pub PinchStrength_4: f32,
    pub PointerPose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub HandScale: f32,
    pub HandConfidence: crate::GlobalNamespace::OVRPlugin_TrackingConfidence,
    pub FingerConfidences_0: crate::GlobalNamespace::OVRPlugin_TrackingConfidence,
    pub FingerConfidences_1: crate::GlobalNamespace::OVRPlugin_TrackingConfidence,
    pub FingerConfidences_2: crate::GlobalNamespace::OVRPlugin_TrackingConfidence,
    pub FingerConfidences_3: crate::GlobalNamespace::OVRPlugin_TrackingConfidence,
    pub FingerConfidences_4: crate::GlobalNamespace::OVRPlugin_TrackingConfidence,
    pub RequestedTimeStamp: f64,
    pub SampleTimeStamp: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStateInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HandStateInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HandStateInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStateInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HandStateInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStateInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HandStateInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStateInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HandStateInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStateInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HandStateInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStateInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_HandStateInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+HandStateInternal")]
impl crate::GlobalNamespace::OVRPlugin_HandStateInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+HandStatus")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_HandStatus {
    #[default]
    DominantHand = 128i32,
    HandTracked = 1i32,
    InputStateValid = 2i32,
    MenuPressed = 256i32,
    SystemGestureInProgress = 64i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStatus")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HandStatus {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HandStatus";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStatus")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HandStatus {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStatus")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HandStatus {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStatus")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HandStatus {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HandStatus")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HandStatus {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Handedness")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Handedness {
    #[default]
    LeftHanded = 1i32,
    RightHanded = 2i32,
    Unsupported = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Handedness")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_Handedness {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Handedness";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Handedness")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Handedness {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Handedness")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Handedness {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Handedness")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Handedness {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Handedness")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Handedness {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_HapticsAmplitudeEnvelopeVibration {
    pub Duration: f32,
    pub AmplitudeCount: u32,
    pub Amplitudes: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HapticsAmplitudeEnvelopeVibration";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+HapticsAmplitudeEnvelopeVibration")]
impl crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration {}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsBuffer")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_HapticsBuffer {
    pub Samples: crate::System::IntPtr,
    pub SamplesCount: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsBuffer")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HapticsBuffer {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HapticsBuffer";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsBuffer")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HapticsBuffer {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsBuffer")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HapticsBuffer {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsBuffer")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HapticsBuffer {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsBuffer")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HapticsBuffer {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsBuffer")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_HapticsBuffer {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+HapticsBuffer")]
impl crate::GlobalNamespace::OVRPlugin_HapticsBuffer {}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsConstants")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_HapticsConstants {
    #[default]
    MaxSamples = 4000i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsConstants")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HapticsConstants {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HapticsConstants";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsConstants")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HapticsConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsConstants")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HapticsConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsConstants")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HapticsConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsConstants")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HapticsConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsDesc")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_HapticsDesc {
    pub SampleRateHz: i32,
    pub SampleSizeInBytes: i32,
    pub MinimumSafeSamplesQueued: i32,
    pub MinimumBufferSamplesCount: i32,
    pub OptimalBufferSamplesCount: i32,
    pub MaximumBufferSamplesCount: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsDesc")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HapticsDesc {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HapticsDesc";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsDesc")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HapticsDesc {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsDesc")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HapticsDesc {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsDesc")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HapticsDesc {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsDesc")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HapticsDesc {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsDesc")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_HapticsDesc {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+HapticsDesc")]
impl crate::GlobalNamespace::OVRPlugin_HapticsDesc {}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsLocation")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_HapticsLocation {
    #[default]
    Hand = 1i32,
    Index = 4i32,
    None = 0i32,
    Thumb = 2i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsLocation")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HapticsLocation {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HapticsLocation";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsLocation")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HapticsLocation {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsLocation")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HapticsLocation {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsLocation")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HapticsLocation {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsLocation")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HapticsLocation {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsPcmVibration")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_HapticsPcmVibration {
    pub BufferSize: u32,
    pub Buffer: crate::System::IntPtr,
    pub SampleRateHz: f32,
    pub Append: crate::GlobalNamespace::OVRPlugin_Bool,
    pub SamplesConsumed: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsPcmVibration")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HapticsPcmVibration";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsPcmVibration")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsPcmVibration")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsPcmVibration")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsPcmVibration")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsPcmVibration")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+HapticsPcmVibration")]
impl crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration {}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_HapticsState {
    pub SamplesAvailable: i32,
    pub SamplesQueued: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsState")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_HapticsState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/HapticsState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_HapticsState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_HapticsState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_HapticsState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_HapticsState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+HapticsState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_HapticsState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+HapticsState")]
impl crate::GlobalNamespace::OVRPlugin_HapticsState {}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughColorMapType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_InsightPassthroughColorMapType {
    #[default]
    BrightnessContrastSaturation = 4i32,
    ColorLut = 6i32,
    InterpolatedColorLut = 7i32,
    MonoToMono = 2i32,
    MonoToRgba = 1i32,
    None = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughColorMapType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughColorMapType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/InsightPassthroughColorMapType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughColorMapType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughColorMapType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughColorMapType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughColorMapType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughColorMapType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughColorMapType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughColorMapType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughColorMapType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_InsightPassthroughKeyboardHandsIntensity {
    pub LeftHandIntensity: f32,
    pub RightHandIntensity: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/InsightPassthroughKeyboardHandsIntensity";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+InsightPassthroughKeyboardHandsIntensity")]
impl crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity {}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_InsightPassthroughStyle {
    pub Flags: crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyleFlags,
    pub TextureOpacityFactor: f32,
    pub EdgeColor: crate::GlobalNamespace::OVRPlugin_Colorf,
    pub TextureColorMapType: crate::GlobalNamespace::OVRPlugin_InsightPassthroughColorMapType,
    pub TextureColorMapDataSize: u32,
    pub TextureColorMapData: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/InsightPassthroughStyle";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+InsightPassthroughStyle")]
impl crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle {}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle2")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_InsightPassthroughStyle2 {
    pub Flags: crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyleFlags,
    pub TextureOpacityFactor: f32,
    pub EdgeColor: crate::GlobalNamespace::OVRPlugin_Colorf,
    pub TextureColorMapType: crate::GlobalNamespace::OVRPlugin_InsightPassthroughColorMapType,
    pub TextureColorMapDataSize: u32,
    pub TextureColorMapData: crate::System::IntPtr,
    pub LutSource: u64,
    pub LutTarget: u64,
    pub LutWeight: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle2")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2 {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/InsightPassthroughStyle2";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle2")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle2")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle2")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle2")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyle2")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2 {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+InsightPassthroughStyle2")]
impl crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2 {
    pub fn CopyTo(
        &mut self,
        target: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle,
        >,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle,
                        >),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("CopyTo")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "CopyTo",
                            1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (target))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyleFlags")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_InsightPassthroughStyleFlags {
    #[default]
    HasEdgeColor = 2i32,
    HasTextureColorMap = 4i32,
    HasTextureOpacityFactor = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyleFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyleFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/InsightPassthroughStyleFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyleFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyleFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyleFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyleFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyleFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyleFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InsightPassthroughStyleFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyleFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InteractionProfile")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_InteractionProfile {
    #[default]
    None = 0i32,
    Touch = 1i32,
    TouchPlus = 4i32,
    TouchPro = 2i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+InteractionProfile")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_InteractionProfile {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/InteractionProfile";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InteractionProfile")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_InteractionProfile {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InteractionProfile")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_InteractionProfile {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InteractionProfile")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_InteractionProfile {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+InteractionProfile")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_InteractionProfile {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescription")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_KeyboardDescription {
    pub Name: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<u8>>,
    pub TrackedKeyboardId: u64,
    pub Dimensions: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub KeyboardFlags: crate::GlobalNamespace::OVRPlugin_TrackedKeyboardFlags,
    pub SupportedPresentationStyles: crate::GlobalNamespace::OVRPlugin_TrackedKeyboardPresentationStyles,
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescription")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_KeyboardDescription {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/KeyboardDescription";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescription")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_KeyboardDescription {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescription")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_KeyboardDescription {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescription")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_KeyboardDescription {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescription")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_KeyboardDescription {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescription")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_KeyboardDescription {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+KeyboardDescription")]
impl crate::GlobalNamespace::OVRPlugin_KeyboardDescription {}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescriptionConstants")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_KeyboardDescriptionConstants {
    #[default]
    NameMaxLength = 128i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescriptionConstants")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_KeyboardDescriptionConstants {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/KeyboardDescriptionConstants";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescriptionConstants")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_KeyboardDescriptionConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescriptionConstants")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_KeyboardDescriptionConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescriptionConstants")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_KeyboardDescriptionConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardDescriptionConstants")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_KeyboardDescriptionConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_KeyboardState {
    pub IsActive: crate::GlobalNamespace::OVRPlugin_Bool,
    pub OrientationValid: crate::GlobalNamespace::OVRPlugin_Bool,
    pub PositionValid: crate::GlobalNamespace::OVRPlugin_Bool,
    pub OrientationTracked: crate::GlobalNamespace::OVRPlugin_Bool,
    pub PositionTracked: crate::GlobalNamespace::OVRPlugin_Bool,
    pub PoseState: crate::GlobalNamespace::OVRPlugin_PoseStatef,
    pub ContrastParameters: crate::GlobalNamespace::OVRPlugin_Vector4f,
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardState")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_KeyboardState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/KeyboardState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_KeyboardState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_KeyboardState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_KeyboardState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_KeyboardState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+KeyboardState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_KeyboardState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+KeyboardState")]
impl crate::GlobalNamespace::OVRPlugin_KeyboardState {}
#[cfg(feature = "cordl_class_OVRPlugin+Ktx")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_Ktx {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+Ktx")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Ktx {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Ktx";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Ktx")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_Ktx {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Ktx")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_Ktx {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+Ktx")]
impl crate::GlobalNamespace::OVRPlugin_Ktx {
    pub fn DestroyKtxTexture(
        texture: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        bool,
                        1usize,
                    >("DestroyKtxTexture")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "DestroyKtxTexture", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (texture))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetKtxTextureData(
        texture: crate::System::IntPtr,
        textureData: crate::System::IntPtr,
        bufferSize: u32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, crate::System::IntPtr, u32),
                        bool,
                        3usize,
                    >("GetKtxTextureData")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetKtxTextureData", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (texture, textureData, bufferSize))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetKtxTextureHeight(
        texture: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        u32,
                        1usize,
                    >("GetKtxTextureHeight")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetKtxTextureHeight", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (texture))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetKtxTextureSize(
        texture: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        u32,
                        1usize,
                    >("GetKtxTextureSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetKtxTextureSize", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (texture))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetKtxTextureWidth(
        texture: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        u32,
                        1usize,
                    >("GetKtxTextureWidth")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetKtxTextureWidth", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (texture))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn LoadKtxFromMemory(
        dataPtr: crate::System::IntPtr,
        length: u32,
    ) -> quest_hook::libil2cpp::Result<crate::System::IntPtr> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, u32),
                        crate::System::IntPtr,
                        2usize,
                    >("LoadKtxFromMemory")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "LoadKtxFromMemory", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), (dataPtr, length))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn TranscodeKtxTexture(
        texture: crate::System::IntPtr,
        format: u32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, u32),
                        bool,
                        2usize,
                    >("TranscodeKtxTexture")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "TranscodeKtxTexture", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (texture, format))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Ktx")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_Ktx {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDesc")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_LayerDesc {
    pub Shape: crate::GlobalNamespace::OVRPlugin_OverlayShape,
    pub Layout: crate::GlobalNamespace::OVRPlugin_LayerLayout,
    pub TextureSize: crate::GlobalNamespace::OVRPlugin_Sizei,
    pub MipLevels: i32,
    pub SampleCount: i32,
    pub Format: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub LayerFlags: i32,
    pub Fov: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Fovf>,
    >,
    pub VisibleRect: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Rectf>,
    >,
    pub MaxViewportSize: crate::GlobalNamespace::OVRPlugin_Sizei,
    pub DepthFormat: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub MotionVectorFormat: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub MotionVectorDepthFormat: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub MotionVectorTextureSize: crate::GlobalNamespace::OVRPlugin_Sizei,
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDesc")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_LayerDesc {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LayerDesc";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDesc")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_LayerDesc {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDesc")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_LayerDesc {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDesc")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_LayerDesc {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDesc")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_LayerDesc {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDesc")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_LayerDesc {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+LayerDesc")]
impl crate::GlobalNamespace::OVRPlugin_LayerDesc {
    pub fn ToString(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ToString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToString", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDescInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_LayerDescInternal {
    pub Shape: crate::GlobalNamespace::OVRPlugin_OverlayShape,
    pub Layout: crate::GlobalNamespace::OVRPlugin_LayerLayout,
    pub TextureSize: crate::GlobalNamespace::OVRPlugin_Sizei,
    pub MipLevels: i32,
    pub SampleCount: i32,
    pub Format: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub LayerFlags: i32,
    pub Fov0: crate::GlobalNamespace::OVRPlugin_Fovf,
    pub Fov1: crate::GlobalNamespace::OVRPlugin_Fovf,
    pub VisibleRect0: crate::GlobalNamespace::OVRPlugin_Rectf,
    pub VisibleRect1: crate::GlobalNamespace::OVRPlugin_Rectf,
    pub MaxViewportSize: crate::GlobalNamespace::OVRPlugin_Sizei,
    pub DepthFormat: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub MotionVectorFormat: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub MotionVectorDepthFormat: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    pub MotionVectorTextureSize: crate::GlobalNamespace::OVRPlugin_Sizei,
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDescInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_LayerDescInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LayerDescInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDescInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_LayerDescInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDescInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_LayerDescInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDescInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_LayerDescInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDescInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_LayerDescInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerDescInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_LayerDescInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+LayerDescInternal")]
impl crate::GlobalNamespace::OVRPlugin_LayerDescInternal {
    pub fn ToLayerDesc(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_LayerDesc> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_LayerDesc,
                        0usize,
                    >("ToLayerDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToLayerDesc", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_LayerDesc = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
        layerDesc: crate::GlobalNamespace::OVRPlugin_LayerDesc,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (crate::GlobalNamespace::OVRPlugin_LayerDesc),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (layerDesc))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerFlags")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_LayerFlags {
    #[default]
    AndroidSurfaceSwapChain = 128i32,
    BicubicFiltering = 16384i32,
    ChromaticAberrationCorrection = 16i32,
    LoadingScreen = 2i32,
    NoAllocation = 32i32,
    ProtectedContent = 64i32,
    Static = 1i32,
    SymmetricFov = 4i32,
    TextureOriginAtBottomLeft = 8i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_LayerFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LayerFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_LayerFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_LayerFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_LayerFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_LayerFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerLayout")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_LayerLayout {
    #[default]
    Array = 3i32,
    DoubleWide = 2i32,
    EnumSize = 15i32,
    Mono = 1i32,
    Stereo = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerLayout")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_LayerLayout {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LayerLayout";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerLayout")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_LayerLayout {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerLayout")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_LayerLayout {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerLayout")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_LayerLayout {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerLayout")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_LayerLayout {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSharpenType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_LayerSharpenType {
    #[default]
    None = 0i32,
    Normal = 8192i32,
    Quality = 65536i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSharpenType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_LayerSharpenType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LayerSharpenType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSharpenType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_LayerSharpenType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSharpenType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_LayerSharpenType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSharpenType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_LayerSharpenType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSharpenType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_LayerSharpenType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSubmit")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_LayerSubmit {
    pub LayerId: i32,
    pub TextureStage: i32,
    pub ViewportRect: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Recti>,
    >,
    pub Pose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub LayerSubmitFlags: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSubmit")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_LayerSubmit {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LayerSubmit";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSubmit")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_LayerSubmit {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSubmit")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_LayerSubmit {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSubmit")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_LayerSubmit {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSubmit")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_LayerSubmit {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSubmit")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_LayerSubmit {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+LayerSubmit")]
impl crate::GlobalNamespace::OVRPlugin_LayerSubmit {}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSuperSamplingType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_LayerSuperSamplingType {
    #[default]
    None = 0i32,
    Normal = 4096i32,
    Quality = 256i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSuperSamplingType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_LayerSuperSamplingType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LayerSuperSamplingType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSuperSamplingType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_LayerSuperSamplingType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSuperSamplingType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_LayerSuperSamplingType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSuperSamplingType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_LayerSuperSamplingType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LayerSuperSamplingType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_LayerSuperSamplingType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogCallback2DelegateType")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_LogCallback2DelegateType {
    __cordl_parent: crate::System::MulticastDelegate,
}
#[cfg(feature = "cordl_class_OVRPlugin+LogCallback2DelegateType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LogCallback2DelegateType";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogCallback2DelegateType")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType {
    type Target = crate::System::MulticastDelegate;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogCallback2DelegateType")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+LogCallback2DelegateType")]
impl crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType {
    pub fn BeginInvoke(
        &mut self,
        logLevel: crate::GlobalNamespace::OVRPlugin_LogLevel,
        message: crate::System::IntPtr,
        _cordl_size: i32,
        callback: quest_hook::libil2cpp::Gc<crate::System::AsyncCallback>,
        object: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<crate::System::IAsyncResult>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_LogLevel,
                            crate::System::IntPtr,
                            i32,
                            quest_hook::libil2cpp::Gc<crate::System::AsyncCallback>,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                        ),
                        quest_hook::libil2cpp::Gc<crate::System::IAsyncResult>,
                        5usize,
                    >("BeginInvoke")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "BeginInvoke", 5usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<crate::System::IAsyncResult> = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    self,
                    (logLevel, message, _cordl_size, callback, object),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn EndInvoke(
        &mut self,
        result: quest_hook::libil2cpp::Gc<crate::System::IAsyncResult>,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (quest_hook::libil2cpp::Gc<crate::System::IAsyncResult>),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("EndInvoke")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "EndInvoke", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (result))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Invoke(
        &mut self,
        logLevel: crate::GlobalNamespace::OVRPlugin_LogLevel,
        message: crate::System::IntPtr,
        _cordl_size: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_LogLevel,
                            crate::System::IntPtr,
                            i32,
                        ),
                        quest_hook::libil2cpp::Void,
                        3usize,
                    >("Invoke")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "Invoke",
                            3usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (logLevel, message, _cordl_size))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn New(
        object: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        method: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", (object, method))?;
        Ok(__cordl_object.into())
    }
    pub fn _ctor(
        &mut self,
        object: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        method: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::System::IntPtr,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (object, method))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogCallback2DelegateType")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogLevel")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_LogLevel {
    #[default]
    Debug = 0i32,
    Error = 2i32,
    Info = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+LogLevel")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_LogLevel {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/LogLevel";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogLevel")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_LogLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogLevel")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_LogLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogLevel")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_LogLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+LogLevel")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_LogLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_Media {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+Media")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Media {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Media";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_Media {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_Media {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+Media")]
impl crate::GlobalNamespace::OVRPlugin_Media {
    #[cfg(feature = "OVRPlugin+Media+InputVideoBufferType")]
    pub type InputVideoBufferType = crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType;
    #[cfg(feature = "OVRPlugin+Media+MrcActivationMode")]
    pub type MrcActivationMode = crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode;
    #[cfg(feature = "OVRPlugin+Media+PlatformCameraMode")]
    pub type PlatformCameraMode = crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode;
    pub fn EncodeMrcFrame_IntPtr_IntPtr_Il2CppArray_i32_f64_ByRefMut0(
        textureHandle: crate::System::IntPtr,
        fgTextureHandle: crate::System::IntPtr,
        audioData: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<f32>>,
        audioFrames: i32,
        audioChannels: i32,
        timestamp: f64,
        poseTime: f64,
        outSyncId: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppArray<f32>,
                            >,
                            i32,
                            i32,
                            f64,
                            f64,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        bool,
                        8usize,
                    >("EncodeMrcFrame")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "EncodeMrcFrame", 8usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        textureHandle,
                        fgTextureHandle,
                        audioData,
                        audioFrames,
                        audioChannels,
                        timestamp,
                        poseTime,
                        outSyncId,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn EncodeMrcFrame_RenderTexture_Il2CppArray_i32_f64_ByRefMut1(
        frame: quest_hook::libil2cpp::Gc<crate::UnityEngine::RenderTexture>,
        audioData: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<f32>>,
        audioFrames: i32,
        audioChannels: i32,
        timestamp: f64,
        poseTime: f64,
        outSyncId: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<crate::UnityEngine::RenderTexture>,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppArray<f32>,
                            >,
                            i32,
                            i32,
                            f64,
                            f64,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        bool,
                        7usize,
                    >("EncodeMrcFrame")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "EncodeMrcFrame", 7usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        frame,
                        audioData,
                        audioFrames,
                        audioChannels,
                        timestamp,
                        poseTime,
                        outSyncId,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetInitialized() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("GetInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetInitialized", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetMrcActivationMode() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode,
                        0usize,
                    >("GetMrcActivationMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetMrcActivationMode", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetMrcAudioSampleRate() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("GetMrcAudioSampleRate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetMrcAudioSampleRate", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetMrcFrameImageFlipped() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("GetMrcFrameImageFlipped")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetMrcFrameImageFlipped", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn GetMrcFrameSize(
        frameWidth: quest_hook::libil2cpp::ByRefMut<i32>,
        frameHeight: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<i32>,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("GetMrcFrameSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetMrcFrameSize", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (frameWidth, frameHeight))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetMrcInputVideoBufferType() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType,
                        0usize,
                    >("GetMrcInputVideoBufferType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetMrcInputVideoBufferType", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetPlatformCameraMode() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode,
                        0usize,
                    >("GetPlatformCameraMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetPlatformCameraMode", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Initialize() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("Initialize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "Initialize", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsCastingToRemoteClient() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("IsCastingToRemoteClient")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsCastingToRemoteClient", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsMrcActivated() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("IsMrcActivated")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsMrcActivated", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn IsMrcEnabled() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("IsMrcEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "IsMrcEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn SetAvailableQueueIndexVulkan(
        queueIndexVk: u32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        bool,
                        1usize,
                    >("SetAvailableQueueIndexVulkan")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetAvailableQueueIndexVulkan", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (queueIndexVk))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetMrcActivationMode(
        mode: crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode),
                        bool,
                        1usize,
                    >("SetMrcActivationMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetMrcActivationMode", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (mode))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetMrcAudioSampleRate(
        sampleRate: i32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), bool, 1usize>("SetMrcAudioSampleRate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetMrcAudioSampleRate", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (sampleRate))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetMrcFrameImageFlipped(
        imageFlipped: bool,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (bool),
                        bool,
                        1usize,
                    >("SetMrcFrameImageFlipped")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetMrcFrameImageFlipped", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (imageFlipped))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetMrcFrameSize(
        frameWidth: i32,
        frameHeight: i32,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), bool, 2usize>("SetMrcFrameSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetMrcFrameSize", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (frameWidth, frameHeight))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetMrcHeadsetControllerPose(
        headsetPose: crate::GlobalNamespace::OVRPlugin_Posef,
        leftControllerPose: crate::GlobalNamespace::OVRPlugin_Posef,
        rightControllerPose: crate::GlobalNamespace::OVRPlugin_Posef,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Posef,
                            crate::GlobalNamespace::OVRPlugin_Posef,
                            crate::GlobalNamespace::OVRPlugin_Posef,
                        ),
                        bool,
                        3usize,
                    >("SetMrcHeadsetControllerPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetMrcHeadsetControllerPose", 3usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (headsetPose, leftControllerPose, rightControllerPose),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetMrcInputVideoBufferType(
        videoBufferType: crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType),
                        bool,
                        1usize,
                    >("SetMrcInputVideoBufferType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetMrcInputVideoBufferType", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (videoBufferType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetPlatformCameraMode(
        mode: crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode),
                        bool,
                        1usize,
                    >("SetPlatformCameraMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetPlatformCameraMode", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (mode))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetPlatformInitialized() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("SetPlatformInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetPlatformInitialized", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn Shutdown() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("Shutdown")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "Shutdown", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn SyncMrcFrame(syncId: i32) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), bool, 1usize>("SyncMrcFrame")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SyncMrcFrame", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (syncId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Update() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("Update")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "Update",
                            0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn UseMrcDebugCamera() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("UseMrcDebugCamera")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "UseMrcDebugCamera", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Media")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_Media {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Mesh")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_Mesh {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
    pub Type: crate::GlobalNamespace::OVRPlugin_MeshType,
    pub NumVertices: u32,
    pub NumIndices: u32,
    pub VertexPositions: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Vector3f>,
    >,
    pub Indices: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<i16>>,
    pub VertexNormals: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Vector3f>,
    >,
    pub VertexUV0: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Vector2f>,
    >,
    pub BlendIndices: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Vector4s>,
    >,
    pub BlendWeights: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Vector4f>,
    >,
}
#[cfg(feature = "cordl_class_OVRPlugin+Mesh")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Mesh {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Mesh";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Mesh")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_Mesh {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Mesh")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_Mesh {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+Mesh")]
impl crate::GlobalNamespace::OVRPlugin_Mesh {
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Mesh")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_Mesh {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshConstants")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_MeshConstants {
    #[default]
    MaxIndices = 18000i32,
    MaxVertices = 3000i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshConstants")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_MeshConstants {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/MeshConstants";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshConstants")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_MeshConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshConstants")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_MeshConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshConstants")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_MeshConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshConstants")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_MeshConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_MeshType {
    #[default]
    HandLeft = 0i32,
    HandRight = 1i32,
    None = -1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshType")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_MeshType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/MeshType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_MeshType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_MeshType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_MeshType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+MeshType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_MeshType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Node")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Node {
    #[default]
    ControllerLeft = 12i32,
    ControllerRight = 13i32,
    Count = 14i32,
    DeviceObjectZero = 10i32,
    EyeCenter = 2i32,
    EyeLeft = 0i32,
    EyeRight = 1i32,
    HandLeft = 3i32,
    HandRight = 4i32,
    Head = 9i32,
    None = -1i32,
    TrackedKeyboard = 11i32,
    TrackerOne = 6i32,
    TrackerThree = 8i32,
    TrackerTwo = 7i32,
    TrackerZero = 5i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Node")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Node {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Node";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Node")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Node {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Node")]
unsafe impl quest_hook::libil2cpp::Parameter for crate::GlobalNamespace::OVRPlugin_Node {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Node")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Node {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Node")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Node {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_0_1_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_0_1_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_0_1_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_0_1_0 {
    pub fn ovrp_GetEyeTextureSize(
        eyeId: crate::GlobalNamespace::OVRPlugin_Eye,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Sizei> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Eye),
                        crate::GlobalNamespace::OVRPlugin_Sizei,
                        1usize,
                    >("ovrp_GetEyeTextureSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeTextureSize", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Sizei = unsafe {
            cordl_method_info.invoke_unchecked((), (eyeId))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_1")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_0_1_1 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_1")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_1 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_0_1_1";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_1")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_1 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_1")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_1 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_0_1_1")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_0_1_1 {
    pub fn ovrp_SetOverlayQuad2(
        onTop: crate::GlobalNamespace::OVRPlugin_Bool,
        headLocked: crate::GlobalNamespace::OVRPlugin_Bool,
        texture: crate::System::IntPtr,
        device: crate::System::IntPtr,
        pose: crate::GlobalNamespace::OVRPlugin_Posef,
        scale: crate::GlobalNamespace::OVRPlugin_Vector3f,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Bool,
                            crate::GlobalNamespace::OVRPlugin_Bool,
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            crate::GlobalNamespace::OVRPlugin_Posef,
                            crate::GlobalNamespace::OVRPlugin_Vector3f,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        6usize,
                    >("ovrp_SetOverlayQuad2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetOverlayQuad2", 6usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (onTop, headLocked, texture, device, pose, scale))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_1")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_1 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_2")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_0_1_2 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_2")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_2 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_0_1_2";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_2")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_2 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_2")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_2 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_0_1_2")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_0_1_2 {
    pub fn ovrp_GetNodePose(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        1usize,
                    >("ovrp_GetNodePose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePose", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetControllerVibration(
        controllerMask: u32,
        frequency: f32,
        amplitude: f32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, f32, f32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        3usize,
                    >("ovrp_SetControllerVibration")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetControllerVibration", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (controllerMask, frequency, amplitude))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_2")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_2 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_3")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_0_1_3 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_3")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_3 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_0_1_3";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_3")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_3 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_3")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_3 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_0_1_3")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_0_1_3 {
    pub fn ovrp_GetNodeAcceleration(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        1usize,
                    >("ovrp_GetNodeAcceleration")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodeAcceleration", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodeVelocity(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        1usize,
                    >("ovrp_GetNodeVelocity")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodeVelocity", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_1_3")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_0_1_3 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_5_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_0_5_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_5_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_0_5_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_0_5_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_5_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_0_5_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_5_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_0_5_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_0_5_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_0_5_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_0_5_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_0_5_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_0_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_0_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_0_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_0_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_0_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_0_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_0_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_0_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_0_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_0_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_0_0 {
    pub fn ovrp_GetTrackingCalibratedOrigin() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Posef,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        0usize,
                    >("ovrp_GetTrackingCalibratedOrigin")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingCalibratedOrigin", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTrackingOriginType() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
                        0usize,
                    >("ovrp_GetTrackingOriginType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingOriginType", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_TrackingOrigin = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_RecenterTrackingOrigin(
        flags: u32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_RecenterTrackingOrigin")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_RecenterTrackingOrigin", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (flags))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetTrackingOriginType(
        originType: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_TrackingOrigin),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetTrackingOriginType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetTrackingOriginType", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (originType))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_0_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_0_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_10_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_10_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_10_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_10_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_10_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_10_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_10_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_10_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_10_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_10_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_10_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_10_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_10_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_11_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_11_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_11_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_11_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_11_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_11_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_11_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_11_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_11_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_11_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_11_0 {
    pub fn ovrp_GetDesiredEyeTextureFormat() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
                        0usize,
                    >("ovrp_GetDesiredEyeTextureFormat")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetDesiredEyeTextureFormat", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetDesiredEyeTextureFormat(
        value: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_EyeTextureFormat),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetDesiredEyeTextureFormat")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetDesiredEyeTextureFormat", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_11_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_11_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_12_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_12_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_12_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_12_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_12_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_12_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_12_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_12_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_12_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_12_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_12_0 {
    pub fn ovrp_GetAppFramerate() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("ovrp_GetAppFramerate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppFramerate", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetControllerState2(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ControllerState2,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_ControllerState2,
                        1usize,
                    >("ovrp_GetControllerState2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerState2", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ControllerState2 = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodePoseState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_PoseStatef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            crate::GlobalNamespace::OVRPlugin_Node,
                        ),
                        crate::GlobalNamespace::OVRPlugin_PoseStatef,
                        2usize,
                    >("ovrp_GetNodePoseState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePoseState", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_PoseStatef = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, nodeId))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_12_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_12_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_15_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_15_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_15_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_15_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_15_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_15_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_15_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_15_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_15_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_15_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_15_0 {
    pub const OVRP_EXTERNAL_CAMERA_NAME_SIZE: i32 = 32i32;
    pub fn ovrp_CalculateLayerDesc(
        shape: crate::GlobalNamespace::OVRPlugin_OverlayShape,
        layout: crate::GlobalNamespace::OVRPlugin_LayerLayout,
        textureSize: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Sizei,
        >,
        mipLevels: i32,
        sampleCount: i32,
        format: crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
        layerFlags: i32,
        layerDesc: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_LayerDescInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_OverlayShape,
                            crate::GlobalNamespace::OVRPlugin_LayerLayout,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Sizei,
                            >,
                            i32,
                            i32,
                            crate::GlobalNamespace::OVRPlugin_EyeTextureFormat,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_LayerDescInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        8usize,
                    >("ovrp_CalculateLayerDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_CalculateLayerDesc", 8usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        shape,
                        layout,
                        textureSize,
                        mipLevels,
                        sampleCount,
                        format,
                        layerFlags,
                        layerDesc,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_EnqueueDestroyLayer(
        layerId: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_EnqueueDestroyLayer")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_EnqueueDestroyLayer", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_EnqueueSetupLayer(
        desc: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_LayerDescInternal,
        >,
        layerId: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_LayerDescInternal,
                            >,
                            crate::System::IntPtr,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_EnqueueSetupLayer")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_EnqueueSetupLayer", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (desc, layerId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_EnqueueSubmitLayer(
        flags: u32,
        textureLeft: crate::System::IntPtr,
        textureRight: crate::System::IntPtr,
        layerId: i32,
        frameIndex: i32,
        pose: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Posef>,
        scale: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Vector3f,
        >,
        layerIndex: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u32,
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            i32,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Vector3f,
                            >,
                            i32,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        8usize,
                    >("ovrp_EnqueueSubmitLayer")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_EnqueueSubmitLayer", 8usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        flags,
                        textureLeft,
                        textureRight,
                        layerId,
                        frameIndex,
                        pose,
                        scale,
                        layerIndex,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetExternalCameraCount(
        cameraCount: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<i32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetExternalCameraCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetExternalCameraCount", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraCount))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetExternalCameraExtrinsics(
        cameraId: i32,
        cameraExtrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetExternalCameraExtrinsics")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetExternalCameraExtrinsics", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId, cameraExtrinsics))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetExternalCameraIntrinsics(
        cameraId: i32,
        cameraIntrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetExternalCameraIntrinsics")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetExternalCameraIntrinsics", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId, cameraIntrinsics))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetExternalCameraName(
        cameraId: i32,
        cameraName: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<char>>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppArray<char>,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetExternalCameraName")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetExternalCameraName", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId, cameraName))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetEyeTextureArrayEnabled() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetEyeTextureArrayEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeTextureArrayEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetLayerTexturePtr(
        layerId: i32,
        stage: i32,
        eyeId: crate::GlobalNamespace::OVRPlugin_Eye,
        textureHandle: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            i32,
                            crate::GlobalNamespace::OVRPlugin_Eye,
                            quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_GetLayerTexturePtr")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetLayerTexturePtr", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (layerId, stage, eyeId, textureHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetLayerTextureStageCount(
        layerId: i32,
        layerTextureStageCount: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, quest_hook::libil2cpp::ByRefMut<i32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetLayerTextureStageCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetLayerTextureStageCount", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, layerTextureStageCount))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetMixedRealityInitialized() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetMixedRealityInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetMixedRealityInitialized", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodeFrustum2(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        nodeFrustum: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Frustumf2,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Frustumf2,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetNodeFrustum2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodeFrustum2", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, nodeFrustum))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_InitializeMixedReality() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_InitializeMixedReality")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_InitializeMixedReality", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_ShutdownMixedReality() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_ShutdownMixedReality")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_ShutdownMixedReality", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UpdateExternalCamera() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_UpdateExternalCamera")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UpdateExternalCamera", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_15_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_15_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_16_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_16_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_16_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_16_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_16_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_16_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_16_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_16_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_16_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_16_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_16_0 {
    pub fn ovrp_CloseCameraDevice(
        cameraDevice: crate::GlobalNamespace::OVRPlugin_CameraDevice,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_CameraDevice),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_CloseCameraDevice")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_CloseCameraDevice", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraDevice))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetCameraDeviceColorFrameBgraPixels(
        cameraDevice: crate::GlobalNamespace::OVRPlugin_CameraDevice,
        colorFrameBgraPixels: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
        colorFrameRowPitch: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_CameraDevice,
                            quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetCameraDeviceColorFrameBgraPixels")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetCameraDeviceColorFrameBgraPixels", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (cameraDevice, colorFrameBgraPixels, colorFrameRowPitch),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetCameraDeviceColorFrameSize(
        cameraDevice: crate::GlobalNamespace::OVRPlugin_CameraDevice,
        colorFrameSize: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Sizei,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_CameraDevice,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Sizei,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetCameraDeviceColorFrameSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetCameraDeviceColorFrameSize", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraDevice, colorFrameSize))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetControllerState4(
        controllerMask: u32,
        controllerState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_ControllerState4,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_ControllerState4,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetControllerState4")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerState4", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, controllerState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_HasCameraDeviceOpened(
        cameraDevice: crate::GlobalNamespace::OVRPlugin_CameraDevice,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_CameraDevice),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_HasCameraDeviceOpened")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_HasCameraDeviceOpened", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraDevice))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_IsCameraDeviceAvailable(
        cameraDevice: crate::GlobalNamespace::OVRPlugin_CameraDevice,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_CameraDevice),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_IsCameraDeviceAvailable")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_IsCameraDeviceAvailable", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraDevice))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_IsCameraDeviceColorFrameAvailable(
        cameraDevice: crate::GlobalNamespace::OVRPlugin_CameraDevice,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_CameraDevice),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_IsCameraDeviceColorFrameAvailable")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_IsCameraDeviceColorFrameAvailable", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraDevice))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_OpenCameraDevice(
        cameraDevice: crate::GlobalNamespace::OVRPlugin_CameraDevice,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_CameraDevice),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_OpenCameraDevice")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_OpenCameraDevice", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraDevice))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetCameraDevicePreferredColorFrameSize(
        cameraDevice: crate::GlobalNamespace::OVRPlugin_CameraDevice,
        preferredColorFrameSize: crate::GlobalNamespace::OVRPlugin_Sizei,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_CameraDevice,
                            crate::GlobalNamespace::OVRPlugin_Sizei,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SetCameraDevicePreferredColorFrameSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetCameraDevicePreferredColorFrameSize", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (cameraDevice, preferredColorFrameSize))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UpdateCameraDevices() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_UpdateCameraDevices")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UpdateCameraDevices", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_16_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_16_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_17_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_17_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_17_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_17_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_17_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_17_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_17_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_17_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_17_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_17_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_17_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_17_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_17_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_18_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_18_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_18_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_18_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_18_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_18_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_18_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_18_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_18_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_18_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_18_0 {
    pub fn ovrp_GetAppHasInputFocus(
        appHasInputFocus: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetAppHasInputFocus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppHasInputFocus", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (appHasInputFocus))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetHandNodePoseStateLatency(
        latencyInSeconds: quest_hook::libil2cpp::ByRefMut<f64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<f64>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetHandNodePoseStateLatency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetHandNodePoseStateLatency", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (latencyInSeconds))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetHandNodePoseStateLatency(
        latencyInSeconds: f64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetHandNodePoseStateLatency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetHandNodePoseStateLatency", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (latencyInSeconds))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_18_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_18_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_19_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_19_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_19_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_19_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_19_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_19_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_19_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_19_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_19_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_19_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_19_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_19_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_19_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_1_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_1_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_1_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_1_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_1_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_1_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_1_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_1_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_1_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_1_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_1_0 {
    pub fn _ovrp_GetAppLatencyTimings() -> quest_hook::libil2cpp::Result<
        crate::System::IntPtr,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::System::IntPtr,
                        0usize,
                    >("_ovrp_GetAppLatencyTimings")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "_ovrp_GetAppLatencyTimings", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ovrp_GetNativeSDKVersion() -> quest_hook::libil2cpp::Result<
        crate::System::IntPtr,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::System::IntPtr,
                        0usize,
                    >("_ovrp_GetNativeSDKVersion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "_ovrp_GetNativeSDKVersion", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ovrp_GetSystemProductName() -> quest_hook::libil2cpp::Result<
        crate::System::IntPtr,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::System::IntPtr,
                        0usize,
                    >("_ovrp_GetSystemProductName")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "_ovrp_GetSystemProductName", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ovrp_GetVersion() -> quest_hook::libil2cpp::Result<crate::System::IntPtr> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::System::IntPtr,
                        0usize,
                    >("_ovrp_GetVersion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "_ovrp_GetVersion", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetAppHasVrFocus() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetAppHasVrFocus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppHasVrFocus", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetAppLatencyTimings() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ovrp_GetAppLatencyTimings")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppLatencyTimings", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetAppMonoscopic() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetAppMonoscopic")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppMonoscopic", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetAppShouldQuit() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetAppShouldQuit")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppShouldQuit", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetAppShouldRecenter() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetAppShouldRecenter")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppShouldRecenter", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetAudioInId() -> quest_hook::libil2cpp::Result<crate::System::IntPtr> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::System::IntPtr,
                        0usize,
                    >("ovrp_GetAudioInId")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAudioInId", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetAudioOutId() -> quest_hook::libil2cpp::Result<crate::System::IntPtr> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::System::IntPtr,
                        0usize,
                    >("ovrp_GetAudioOutId")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAudioOutId", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetControllerState(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_ControllerState,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_ControllerState,
                        1usize,
                    >("ovrp_GetControllerState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerState", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_ControllerState = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetEyeTextureScale() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("ovrp_GetEyeTextureScale")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeTextureScale", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetInitialized() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetInitialized", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNativeSDKVersion() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ovrp_GetNativeSDKVersion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNativeSDKVersion", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodeFrustum(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Frustumf> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Frustumf,
                        1usize,
                    >("ovrp_GetNodeFrustum")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodeFrustum", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Frustumf = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodeOrientationTracked(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_GetNodeOrientationTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodeOrientationTracked", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodePositionTracked(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_GetNodePositionTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePositionTracked", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodePresent(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_GetNodePresent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePresent", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemBatteryLevel() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("ovrp_GetSystemBatteryLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemBatteryLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemBatteryStatus() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_BatteryStatus,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_BatteryStatus,
                        0usize,
                    >("ovrp_GetSystemBatteryStatus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemBatteryStatus", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_BatteryStatus = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemBatteryTemperature() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        f32,
                        0usize,
                    >("ovrp_GetSystemBatteryTemperature")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemBatteryTemperature", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemCpuLevel() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("ovrp_GetSystemCpuLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemCpuLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemDisplayFrequency() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        f32,
                        0usize,
                    >("ovrp_GetSystemDisplayFrequency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemDisplayFrequency", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemGpuLevel() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("ovrp_GetSystemGpuLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemGpuLevel", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemPowerSavingMode() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetSystemPowerSavingMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemPowerSavingMode", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemProductName() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ovrp_GetSystemProductName")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemProductName", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemVSyncCount() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), i32, 0usize>("ovrp_GetSystemVSyncCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemVSyncCount", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemVolume() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("ovrp_GetSystemVolume")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemVolume", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTrackingOrientationEnabled() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetTrackingOrientationEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingOrientationEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTrackingOrientationSupported() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetTrackingOrientationSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingOrientationSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTrackingPositionEnabled() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetTrackingPositionEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingPositionEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTrackingPositionSupported() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetTrackingPositionSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingPositionSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetUserEyeDepth() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("ovrp_GetUserEyeDepth")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetUserEyeDepth", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetUserEyeHeight() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("ovrp_GetUserEyeHeight")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetUserEyeHeight", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetUserIPD() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), f32, 0usize>("ovrp_GetUserIPD")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetUserIPD", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetUserPresent() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetUserPresent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetUserPresent", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetVersion() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ovrp_GetVersion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetVersion", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetAppMonoscopic(
        value: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetAppMonoscopic")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetAppMonoscopic", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetEyeTextureScale(
        value: f32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetEyeTextureScale")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetEyeTextureScale", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetSystemCpuLevel(
        value: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetSystemCpuLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetSystemCpuLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetSystemGpuLevel(
        value: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetSystemGpuLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetSystemGpuLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetTrackingOrientationEnabled(
        value: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetTrackingOrientationEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetTrackingOrientationEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetTrackingPositionEnabled(
        value: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetTrackingPositionEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetTrackingPositionEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetUserEyeDepth(
        value: f32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetUserEyeDepth")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetUserEyeDepth", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetUserEyeHeight(
        value: f32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetUserEyeHeight")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetUserEyeHeight", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetUserIPD(
        value: f32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetUserIPD")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetUserIPD", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_ShowSystemUI(
        ui: crate::GlobalNamespace::OVRPlugin_PlatformUI,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_PlatformUI),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_ShowSystemUI")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_ShowSystemUI", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (ui))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_1_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_1_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_21_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_21_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_21_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_21_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_21_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_21_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_21_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_21_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_21_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_21_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_21_0 {
    pub fn ovrp_GetAppAsymmetricFov(
        useAsymmetricFov: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetAppAsymmetricFov")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppAsymmetricFov", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (useAsymmetricFov))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetGPUUtilLevel(
        gpuUtil: quest_hook::libil2cpp::ByRefMut<f32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<f32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetGPUUtilLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetGPUUtilLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (gpuUtil))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetGPUUtilSupported(
        gpuUtilSupported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetGPUUtilSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetGPUUtilSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (gpuUtilSupported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemDisplayAvailableFrequencies(
        systemDisplayAvailableFrequencies: crate::System::IntPtr,
        numFrequencies: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, quest_hook::libil2cpp::ByRefMut<i32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSystemDisplayAvailableFrequencies")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemDisplayAvailableFrequencies", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (systemDisplayAvailableFrequencies, numFrequencies),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemDisplayFrequency2(
        systemDisplayFrequency: quest_hook::libil2cpp::ByRefMut<f32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<f32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetSystemDisplayFrequency2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemDisplayFrequency2", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (systemDisplayFrequency))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTiledMultiResLevel(
        level: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetTiledMultiResLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTiledMultiResLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (level))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTiledMultiResSupported(
        foveationSupported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetTiledMultiResSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTiledMultiResSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (foveationSupported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetSystemDisplayFrequency(
        requestedFrequency: f32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetSystemDisplayFrequency")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetSystemDisplayFrequency", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (requestedFrequency))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetTiledMultiResLevel(
        level: crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_FoveatedRenderingLevel),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetTiledMultiResLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetTiledMultiResLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (level))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_21_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_21_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_28_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_28_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_28_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_28_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_28_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_28_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_28_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_28_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_28_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_28_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_28_0 {
    pub fn ovrp_EnqueueSetupLayer2(
        desc: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_LayerDescInternal,
        >,
        compositionDepth: i32,
        layerId: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_LayerDescInternal,
                            >,
                            i32,
                            crate::System::IntPtr,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_EnqueueSetupLayer2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_EnqueueSetupLayer2", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (desc, compositionDepth, layerId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetDominantHand(
        dominantHand: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Handedness,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Handedness,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetDominantHand")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetDominantHand", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (dominantHand))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SendEvent(
        name: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        param: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SendEvent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SendEvent", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (name, param))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_28_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_28_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_29_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_29_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_29_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_29_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_29_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_29_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_29_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_29_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_29_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_29_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_29_0 {
    pub fn ovrp_GetHeadPoseModifier(
        relativeRotation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Quatf,
        >,
        relativeTranslation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Vector3f,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Quatf,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Vector3f,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetHeadPoseModifier")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetHeadPoseModifier", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (relativeRotation, relativeTranslation))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetLayerAndroidSurfaceObject(
        layerId: i32,
        surfaceObject: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetLayerAndroidSurfaceObject")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetLayerAndroidSurfaceObject", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, surfaceObject))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodePoseStateRaw(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        frameIndex: i32,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        nodePoseState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PoseStatef,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            i32,
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_PoseStatef,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_GetNodePoseStateRaw")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePoseStateRaw", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (stepId, frameIndex, nodeId, nodePoseState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetHeadPoseModifier(
        relativeRotation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Quatf,
        >,
        relativeTranslation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Vector3f,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Quatf,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Vector3f,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SetHeadPoseModifier")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetHeadPoseModifier", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (relativeRotation, relativeTranslation))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_29_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_29_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_2_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_2_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_2_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_2_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_2_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_2_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_2_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_2_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_2_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_2_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_2_0 {
    pub fn ovrp_SetSystemVSyncCount(
        vsyncCount: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetSystemVSyncCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetSystemVSyncCount", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (vsyncCount))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrpi_SetTrackingCalibratedOrigin() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrpi_SetTrackingCalibratedOrigin")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrpi_SetTrackingCalibratedOrigin", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_2_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_2_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_30_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_30_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_30_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_30_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_30_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_30_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_30_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_30_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_30_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_30_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_30_0 {
    pub fn ovrp_GetCurrentTrackingTransformPose(
        trackingTransformPose: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Posef,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Posef,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetCurrentTrackingTransformPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetCurrentTrackingTransformPose", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (trackingTransformPose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetPerfMetricsFloat(
        perfMetrics: crate::GlobalNamespace::OVRPlugin_PerfMetrics,
        value: quest_hook::libil2cpp::ByRefMut<f32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_PerfMetrics,
                            quest_hook::libil2cpp::ByRefMut<f32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetPerfMetricsFloat")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetPerfMetricsFloat", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (perfMetrics, value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetPerfMetricsInt(
        perfMetrics: crate::GlobalNamespace::OVRPlugin_PerfMetrics,
        value: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_PerfMetrics,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetPerfMetricsInt")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetPerfMetricsInt", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (perfMetrics, value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTrackingTransformRawPose(
        trackingTransformRawPose: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Posef,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Posef,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetTrackingTransformRawPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingTransformRawPose", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (trackingTransformRawPose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_IsPerfMetricsSupported(
        perfMetrics: crate::GlobalNamespace::OVRPlugin_PerfMetrics,
        isSupported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_PerfMetrics,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_IsPerfMetricsSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_IsPerfMetricsSupported", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (perfMetrics, isSupported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SendEvent2(
        name: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        param: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        source: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_SendEvent2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SendEvent2", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (name, param, source))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_30_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_30_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_31_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_31_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_31_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_31_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_31_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_31_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_31_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_31_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_31_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_31_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_31_0 {
    pub fn ovrp_GetTimeInSeconds(
        value: quest_hook::libil2cpp::ByRefMut<f64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<f64>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetTimeInSeconds")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTimeInSeconds", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetColorScaleAndOffset(
        colorScale: crate::UnityEngine::Vector4,
        colorOffset: crate::UnityEngine::Vector4,
        applyToAllLayers: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::UnityEngine::Vector4,
                            crate::UnityEngine::Vector4,
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_SetColorScaleAndOffset")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetColorScaleAndOffset", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (colorScale, colorOffset, applyToAllLayers))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_31_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_31_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_32_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_32_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_32_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_32_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_32_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_32_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_32_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_32_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_32_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_32_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_32_0 {
    pub fn ovrp_AddCustomMetadata(
        name: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        param: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_AddCustomMetadata")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_AddCustomMetadata", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (name, param))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_32_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_32_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_34_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_34_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_34_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_34_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_34_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_34_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_34_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_34_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_34_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_34_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_34_0 {
    pub fn ovrp_EnqueueSubmitLayer2(
        flags: u32,
        textureLeft: crate::System::IntPtr,
        textureRight: crate::System::IntPtr,
        layerId: i32,
        frameIndex: i32,
        pose: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Posef>,
        scale: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Vector3f,
        >,
        layerIndex: i32,
        overrideTextureRectMatrix: crate::GlobalNamespace::OVRPlugin_Bool,
        textureRectMatrix: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf,
        >,
        overridePerLayerColorScaleAndOffset: crate::GlobalNamespace::OVRPlugin_Bool,
        colorScale: quest_hook::libil2cpp::ByRefMut<crate::UnityEngine::Vector4>,
        colorOffset: quest_hook::libil2cpp::ByRefMut<crate::UnityEngine::Vector4>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u32,
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            i32,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Vector3f,
                            >,
                            i32,
                            crate::GlobalNamespace::OVRPlugin_Bool,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf,
                            >,
                            crate::GlobalNamespace::OVRPlugin_Bool,
                            quest_hook::libil2cpp::ByRefMut<crate::UnityEngine::Vector4>,
                            quest_hook::libil2cpp::ByRefMut<crate::UnityEngine::Vector4>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        13usize,
                    >("ovrp_EnqueueSubmitLayer2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_EnqueueSubmitLayer2", 13usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        flags,
                        textureLeft,
                        textureRight,
                        layerId,
                        frameIndex,
                        pose,
                        scale,
                        layerIndex,
                        overrideTextureRectMatrix,
                        textureRectMatrix,
                        overridePerLayerColorScaleAndOffset,
                        colorScale,
                        colorOffset,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_34_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_34_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_35_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_35_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_35_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_35_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_35_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_35_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_35_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_35_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_35_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_35_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_35_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_35_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_35_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_36_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_36_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_36_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_36_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_36_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_36_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_36_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_36_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_36_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_36_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_36_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_36_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_36_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_37_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_37_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_37_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_37_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_37_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_37_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_37_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_37_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_37_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_37_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_37_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_37_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_37_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_38_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_38_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_38_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_38_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_38_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_38_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_38_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_38_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_38_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_38_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_38_0 {
    pub fn ovrp_GetNodeOrientationValid(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        nodeOrientationValid: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetNodeOrientationValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodeOrientationValid", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, nodeOrientationValid))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodePositionValid(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        nodePositionValid: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetNodePositionValid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePositionValid", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, nodePositionValid))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTrackingTransformRelativePose(
        trackingTransformRelativePose: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Posef,
        >,
        trackingOrigin: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                            crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetTrackingTransformRelativePose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingTransformRelativePose", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (trackingTransformRelativePose, trackingOrigin))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_EncodeMrcFrame(
        rawBuffer: crate::System::IntPtr,
        audioDataPtr: crate::System::IntPtr,
        audioDataLen: i32,
        audioChannels: i32,
        timestamp: f64,
        outSyncId: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            i32,
                            i32,
                            f64,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        6usize,
                    >("ovrp_Media_EncodeMrcFrame")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_EncodeMrcFrame", 6usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        rawBuffer,
                        audioDataPtr,
                        audioDataLen,
                        audioChannels,
                        timestamp,
                        outSyncId,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_EncodeMrcFrameWithDualTextures(
        backgroundTextureHandle: crate::System::IntPtr,
        foregroundTextureHandle: crate::System::IntPtr,
        audioData: crate::System::IntPtr,
        audioDataLen: i32,
        audioChannels: i32,
        timestamp: f64,
        outSyncId: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            i32,
                            i32,
                            f64,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        7usize,
                    >("ovrp_Media_EncodeMrcFrameWithDualTextures")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_EncodeMrcFrameWithDualTextures", 7usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        backgroundTextureHandle,
                        foregroundTextureHandle,
                        audioData,
                        audioDataLen,
                        audioChannels,
                        timestamp,
                        outSyncId,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetInitialized(
        initialized: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_GetInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetInitialized", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (initialized))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetMrcActivationMode(
        activationMode: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_GetMrcActivationMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetMrcActivationMode", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (activationMode))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetMrcAudioSampleRate(
        sampleRate: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<i32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_GetMrcAudioSampleRate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetMrcAudioSampleRate", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (sampleRate))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetMrcFrameImageFlipped(
        flipped: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_GetMrcFrameImageFlipped")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetMrcFrameImageFlipped", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (flipped))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetMrcFrameSize(
        frameWidth: quest_hook::libil2cpp::ByRefMut<i32>,
        frameHeight: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<i32>,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_GetMrcFrameSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetMrcFrameSize", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (frameWidth, frameHeight))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetMrcInputVideoBufferType(
        inputVideoBufferType: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_GetMrcInputVideoBufferType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetMrcInputVideoBufferType", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (inputVideoBufferType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_Initialize() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_Media_Initialize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_Initialize", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_IsMrcActivated(
        mrcActivated: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_IsMrcActivated")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_IsMrcActivated", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (mrcActivated))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_IsMrcEnabled(
        mrcEnabled: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_IsMrcEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_IsMrcEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (mrcEnabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetMrcActivationMode(
        activationMode: crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::Media_OVRPlugin_MrcActivationMode),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_SetMrcActivationMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetMrcActivationMode", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (activationMode))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetMrcAudioSampleRate(
        sampleRate: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_SetMrcAudioSampleRate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetMrcAudioSampleRate", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (sampleRate))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetMrcFrameImageFlipped(
        flipped: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_SetMrcFrameImageFlipped")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetMrcFrameImageFlipped", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (flipped))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetMrcFrameSize(
        frameWidth: i32,
        frameHeight: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_SetMrcFrameSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetMrcFrameSize", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (frameWidth, frameHeight))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetMrcInputVideoBufferType(
        inputVideoBufferType: crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::Media_OVRPlugin_InputVideoBufferType),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_SetMrcInputVideoBufferType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetMrcInputVideoBufferType", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (inputVideoBufferType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_Shutdown() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_Media_Shutdown")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_Shutdown", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SyncMrcFrame(
        syncId: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_SyncMrcFrame")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SyncMrcFrame", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (syncId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_Update() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_Media_Update")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_Update", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_UseMrcDebugCamera(
        useMrcDebugCamera: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_UseMrcDebugCamera")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_UseMrcDebugCamera", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (useMrcDebugCamera))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetDeveloperMode(
        active: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetDeveloperMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetDeveloperMode", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (active))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_38_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_38_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_39_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_39_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_39_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_39_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_39_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_39_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_39_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_39_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_39_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_39_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_39_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_39_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_39_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_3_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_3_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_3_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_3_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_3_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_3_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_3_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_3_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_3_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_3_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_3_0 {
    pub fn ovrp_GetEyeOcclusionMeshEnabled() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetEyeOcclusionMeshEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeOcclusionMeshEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemHeadphonesPresent() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetSystemHeadphonesPresent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemHeadphonesPresent", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetEyeOcclusionMeshEnabled(
        value: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetEyeOcclusionMeshEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetEyeOcclusionMeshEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_3_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_3_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_40_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_40_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_40_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_40_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_40_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_40_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_40_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_40_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_40_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_40_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_40_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_40_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_40_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_41_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_41_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_41_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_41_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_41_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_41_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_41_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_41_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_41_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_41_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_41_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_41_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_41_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_42_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_42_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_42_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_42_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_42_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_42_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_42_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_42_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_42_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_42_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_42_0 {
    pub fn ovrp_GetAdaptiveGpuPerformanceScale2(
        adaptiveGpuPerformanceScale: quest_hook::libil2cpp::ByRefMut<f32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<f32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetAdaptiveGpuPerformanceScale2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAdaptiveGpuPerformanceScale2", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (adaptiveGpuPerformanceScale))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_42_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_42_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_43_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_43_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_43_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_43_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_43_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_43_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_43_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_43_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_43_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_43_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_43_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_43_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_43_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_44_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_44_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_44_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_44_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_44_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_44_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_44_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_44_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_44_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_44_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_44_0 {
    pub fn ovrp_GetHandState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        hand: crate::GlobalNamespace::OVRPlugin_Hand,
        handState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_HandStateInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            crate::GlobalNamespace::OVRPlugin_Hand,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_HandStateInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetHandState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetHandState", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, hand, handState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetHandTrackingEnabled(
        handTrackingEnabled: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetHandTrackingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetHandTrackingEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (handTrackingEnabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetLocalTrackingSpaceRecenterCount(
        recenterCount: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<i32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetLocalTrackingSpaceRecenterCount")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetLocalTrackingSpaceRecenterCount", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (recenterCount))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetMesh(
        meshType: crate::GlobalNamespace::OVRPlugin_MeshType,
        meshPtr: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_MeshType,
                            crate::System::IntPtr,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetMesh", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (meshType, meshPtr))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSkeleton(
        skeletonType: crate::GlobalNamespace::OVRPlugin_SkeletonType,
        skeleton: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Skeleton,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_SkeletonType,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Skeleton,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSkeleton")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSkeleton", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (skeletonType, skeleton))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetUseOverriddenExternalCameraFov(
        cameraId: i32,
        useOverriddenFov: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetUseOverriddenExternalCameraFov")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetUseOverriddenExternalCameraFov", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId, useOverriddenFov))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetUseOverriddenExternalCameraStaticPose(
        cameraId: i32,
        useOverriddenStaticPose: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetUseOverriddenExternalCameraStaticPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetUseOverriddenExternalCameraStaticPose", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId, useOverriddenStaticPose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_OverrideExternalCameraFov(
        cameraId: i32,
        useOverriddenFov: crate::GlobalNamespace::OVRPlugin_Bool,
        fov: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Fovf>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            crate::GlobalNamespace::OVRPlugin_Bool,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Fovf,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_OverrideExternalCameraFov")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_OverrideExternalCameraFov", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (cameraId, useOverriddenFov, fov))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_OverrideExternalCameraStaticPose(
        cameraId: i32,
        useOverriddenPose: crate::GlobalNamespace::OVRPlugin_Bool,
        poseInStageOrigin: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Posef,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            crate::GlobalNamespace::OVRPlugin_Bool,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_OverrideExternalCameraStaticPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_OverrideExternalCameraStaticPose", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (cameraId, useOverriddenPose, poseInStageOrigin))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_ResetDefaultExternalCamera() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_ResetDefaultExternalCamera")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_ResetDefaultExternalCamera", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetDefaultExternalCamera(
        cameraName: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        cameraIntrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
        >,
        cameraExtrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_SetDefaultExternalCamera")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetDefaultExternalCamera", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (cameraName, cameraIntrinsics, cameraExtrinsics))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_44_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_44_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_45_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_45_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_45_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_45_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_45_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_45_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_45_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_45_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_45_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_45_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_45_0 {
    pub fn ovrp_GetSystemHmd3DofModeEnabled(
        enabled: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetSystemHmd3DofModeEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemHmd3DofModeEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (enabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetAvailableQueueIndexVulkan(
        queueIndexVk: u32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_SetAvailableQueueIndexVulkan")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetAvailableQueueIndexVulkan", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (queueIndexVk))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_45_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_45_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_46_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_46_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_46_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_46_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_46_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_46_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_46_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_46_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_46_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_46_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_46_0 {
    pub fn ovrp_GetTiledMultiResDynamic(
        isDynamic: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetTiledMultiResDynamic")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTiledMultiResDynamic", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (isDynamic))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetTiledMultiResDynamic(
        isDynamic: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetTiledMultiResDynamic")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetTiledMultiResDynamic", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (isDynamic))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_46_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_46_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_47_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_47_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_47_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_47_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_47_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_47_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_47_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_47_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_47_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_47_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_47_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_47_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_47_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_48_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_48_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_48_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_48_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_48_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_48_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_48_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_48_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_48_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_48_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_48_0 {
    pub fn ovrp_SetExternalCameraProperties(
        cameraName: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        cameraIntrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
        >,
        cameraExtrinsics: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraIntrinsics,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraExtrinsics,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_SetExternalCameraProperties")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetExternalCameraProperties", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (cameraName, cameraIntrinsics, cameraExtrinsics))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_48_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_48_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_49_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_49_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_49_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_49_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_49_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_49_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_49_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_49_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_49_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_49_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_49_0 {
    pub const OVRP_ANCHOR_NAME_SIZE: i32 = 32i32;
    pub fn ovrp_GetHmdColorDesc(
        colorSpace: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_ColorSpace,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_ColorSpace,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetHmdColorDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetHmdColorDesc", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (colorSpace))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_CreateCustomCameraAnchor(
        anchorName: crate::System::IntPtr,
        anchorHandle: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_CreateCustomCameraAnchor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_CreateCustomCameraAnchor", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorName, anchorHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_DestroyCustomCameraAnchor(
        anchorHandle: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_DestroyCustomCameraAnchor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_DestroyCustomCameraAnchor", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_EncodeMrcFrameDualTexturesWithPoseTime(
        backgroundTextureHandle: crate::System::IntPtr,
        foregroundTextureHandle: crate::System::IntPtr,
        audioData: crate::System::IntPtr,
        audioDataLen: i32,
        audioChannels: i32,
        timestamp: f64,
        poseTime: f64,
        outSyncId: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            i32,
                            i32,
                            f64,
                            f64,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        8usize,
                    >("ovrp_Media_EncodeMrcFrameDualTexturesWithPoseTime")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_EncodeMrcFrameDualTexturesWithPoseTime", 8usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        backgroundTextureHandle,
                        foregroundTextureHandle,
                        audioData,
                        audioDataLen,
                        audioChannels,
                        timestamp,
                        poseTime,
                        outSyncId,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_EncodeMrcFrameWithPoseTime(
        rawBuffer: crate::System::IntPtr,
        audioDataPtr: crate::System::IntPtr,
        audioDataLen: i32,
        audioChannels: i32,
        timestamp: f64,
        poseTime: f64,
        outSyncId: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            i32,
                            i32,
                            f64,
                            f64,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        7usize,
                    >("ovrp_Media_EncodeMrcFrameWithPoseTime")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_EncodeMrcFrameWithPoseTime", 7usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        rawBuffer,
                        audioDataPtr,
                        audioDataLen,
                        audioChannels,
                        timestamp,
                        poseTime,
                        outSyncId,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_EnumerateCameraAnchorHandles(
        anchorCount: quest_hook::libil2cpp::ByRefMut<i32>,
        CameraAnchorHandle: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<i32>,
                            quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_EnumerateCameraAnchorHandles")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_EnumerateCameraAnchorHandles", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorCount, CameraAnchorHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetCameraAnchorHandle(
        anchorName: crate::System::IntPtr,
        anchorHandle: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_GetCameraAnchorHandle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetCameraAnchorHandle", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorName, anchorHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetCameraAnchorName(
        anchorHandle: crate::System::IntPtr,
        cameraName: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<char>>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppArray<char>,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_GetCameraAnchorName")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetCameraAnchorName", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorHandle, cameraName))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetCameraAnchorType(
        anchorHandle: crate::System::IntPtr,
        anchorType: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_CameraAnchorType,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_CameraAnchorType,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_GetCameraAnchorType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetCameraAnchorType", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorHandle, anchorType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetCameraMinMaxDistance(
        anchorHandle: crate::System::IntPtr,
        minDistance: quest_hook::libil2cpp::ByRefMut<f64>,
        maxDistance: quest_hook::libil2cpp::ByRefMut<f64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::ByRefMut<f64>,
                            quest_hook::libil2cpp::ByRefMut<f64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_Media_GetCameraMinMaxDistance")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetCameraMinMaxDistance", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (anchorHandle, minDistance, maxDistance))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetCurrentCameraAnchorHandle(
        anchorHandle: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_GetCurrentCameraAnchorHandle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetCurrentCameraAnchorHandle", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetCustomCameraAnchorPose(
        anchorHandle: crate::System::IntPtr,
        pose: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Posef>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_GetCustomCameraAnchorPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetCustomCameraAnchorPose", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorHandle, pose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetCameraMinMaxDistance(
        anchorHandle: crate::System::IntPtr,
        minDistance: f64,
        maxDistance: f64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, f64, f64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_Media_SetCameraMinMaxDistance")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetCameraMinMaxDistance", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (anchorHandle, minDistance, maxDistance))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetCustomCameraAnchorPose(
        anchorHandle: crate::System::IntPtr,
        pose: crate::GlobalNamespace::OVRPlugin_Posef,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, crate::GlobalNamespace::OVRPlugin_Posef),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_Media_SetCustomCameraAnchorPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetCustomCameraAnchorPose", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (anchorHandle, pose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetHeadsetControllerPose(
        headsetPose: crate::GlobalNamespace::OVRPlugin_Posef,
        leftControllerPose: crate::GlobalNamespace::OVRPlugin_Posef,
        rightControllerPose: crate::GlobalNamespace::OVRPlugin_Posef,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Posef,
                            crate::GlobalNamespace::OVRPlugin_Posef,
                            crate::GlobalNamespace::OVRPlugin_Posef,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_Media_SetHeadsetControllerPose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetHeadsetControllerPose", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (headsetPose, leftControllerPose, rightControllerPose),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetClientColorDesc(
        colorSpace: crate::GlobalNamespace::OVRPlugin_ColorSpace,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_ColorSpace),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetClientColorDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetClientColorDesc", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (colorSpace))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_49_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_49_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_50_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_50_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_50_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_50_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_50_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_50_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_50_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_50_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_50_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_50_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_50_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_50_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_50_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_51_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_51_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_51_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_51_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_51_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_51_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_51_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_51_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_51_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_51_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_51_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_51_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_51_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_52_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_52_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_52_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_52_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_52_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_52_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_52_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_52_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_52_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_52_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_52_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_52_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_52_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_53_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_53_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_53_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_53_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_53_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_53_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_53_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_53_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_53_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_53_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_53_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_53_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_53_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_54_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_54_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_54_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_54_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_54_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_54_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_54_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_54_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_54_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_54_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_54_0 {
    pub fn ovrp_Media_SetPlatformInitialized() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_Media_SetPlatformInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetPlatformInitialized", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_54_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_54_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_55_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_55_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_55_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_55_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_55_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_55_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_55_0 {
    pub fn ovrp_GetNativeOpenXRHandles(
        xrInstance: quest_hook::libil2cpp::ByRefMut<u64>,
        xrSession: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetNativeOpenXRHandles")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNativeOpenXRHandles", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (xrInstance, xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNativeXrApiType(
        xrApi: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_XrApi>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_XrApi,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetNativeXrApiType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNativeXrApiType", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (xrApi))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSkeleton2(
        skeletonType: crate::GlobalNamespace::OVRPlugin_SkeletonType,
        skeleton: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Skeleton2Internal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_SkeletonType,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Skeleton2Internal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSkeleton2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSkeleton2", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (skeletonType, skeleton))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_PollEvent(
        eventDataBuffer: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_EventDataBuffer,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_EventDataBuffer,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_PollEvent")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_PollEvent", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (eventDataBuffer))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_55_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_1")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_55_1 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_1")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_55_1 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_55_1";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_1")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_55_1 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_1")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_55_1 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_55_1")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_55_1 {
    pub fn ovrp_PollEvent2(
        eventType: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_EventType,
        >,
        eventData: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_EventType,
                            >,
                            quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_PollEvent2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_PollEvent2", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (eventType, eventData))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_55_1")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_55_1 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_56_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_56_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_56_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_56_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_56_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_56_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_56_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_56_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_56_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_56_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_56_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_56_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_56_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_57_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_57_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_57_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_57_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_57_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_57_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_57_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_57_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_57_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_57_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_57_0 {
    pub fn ovrp_GetEyeFovPremultipliedAlphaMode(
        enabled: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetEyeFovPremultipliedAlphaMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeFovPremultipliedAlphaMode", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (enabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_GetPlatformCameraMode(
        platformCameraMode: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_GetPlatformCameraMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_GetPlatformCameraMode", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (platformCameraMode))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_SetPlatformCameraMode(
        platformCameraMode: crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::Media_OVRPlugin_PlatformCameraMode),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_SetPlatformCameraMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_SetPlatformCameraMode", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (platformCameraMode))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetEyeFovPremultipliedAlphaMode(
        enabled: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetEyeFovPremultipliedAlphaMode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetEyeFovPremultipliedAlphaMode", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (enabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetKeyboardOverlayUV(
        uv: crate::GlobalNamespace::OVRPlugin_Vector2f,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Vector2f),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetKeyboardOverlayUV")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetKeyboardOverlayUV", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (uv))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_57_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_57_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_58_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_58_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_58_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_58_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_58_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_58_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_58_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_58_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_58_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_58_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_58_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_58_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_58_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_59_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_59_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_59_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_59_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_59_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_59_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_59_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_59_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_59_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_59_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_59_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_59_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_59_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_5_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_5_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_5_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_5_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_5_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_5_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_5_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_5_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_5_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_5_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_5_0 {
    pub fn ovrp_GetSystemRegion() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_SystemRegion,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_SystemRegion,
                        0usize,
                    >("ovrp_GetSystemRegion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemRegion", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_SystemRegion = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_5_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_5_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_60_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_60_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_60_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_60_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_60_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_60_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_60_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_60_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_60_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_60_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_60_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_60_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_60_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_61_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_61_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_61_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_61_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_61_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_61_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_61_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_61_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_61_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_61_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_61_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_61_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_61_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_62_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_62_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_62_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_62_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_62_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_62_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_62_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_62_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_62_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_62_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_62_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_62_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_62_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_63_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_63_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_63_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_63_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_63_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_63_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_63_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_63_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_63_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_63_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_63_0 {
    pub fn ovrp_AddInsightPassthroughSurfaceGeometry(
        layerId: i32,
        meshHandle: u64,
        T_world_model: crate::UnityEngine::Matrix4x4,
        geometryInstanceHandle: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            u64,
                            crate::UnityEngine::Matrix4x4,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_AddInsightPassthroughSurfaceGeometry")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_AddInsightPassthroughSurfaceGeometry", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (layerId, meshHandle, T_world_model, geometryInstanceHandle),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_CreateInsightTriangleMesh(
        layerId: i32,
        vertices: crate::System::IntPtr,
        vertexCount: i32,
        triangles: crate::System::IntPtr,
        triangleCount: i32,
        meshHandle: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            crate::System::IntPtr,
                            i32,
                            crate::System::IntPtr,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        6usize,
                    >("ovrp_CreateInsightTriangleMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_CreateInsightTriangleMesh", 6usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        layerId,
                        vertices,
                        vertexCount,
                        triangles,
                        triangleCount,
                        meshHandle,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_DestroyInsightPassthroughGeometryInstance(
        geometryInstanceHandle: u64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_DestroyInsightPassthroughGeometryInstance")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_DestroyInsightPassthroughGeometryInstance", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (geometryInstanceHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_DestroyInsightTriangleMesh(
        meshHandle: u64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_DestroyInsightTriangleMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_DestroyInsightTriangleMesh", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (meshHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetInsightPassthroughInitialized() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetInsightPassthroughInitialized")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetInsightPassthroughInitialized", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_InitializeInsightPassthrough() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_InitializeInsightPassthrough")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_InitializeInsightPassthrough", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetInsightPassthroughStyle(
        layerId: i32,
        style: crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SetInsightPassthroughStyle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetInsightPassthroughStyle", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, style))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_ShutdownInsightPassthrough() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_ShutdownInsightPassthrough")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_ShutdownInsightPassthrough", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UpdateInsightPassthroughGeometryTransform(
        geometryInstanceHandle: u64,
        T_world_model: crate::UnityEngine::Matrix4x4,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::UnityEngine::Matrix4x4),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_UpdateInsightPassthroughGeometryTransform")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UpdateInsightPassthroughGeometryTransform", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (geometryInstanceHandle, T_world_model))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_63_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_63_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_64_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_64_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_64_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_64_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_64_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_64_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_64_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_64_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_64_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_64_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_64_0 {
    pub fn ovrp_LocateSpace(
        location: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Posef,
        >,
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        trackingOrigin: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_LocateSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_LocateSpace", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (location, space, trackingOrigin))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_64_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_64_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_65_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_65_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_65_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_65_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_65_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_65_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_65_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_65_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_65_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_65_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_65_0 {
    pub fn ovrp_DestroySpace(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<u64>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_DestroySpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_DestroySpace", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_KtxDestroy(
        texture: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_KtxDestroy")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_KtxDestroy", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (texture))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_KtxGetTextureData(
        texture: crate::System::IntPtr,
        data: crate::System::IntPtr,
        bufferSize: u32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, crate::System::IntPtr, u32),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_KtxGetTextureData")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_KtxGetTextureData", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (texture, data, bufferSize))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_KtxLoadFromMemory(
        data: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
        length: u32,
        texture: quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
                            u32,
                            quest_hook::libil2cpp::ByRefMut<crate::System::IntPtr>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_KtxLoadFromMemory")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_KtxLoadFromMemory", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (data, length, texture))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_KtxTextureHeight(
        texture: crate::System::IntPtr,
        height: quest_hook::libil2cpp::ByRefMut<u32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, quest_hook::libil2cpp::ByRefMut<u32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_KtxTextureHeight")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_KtxTextureHeight", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (texture, height))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_KtxTextureSize(
        texture: crate::System::IntPtr,
        _cordl_size: quest_hook::libil2cpp::ByRefMut<u32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, quest_hook::libil2cpp::ByRefMut<u32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_KtxTextureSize")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_KtxTextureSize", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (texture, _cordl_size))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_KtxTextureWidth(
        texture: crate::System::IntPtr,
        width: quest_hook::libil2cpp::ByRefMut<u32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, quest_hook::libil2cpp::ByRefMut<u32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_KtxTextureWidth")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_KtxTextureWidth", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (texture, width))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_KtxTranscode(
        texture: crate::System::IntPtr,
        format: u32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr, u32),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_KtxTranscode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_KtxTranscode", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (texture, format))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_65_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_65_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_66_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_66_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_66_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_66_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_66_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_66_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_66_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_66_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_66_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_66_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_66_0 {
    pub fn ovrp_GetInsightPassthroughInitializationState() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_GetInsightPassthroughInitializationState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetInsightPassthroughInitializationState", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Media_IsCastingToRemoteClient(
        isCasting: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_Media_IsCastingToRemoteClient")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Media_IsCastingToRemoteClient", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (isCasting))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_66_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_66_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_67_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_67_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_67_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_67_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_67_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_67_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_67_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_67_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_67_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_67_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_67_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_67_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_67_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_68_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_68_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_68_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_68_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_68_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_68_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_68_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_68_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_68_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_68_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_68_0 {
    pub const OVRP_RENDER_MODEL_MAX_NAME_LENGTH: i32 = 64i32;
    pub const OVRP_RENDER_MODEL_MAX_PATH_LENGTH: i32 = 256i32;
    pub fn ovrp_GetKeyboardState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        frameIndex: i32,
        keyboardState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_KeyboardState,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_KeyboardState,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetKeyboardState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetKeyboardState", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, frameIndex, keyboardState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetRenderModelPaths(
        index: u32,
        path: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, crate::System::IntPtr),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetRenderModelPaths")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetRenderModelPaths", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (index, path))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetRenderModelProperties(
        path: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        properties: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetRenderModelProperties")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetRenderModelProperties", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (path, properties))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemKeyboardDescription(
        keyboardQueryFlags: crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags,
        keyboardDescription: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_KeyboardDescription,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_KeyboardDescription,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSystemKeyboardDescription")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemKeyboardDescription", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (keyboardQueryFlags, keyboardDescription))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_LoadRenderModel(
        modelKey: u64,
        bufferInputCapacity: u32,
        bufferCountOutput: quest_hook::libil2cpp::ByRefMut<u32>,
        buffer: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            u32,
                            quest_hook::libil2cpp::ByRefMut<u32>,
                            crate::System::IntPtr,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_LoadRenderModel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_LoadRenderModel", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (modelKey, bufferInputCapacity, bufferCountOutput, buffer),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetInsightPassthroughKeyboardHandsIntensity(
        layerId: i32,
        intensity: crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            crate::GlobalNamespace::OVRPlugin_InsightPassthroughKeyboardHandsIntensity,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SetInsightPassthroughKeyboardHandsIntensity")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetInsightPassthroughKeyboardHandsIntensity", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, intensity))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_StartKeyboardTracking(
        trackedKeyboardId: u64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_StartKeyboardTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_StartKeyboardTracking", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (trackedKeyboardId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_StopKeyboardTracking() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_StopKeyboardTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_StopKeyboardTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_68_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_68_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_69_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_69_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_69_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_69_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_69_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_69_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_69_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_69_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_69_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_69_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_69_0 {
    pub fn ovrp_GetNodePoseStateImmediate(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        nodePoseState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PoseStatef,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_PoseStatef,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetNodePoseStateImmediate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePoseStateImmediate", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, nodePoseState))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_69_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_69_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_6_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_6_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_6_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_6_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_6_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_6_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_6_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_6_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_6_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_6_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_6_0 {
    pub fn ovrp_GetAppCpuStartToGpuEndTime() -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        f32,
                        0usize,
                    >("ovrp_GetAppCpuStartToGpuEndTime")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppCpuStartToGpuEndTime", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetControllerHapticsDesc(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_HapticsDesc> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_HapticsDesc,
                        1usize,
                    >("ovrp_GetControllerHapticsDesc")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerHapticsDesc", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_HapticsDesc = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetControllerHapticsState(
        controllerMask: u32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_HapticsState> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::GlobalNamespace::OVRPlugin_HapticsState,
                        1usize,
                    >("ovrp_GetControllerHapticsState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerHapticsState", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_HapticsState = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetEyeRecommendedResolutionScale() -> quest_hook::libil2cpp::Result<
        f32,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        f32,
                        0usize,
                    >("ovrp_GetEyeRecommendedResolutionScale")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeRecommendedResolutionScale", 0usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemRecommendedMSAALevel() -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        i32,
                        0usize,
                    >("ovrp_GetSystemRecommendedMSAALevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemRecommendedMSAALevel", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetTrackingIPDEnabled() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetTrackingIPDEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetTrackingIPDEnabled", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetControllerHaptics(
        controllerMask: u32,
        hapticsBuffer: crate::GlobalNamespace::OVRPlugin_HapticsBuffer,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, crate::GlobalNamespace::OVRPlugin_HapticsBuffer),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        2usize,
                    >("ovrp_SetControllerHaptics")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetControllerHaptics", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, hapticsBuffer))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetOverlayQuad3(
        flags: u32,
        textureLeft: crate::System::IntPtr,
        textureRight: crate::System::IntPtr,
        device: crate::System::IntPtr,
        pose: crate::GlobalNamespace::OVRPlugin_Posef,
        scale: crate::GlobalNamespace::OVRPlugin_Vector3f,
        layerIndex: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u32,
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            crate::System::IntPtr,
                            crate::GlobalNamespace::OVRPlugin_Posef,
                            crate::GlobalNamespace::OVRPlugin_Vector3f,
                            i32,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        7usize,
                    >("ovrp_SetOverlayQuad3")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetOverlayQuad3", 7usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (flags, textureLeft, textureRight, device, pose, scale, layerIndex),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetTrackingIPDEnabled(
        value: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetTrackingIPDEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetTrackingIPDEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_6_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_6_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_70_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_70_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_70_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_70_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_70_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_70_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_70_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_70_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_70_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_70_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_70_0 {
    pub fn ovrp_SetLogCallback2(
        logCallback: quest_hook::libil2cpp::Gc<
            crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<
                            crate::GlobalNamespace::OVRPlugin_LogCallback2DelegateType,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetLogCallback2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetLogCallback2", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (logCallback))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_70_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_70_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_71_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_71_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_71_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_71_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_71_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_71_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_71_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_71_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_71_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_71_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_71_0 {
    pub fn ovrp_GetSuggestedCpuPerformanceLevel(
        perfLevel: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetSuggestedCpuPerformanceLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSuggestedCpuPerformanceLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (perfLevel))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSuggestedGpuPerformanceLevel(
        perfLevel: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetSuggestedGpuPerformanceLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSuggestedGpuPerformanceLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (perfLevel))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_IsInsightPassthroughSupported(
        supported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_IsInsightPassthroughSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_IsInsightPassthroughSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (supported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetSuggestedCpuPerformanceLevel(
        perfLevel: crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetSuggestedCpuPerformanceLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetSuggestedCpuPerformanceLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (perfLevel))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetSuggestedGpuPerformanceLevel(
        perfLevel: crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetSuggestedGpuPerformanceLevel")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetSuggestedGpuPerformanceLevel", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (perfLevel))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_HookGetInstanceProcAddr(
        func: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::System::IntPtr> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        crate::System::IntPtr,
                        1usize,
                    >("ovrp_UnityOpenXR_HookGetInstanceProcAddr")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_HookGetInstanceProcAddr", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), (func))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnAppSpaceChange(
        xrSpace: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("ovrp_UnityOpenXR_OnAppSpaceChange")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnAppSpaceChange", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSpace))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnInstanceCreate(
        xrInstance: u64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_UnityOpenXR_OnInstanceCreate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnInstanceCreate", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (xrInstance))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnInstanceDestroy(
        xrInstance: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("ovrp_UnityOpenXR_OnInstanceDestroy")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnInstanceDestroy", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrInstance))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnSessionBegin(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("ovrp_UnityOpenXR_OnSessionBegin")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnSessionBegin", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnSessionCreate(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("ovrp_UnityOpenXR_OnSessionCreate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnSessionCreate", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnSessionDestroy(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("ovrp_UnityOpenXR_OnSessionDestroy")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnSessionDestroy", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnSessionEnd(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("ovrp_UnityOpenXR_OnSessionEnd")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnSessionEnd", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnSessionExiting(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("ovrp_UnityOpenXR_OnSessionExiting")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnSessionExiting", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_OnSessionStateChange(
        oldState: i32,
        newState: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("ovrp_UnityOpenXR_OnSessionStateChange")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_OnSessionStateChange", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (oldState, newState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UnityOpenXR_SetClientVersion(
        majorVersion: i32,
        minorVersion: i32,
        patchVersion: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, i32),
                        quest_hook::libil2cpp::Void,
                        3usize,
                    >("ovrp_UnityOpenXR_SetClientVersion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UnityOpenXR_SetClientVersion", 3usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info
                .invoke_unchecked((), (majorVersion, minorVersion, patchVersion))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_71_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_71_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_72_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_72_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_72_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_72_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_72_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_72_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_72_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_72_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_72_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_72_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_72_0 {
    pub fn ovrp_CreateSpatialAnchor(
        createInfo: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo,
        >,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo,
                            >,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_CreateSpatialAnchor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_CreateSpatialAnchor", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (createInfo, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_EnumerateSpaceSupportedComponents(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        componentTypesCapacityInput: u32,
        componentTypesCountOutput: quest_hook::libil2cpp::ByRefMut<u32>,
        componentTypes: quest_hook::libil2cpp::ByRefMut<
            quest_hook::libil2cpp::Gc<
                quest_hook::libil2cpp::Il2CppArray<
                    crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
                >,
            >,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            u32,
                            quest_hook::libil2cpp::ByRefMut<u32>,
                            quest_hook::libil2cpp::ByRefMut<
                                quest_hook::libil2cpp::Gc<
                                    quest_hook::libil2cpp::Il2CppArray<
                                        crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
                                    >,
                                >,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_EnumerateSpaceSupportedComponents")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_EnumerateSpaceSupportedComponents", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (
                        space,
                        componentTypesCapacityInput,
                        componentTypesCountOutput,
                        componentTypes,
                    ),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_EraseSpace(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        location: crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_EraseSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_EraseSpace", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, location, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceBoundary2D(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        boundaryInternal: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceBoundary2D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceBoundary2D", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, boundaryInternal))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceBoundingBox2D(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        rect: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Rectf>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Rectf,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceBoundingBox2D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceBoundingBox2D", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, rect))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceBoundingBox3D(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        bounds: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Boundsf,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Boundsf,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceBoundingBox3D")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceBoundingBox3D", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, bounds))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceComponentStatus(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        componentType: crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
        enabled: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
        changePending: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_GetSpaceComponentStatus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceComponentStatus", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (space, componentType, enabled, changePending))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceContainer(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        containerInternal: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceContainer")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceContainer", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, containerInternal))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceRoomLayout(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        roomLayoutInternal: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceRoomLayout")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceRoomLayout", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, roomLayoutInternal))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceSemanticLabels(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        labelsInternal: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceSemanticLabels")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceSemanticLabels", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, labelsInternal))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_QuerySpaces(
        queryInfo: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo,
        >,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo,
                            >,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_QuerySpaces")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_QuerySpaces", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (queryInfo, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_RequestSceneCapture(
        request: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal,
        >,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal,
                            >,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_RequestSceneCapture")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_RequestSceneCapture", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (request, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_RetrieveSpaceQueryResults(
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
        resultCapacityInput: u32,
        resultCountOutput: quest_hook::libil2cpp::ByRefMut<u32>,
        results: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            u32,
                            quest_hook::libil2cpp::ByRefMut<u32>,
                            crate::System::IntPtr,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_RetrieveSpaceQueryResults")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_RetrieveSpaceQueryResults", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (requestId, resultCapacityInput, resultCountOutput, results),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SaveSpace(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        location: crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
        mode: crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
                            crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_SaveSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SaveSpace", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, location, mode, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetSpaceComponentStatus(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        componentType: crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
        enable: crate::GlobalNamespace::OVRPlugin_Bool,
        timeout: f64,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
                            crate::GlobalNamespace::OVRPlugin_Bool,
                            f64,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        5usize,
                    >("ovrp_SetSpaceComponentStatus")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetSpaceComponentStatus", 5usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (space, componentType, enable, timeout, requestId),
                )?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_72_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_72_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_73_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_73_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_73_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_73_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_73_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_73_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_73_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_73_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_73_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_73_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_73_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_73_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_73_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_74_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_74_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_74_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_74_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_74_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_74_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_74_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_74_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_74_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_74_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_74_0 {
    pub fn ovrp_ChangeVirtualKeyboardTextContext(
        textContext: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_ChangeVirtualKeyboardTextContext")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_ChangeVirtualKeyboardTextContext", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (textContext))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_CreateVirtualKeyboard(
        createInfo: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_CreateVirtualKeyboard")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_CreateVirtualKeyboard", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (createInfo))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_CreateVirtualKeyboardSpace(
        createInfo: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo,
        keyboardSpace: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_CreateVirtualKeyboardSpace")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_CreateVirtualKeyboardSpace", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (createInfo, keyboardSpace))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_DestroyVirtualKeyboard() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_DestroyVirtualKeyboard")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_DestroyVirtualKeyboard", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetRenderModelProperties2(
        path: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        flags: crate::GlobalNamespace::OVRPlugin_RenderModelFlags,
        properties: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            crate::GlobalNamespace::OVRPlugin_RenderModelFlags,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetRenderModelProperties2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetRenderModelProperties2", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (path, flags, properties))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceUuid(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        uuid: quest_hook::libil2cpp::ByRefMut<crate::System::Guid>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<crate::System::Guid>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceUuid")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceUuid", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, uuid))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetVirtualKeyboardScale(
        location: quest_hook::libil2cpp::ByRefMut<f32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<f32>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetVirtualKeyboardScale")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetVirtualKeyboardScale", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (location))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SendVirtualKeyboardInput(
        inputInfo: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo,
        interactorRootPose: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Posef,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Posef,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SendVirtualKeyboardInput")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SendVirtualKeyboardInput", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (inputInfo, interactorRootPose))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SuggestVirtualKeyboardLocation(
        locationInfo: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SuggestVirtualKeyboardLocation")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SuggestVirtualKeyboardLocation", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (locationInfo))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_74_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_74_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_75_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_75_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_75_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_75_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_75_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_75_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_75_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_75_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_75_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_75_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_75_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_75_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_75_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_76_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_76_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_76_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_76_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_76_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_76_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_76_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_76_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_76_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_76_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_76_0 {
    pub fn ovrp_GetNodePoseStateAtTime(
        _cordl_time: f64,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        nodePoseState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PoseStatef,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            f64,
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_PoseStatef,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetNodePoseStateAtTime")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePoseStateAtTime", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (_cordl_time, nodeId, nodePoseState))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_76_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_76_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_78_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_78_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_78_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_78_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_78_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_78_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_78_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_78_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_78_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_78_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_78_0 {
    pub fn ovrp_GetBodyState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        frameIndex: i32,
        bodyState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_BodyStateInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_BodyStateInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetBodyState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetBodyState", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, frameIndex, bodyState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetBodyTrackingEnabled(
        value: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetBodyTrackingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetBodyTrackingEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetBodyTrackingSupported(
        value: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetBodyTrackingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetBodyTrackingSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetControllerSampleRateHz(
        controller: crate::GlobalNamespace::OVRPlugin_Controller,
        sampleRateHz: quest_hook::libil2cpp::ByRefMut<f32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Controller,
                            quest_hook::libil2cpp::ByRefMut<f32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetControllerSampleRateHz")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerSampleRateHz", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (controller, sampleRateHz))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetControllerState5(
        controllerMask: u32,
        controllerState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_ControllerState5,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_ControllerState5,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetControllerState5")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerState5", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, controllerState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetCurrentInteractionProfile(
        hand: crate::GlobalNamespace::OVRPlugin_Hand,
        interactionProfile: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_InteractionProfile,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Hand,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_InteractionProfile,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetCurrentInteractionProfile")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetCurrentInteractionProfile", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (hand, interactionProfile))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetEyeGazesState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        frameIndex: i32,
        eyeGazesState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_EyeGazesStateInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetEyeGazesState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeGazesState", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, frameIndex, eyeGazesState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetEyeTrackingEnabled(
        eyeTrackingEnabled: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetEyeTrackingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeTrackingEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (eyeTrackingEnabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetEyeTrackingSupported(
        eyeTrackingSupported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetEyeTrackingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeTrackingSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (eyeTrackingSupported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetFaceState(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        frameIndex: i32,
        faceState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_FaceStateInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_FaceStateInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetFaceState")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetFaceState", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, frameIndex, faceState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetFaceTrackingEnabled(
        faceTrackingEnabled: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetFaceTrackingEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetFaceTrackingEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (faceTrackingEnabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetFaceTrackingSupported(
        faceTrackingSupported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetFaceTrackingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetFaceTrackingSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (faceTrackingSupported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetFoveationEyeTracked(
        isEyeTrackedFoveation: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetFoveationEyeTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetFoveationEyeTracked", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (isEyeTrackedFoveation))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetFoveationEyeTrackedSupported(
        foveationSupported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetFoveationEyeTrackedSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetFoveationEyeTrackedSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (foveationSupported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetLocalDimming(
        localDimmingMode: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetLocalDimming")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetLocalDimming", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (localDimmingMode))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetLocalDimmingSupported(
        localDimmingSupported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetLocalDimmingSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetLocalDimmingSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (localDimmingSupported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetPassthroughCapabilityFlags(
        capabilityFlags: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetPassthroughCapabilityFlags")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetPassthroughCapabilityFlags", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (capabilityFlags))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetControllerHapticsAmplitudeEnvelope(
        controllerMask: crate::GlobalNamespace::OVRPlugin_Controller,
        hapticsVibration: crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Controller,
                            crate::GlobalNamespace::OVRPlugin_HapticsAmplitudeEnvelopeVibration,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SetControllerHapticsAmplitudeEnvelope")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetControllerHapticsAmplitudeEnvelope", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, hapticsVibration))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetControllerHapticsPcm(
        controllerMask: crate::GlobalNamespace::OVRPlugin_Controller,
        hapticsVibration: crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Controller,
                            crate::GlobalNamespace::OVRPlugin_HapticsPcmVibration,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SetControllerHapticsPcm")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetControllerHapticsPcm", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, hapticsVibration))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetControllerLocalizedVibration(
        controllerMask: crate::GlobalNamespace::OVRPlugin_Controller,
        hapticsLocationMask: crate::GlobalNamespace::OVRPlugin_HapticsLocation,
        frequency: f32,
        amplitude: f32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Controller,
                            crate::GlobalNamespace::OVRPlugin_HapticsLocation,
                            f32,
                            f32,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_SetControllerLocalizedVibration")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetControllerLocalizedVibration", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (controllerMask, hapticsLocationMask, frequency, amplitude),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetFoveationEyeTracked(
        isEyeTrackedFoveation: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetFoveationEyeTracked")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetFoveationEyeTracked", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (isEyeTrackedFoveation))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetLocalDimming(
        localDimmingMode: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetLocalDimming")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetLocalDimming", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (localDimmingMode))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_StartBodyTracking() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_StartBodyTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_StartBodyTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_StartEyeTracking() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_StartEyeTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_StartEyeTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_StartFaceTracking() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_StartFaceTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_StartFaceTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_StopBodyTracking() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_StopBodyTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_StopBodyTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_StopEyeTracking() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_StopEyeTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_StopEyeTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_StopFaceTracking() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_StopFaceTracking")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_StopFaceTracking", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_78_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_78_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_79_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_79_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_79_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_79_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_79_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_79_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_79_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_79_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_79_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_79_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_79_0 {
    pub fn ovrp_CreateSpaceUser(
        spaceUserId: quest_hook::libil2cpp::ByRefMut<u64>,
        spaceUserHandle: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_CreateSpaceUser")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_CreateSpaceUser", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (spaceUserId, spaceUserHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_DeclareUser(
        userId: quest_hook::libil2cpp::ByRefMut<u64>,
        userHandle: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_DeclareUser")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_DeclareUser", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (userId, userHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_DestroySpaceUser(
        userHandle: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<u64>),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_DestroySpaceUser")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_DestroySpaceUser", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (userHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSpaceUserId(
        spaceUserHandle: quest_hook::libil2cpp::ByRefMut<u64>,
        spaceUserId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceUserId")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceUserId", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (spaceUserHandle, spaceUserId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_LocateSpace2(
        location: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_SpaceLocationf,
        >,
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        trackingOrigin: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_SpaceLocationf,
                            >,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_LocateSpace2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_LocateSpace2", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (location, space, trackingOrigin))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_QplCreateMarkerHandle(
        name: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        nameHandle: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_QplCreateMarkerHandle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_QplCreateMarkerHandle", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (name, nameHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_QplDestroyMarkerHandle(
        nameHandle: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_QplDestroyMarkerHandle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_QplDestroyMarkerHandle", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (nameHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_QplMarkerAnnotation(
        markerId: i32,
        annotationKey: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        annotationValue: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        instanceKey: i32,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            i32,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_QplMarkerAnnotation")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_QplMarkerAnnotation", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (markerId, annotationKey, annotationValue, instanceKey),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_QplMarkerEnd(
        markerId: i32,
        resultTypeId: crate::GlobalNamespace::Qpl_OVRPlugin_ResultType,
        instanceKey: i32,
        timestampMs: i64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            crate::GlobalNamespace::Qpl_OVRPlugin_ResultType,
                            i32,
                            i64,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_QplMarkerEnd")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_QplMarkerEnd", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (markerId, resultTypeId, instanceKey, timestampMs),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_QplMarkerPointCached(
        markerId: i32,
        nameHandle: i32,
        instanceKey: i32,
        timestampMs: i64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, i32, i64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_QplMarkerPointCached")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_QplMarkerPointCached", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (markerId, nameHandle, instanceKey, timestampMs))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_QplMarkerStart(
        markerId: i32,
        instanceKey: i32,
        timestampMs: i64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, i64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_QplMarkerStart")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_QplMarkerStart", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (markerId, instanceKey, timestampMs))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SaveSpaceList(
        spaces: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        numSpaces: u32,
        location: crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            u32,
                            crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_SaveSpaceList")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SaveSpaceList", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (spaces, numSpaces, location, requestId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_ShareSpaces(
        spaces: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        numSpaces: u32,
        userHandles: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        numUsers: u32,
        requestId: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            u32,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            u32,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        5usize,
                    >("ovrp_ShareSpaces")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_ShareSpaces", 5usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (spaces, numSpaces, userHandles, numUsers, requestId),
                )?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_79_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_79_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_7_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_7_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_7_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_7_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_7_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_7_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_7_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_7_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_7_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_7_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_7_0 {
    pub fn ovrp_GetAppChromaticCorrection() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetAppChromaticCorrection")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppChromaticCorrection", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetAppChromaticCorrection(
        value: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetAppChromaticCorrection")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetAppChromaticCorrection", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_7_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_7_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_81_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_81_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_81_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_81_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_81_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_81_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_81_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_81_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_81_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_81_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_81_0 {}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_81_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_81_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_82_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_82_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_82_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_82_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_82_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_82_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_82_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_82_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_82_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_82_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_82_0 {
    pub fn ovrp_GetSpaceTriangleMesh(
        space: quest_hook::libil2cpp::ByRefMut<u64>,
        triangleMeshInternal: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::ByRefMut<u64>,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetSpaceTriangleMesh")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSpaceTriangleMesh", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (space, triangleMeshInternal))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_82_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_82_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_83_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_83_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_83_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_83_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_83_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_83_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_83_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_83_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_83_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_83_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_83_0 {
    pub fn ovrp_GetControllerState6(
        controllerMask: u32,
        controllerState: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_ControllerState6,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_ControllerState6,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetControllerState6")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerState6", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerMask, controllerState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetVirtualKeyboardDirtyTextures(
        textureIds: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetVirtualKeyboardDirtyTextures")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetVirtualKeyboardDirtyTextures", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (textureIds))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetVirtualKeyboardModelAnimationStates(
        animationStates: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetVirtualKeyboardModelAnimationStates")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetVirtualKeyboardModelAnimationStates", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (animationStates))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetVirtualKeyboardTextureData(
        textureId: u64,
        textureData: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            u64,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetVirtualKeyboardTextureData")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetVirtualKeyboardTextureData", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (textureId, textureData))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetVirtualKeyboardModelVisibility(
        visibility: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetVirtualKeyboardModelVisibility")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetVirtualKeyboardModelVisibility", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (visibility))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_83_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_83_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_84_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_84_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_84_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_84_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_84_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_84_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_84_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_84_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_84_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_84_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_84_0 {
    pub fn ovrp_CreatePassthroughColorLut(
        channels: crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels,
        resolution: u32,
        data: crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData,
        colorLut: quest_hook::libil2cpp::ByRefMut<u64>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels,
                            u32,
                            crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData,
                            quest_hook::libil2cpp::ByRefMut<u64>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        4usize,
                    >("ovrp_CreatePassthroughColorLut")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_CreatePassthroughColorLut", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (channels, resolution, data, colorLut))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_DestroyPassthroughColorLut(
        colorLut: u64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_DestroyPassthroughColorLut")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_DestroyPassthroughColorLut", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (colorLut))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetEyeLayerRecommendedResolution(
        recommendedDimensions: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Sizei,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Sizei,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetEyeLayerRecommendedResolution")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetEyeLayerRecommendedResolution", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (recommendedDimensions))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetLayerRecommendedResolution(
        layerId: i32,
        recommendedDimensions: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Sizei,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Sizei,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetLayerRecommendedResolution")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetLayerRecommendedResolution", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, recommendedDimensions))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetInsightPassthroughStyle2(
        layerId: i32,
        style: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_InsightPassthroughStyle2,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_SetInsightPassthroughStyle2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetInsightPassthroughStyle2", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (layerId, style))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_UpdatePassthroughColorLut(
        colorLut: u64,
        data: crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_UpdatePassthroughColorLut")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_UpdatePassthroughColorLut", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (colorLut, data))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_84_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_84_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_85_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_85_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_85_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_85_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_85_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_85_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_85_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_85_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_85_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_85_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_85_0 {
    pub fn ovrp_GetPassthroughCapabilities(
        capabilityFlags: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetPassthroughCapabilities")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetPassthroughCapabilities", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (capabilityFlags))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_OnEditorShutdown() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Result,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        0usize,
                    >("ovrp_OnEditorShutdown")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_OnEditorShutdown", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_85_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_85_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_86_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_86_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_86_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_86_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_86_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_86_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_86_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_86_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_86_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_86_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_86_0 {
    pub fn ovrp_AreHandPosesGeneratedByControllerData(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        isGeneratedByControllerData: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_AreHandPosesGeneratedByControllerData")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_AreHandPosesGeneratedByControllerData", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (stepId, nodeId, isGeneratedByControllerData))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetControllerIsInHand(
        stepId: crate::GlobalNamespace::OVRPlugin_Step,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        isInHand: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Step,
                            crate::GlobalNamespace::OVRPlugin_Node,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_Bool,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        3usize,
                    >("ovrp_GetControllerIsInHand")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetControllerIsInHand", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (stepId, nodeId, isInHand))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetCurrentDetachedInteractionProfile(
        hand: crate::GlobalNamespace::OVRPlugin_Hand,
        interactionProfile: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_InteractionProfile,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Hand,
                            quest_hook::libil2cpp::ByRefMut<
                                crate::GlobalNamespace::OVRPlugin_InteractionProfile,
                            >,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        2usize,
                    >("ovrp_GetCurrentDetachedInteractionProfile")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetCurrentDetachedInteractionProfile", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (hand, interactionProfile))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_IsControllerDrivenHandPosesEnabled(
        enabled: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_IsControllerDrivenHandPosesEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_IsControllerDrivenHandPosesEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (enabled))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_IsMultimodalHandsControllersSupported(
        supported: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_Bool,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_IsMultimodalHandsControllersSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_IsMultimodalHandsControllersSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (supported))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetControllerDrivenHandPoses(
        controllerDrivenHandPoses: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetControllerDrivenHandPoses")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetControllerDrivenHandPoses", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (controllerDrivenHandPoses))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetMultimodalHandsControllersSupported(
        supported: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetMultimodalHandsControllersSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetMultimodalHandsControllersSupported", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (supported))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_86_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_86_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_87_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_87_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_87_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_87_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_87_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_87_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_87_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_87_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_87_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_87_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_87_0 {
    pub fn ovrp_AreControllerDrivenHandPosesNatural(
        natural: quest_hook::libil2cpp::ByRefMut<crate::GlobalNamespace::OVRPlugin_Bool>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_Bool,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_AreControllerDrivenHandPosesNatural")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_AreControllerDrivenHandPosesNatural", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (natural))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetPassthroughPreferences(
        preferences: quest_hook::libil2cpp::ByRefMut<
            crate::GlobalNamespace::OVRPlugin_PassthroughPreferences,
        >,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::ByRefMut<
                            crate::GlobalNamespace::OVRPlugin_PassthroughPreferences,
                        >),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_GetPassthroughPreferences")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetPassthroughPreferences", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (preferences))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetControllerDrivenHandPosesAreNatural(
        controllerDrivenHandPosesAreNatural: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetControllerDrivenHandPosesAreNatural")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetControllerDrivenHandPosesAreNatural", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info
                .invoke_unchecked((), (controllerDrivenHandPosesAreNatural))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetEyeBufferSharpenType(
        sharpenType: crate::GlobalNamespace::OVRPlugin_LayerSharpenType,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_LayerSharpenType),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetEyeBufferSharpenType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetEyeBufferSharpenType", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (sharpenType))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_87_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_87_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_88_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_88_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_88_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_88_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_88_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_88_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_88_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_88_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_88_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_88_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_88_0 {
    pub fn ovrp_SetSimultaneousHandsAndControllersEnabled(
        enabled: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Result> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Result,
                        1usize,
                    >("ovrp_SetSimultaneousHandsAndControllersEnabled")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetSimultaneousHandsAndControllersEnabled", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Result = unsafe {
            cordl_method_info.invoke_unchecked((), (enabled))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_88_0")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_OVRP_1_88_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_8_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_8_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_8_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_8_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_8_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_8_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_8_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_8_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_8_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_8_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_8_0 {
    pub fn ovrp_GetBoundaryConfigured() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetBoundaryConfigured")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetBoundaryConfigured", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetBoundaryDimensions(
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Vector3f> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_BoundaryType),
                        crate::GlobalNamespace::OVRPlugin_Vector3f,
                        1usize,
                    >("ovrp_GetBoundaryDimensions")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetBoundaryDimensions", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Vector3f = unsafe {
            cordl_method_info.invoke_unchecked((), (boundaryType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetBoundaryGeometry(
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_BoundaryGeometry,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_BoundaryType),
                        crate::GlobalNamespace::OVRPlugin_BoundaryGeometry,
                        1usize,
                    >("ovrp_GetBoundaryGeometry")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetBoundaryGeometry", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_BoundaryGeometry = unsafe {
            cordl_method_info.invoke_unchecked((), (boundaryType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetBoundaryVisible() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_GetBoundaryVisible")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetBoundaryVisible", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodeAcceleration2(
        stateId: i32,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        2usize,
                    >("ovrp_GetNodeAcceleration2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodeAcceleration2", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (stateId, nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodePose2(
        stateId: i32,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        2usize,
                    >("ovrp_GetNodePose2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodePose2", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (stateId, nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetNodeVelocity2(
        stateId: i32,
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Posef> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::GlobalNamespace::OVRPlugin_Node),
                        crate::GlobalNamespace::OVRPlugin_Posef,
                        2usize,
                    >("ovrp_GetNodeVelocity2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetNodeVelocity2", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Posef = unsafe {
            cordl_method_info.invoke_unchecked((), (stateId, nodeId))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_SetBoundaryVisible(
        value: crate::GlobalNamespace::OVRPlugin_Bool,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_Bool),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        1usize,
                    >("ovrp_SetBoundaryVisible")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_SetBoundaryVisible", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_TestBoundaryNode(
        nodeId: crate::GlobalNamespace::OVRPlugin_Node,
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_BoundaryTestResult,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Node,
                            crate::GlobalNamespace::OVRPlugin_BoundaryType,
                        ),
                        crate::GlobalNamespace::OVRPlugin_BoundaryTestResult,
                        2usize,
                    >("ovrp_TestBoundaryNode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_TestBoundaryNode", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_BoundaryTestResult = unsafe {
            cordl_method_info.invoke_unchecked((), (nodeId, boundaryType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_TestBoundaryPoint(
        point: crate::GlobalNamespace::OVRPlugin_Vector3f,
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
    ) -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_BoundaryTestResult,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_Vector3f,
                            crate::GlobalNamespace::OVRPlugin_BoundaryType,
                        ),
                        crate::GlobalNamespace::OVRPlugin_BoundaryTestResult,
                        2usize,
                    >("ovrp_TestBoundaryPoint")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_TestBoundaryPoint", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_BoundaryTestResult = unsafe {
            cordl_method_info.invoke_unchecked((), (point, boundaryType))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_Update2(
        stateId: i32,
        frameIndex: i32,
        predictionSeconds: f64,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, f64),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        3usize,
                    >("ovrp_Update2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_Update2", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info
                .invoke_unchecked((), (stateId, frameIndex, predictionSeconds))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_8_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_8_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_9_0")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_OVRP_1_9_0 {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_9_0")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OVRP_1_9_0 {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OVRP_1_9_0";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_9_0")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_OVRP_1_9_0 {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_9_0")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_OVRP_1_9_0 {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+OVRP_1_9_0")]
impl crate::GlobalNamespace::OVRPlugin_OVRP_1_9_0 {
    pub fn ovrp_GetActiveController() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Controller,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Controller,
                        0usize,
                    >("ovrp_GetActiveController")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetActiveController", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Controller = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetAppPerfStats() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_AppPerfStats,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_AppPerfStats,
                        0usize,
                    >("ovrp_GetAppPerfStats")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetAppPerfStats", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_AppPerfStats = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetBoundaryGeometry2(
        boundaryType: crate::GlobalNamespace::OVRPlugin_BoundaryType,
        points: crate::System::IntPtr,
        pointsCount: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<crate::GlobalNamespace::OVRPlugin_Bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::GlobalNamespace::OVRPlugin_BoundaryType,
                            crate::System::IntPtr,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        3usize,
                    >("ovrp_GetBoundaryGeometry2")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetBoundaryGeometry2", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), (boundaryType, points, pointsCount))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetConnectedControllers() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Controller,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Controller,
                        0usize,
                    >("ovrp_GetConnectedControllers")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetConnectedControllers", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Controller = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_GetSystemHeadsetType() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_SystemHeadset,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_SystemHeadset,
                        0usize,
                    >("ovrp_GetSystemHeadsetType")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_GetSystemHeadsetType", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_SystemHeadset = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ovrp_ResetAppPerfStats() -> quest_hook::libil2cpp::Result<
        crate::GlobalNamespace::OVRPlugin_Bool,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        crate::GlobalNamespace::OVRPlugin_Bool,
                        0usize,
                    >("ovrp_ResetAppPerfStats")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ovrp_ResetAppPerfStats", 0usize
                        )
                    })
            });
        let __cordl_ret: crate::GlobalNamespace::OVRPlugin_Bool = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OVRP_1_9_0")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_OVRP_1_9_0 {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayFlag")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_OverlayFlag {
    #[default]
    AutoFiltering = 1024i32,
    BicubicFiltering = 64i32,
    EfficientSharpen = 32i32,
    EfficientSuperSample = 16i32,
    ExpensiveSharpen = 128i32,
    ExpensiveSuperSample = 8i32,
    HeadLocked = 2i32,
    Hidden = 512i32,
    NoDepth = 4i32,
    None = 0i32,
    OnTop = 1i32,
    SecureContent = 256i32,
    ShapeFlagRangeMask = 240i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayFlag")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OverlayFlag {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OverlayFlag";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayFlag")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_OverlayFlag {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayFlag")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_OverlayFlag {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayFlag")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_OverlayFlag {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayFlag")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_OverlayFlag {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayShape")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_OverlayShape {
    #[default]
    Cubemap = 2i32,
    Cylinder = 1i32,
    Equirect = 5i32,
    Fisheye = 9i32,
    KeyboardHandsPassthrough = 10i32,
    KeyboardMaskedHandsPassthrough = 11i32,
    OffcenterCubemap = 4i32,
    Quad = 0i32,
    ReconstructionPassthrough = 7i32,
    SurfaceProjectedPassthrough = 8i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_OverlayShape {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/OverlayShape";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_OverlayShape {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_OverlayShape {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_OverlayShape {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+OverlayShape")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_OverlayShape {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilities")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_PassthroughCapabilities {
    pub Fields: crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFields,
    pub Flags: crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags,
    pub MaxColorLutResolution: u32,
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilities")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PassthroughCapabilities";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilities")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilities")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilities")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilities")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilities")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+PassthroughCapabilities")]
impl crate::GlobalNamespace::OVRPlugin_PassthroughCapabilities {}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFields")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_PassthroughCapabilityFields {
    #[default]
    Flags = 1i32,
    MaxColorLutResolution = 2i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFields")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFields {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PassthroughCapabilityFields";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFields")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFields {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFields")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFields {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFields")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFields {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFields")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFields {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFlags")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_PassthroughCapabilityFlags {
    #[default]
    Color = 2i32,
    Depth = 4i32,
    Passthrough = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PassthroughCapabilityFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughCapabilityFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PassthroughCapabilityFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutChannels")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_PassthroughColorLutChannels {
    #[default]
    Rgb = 1i32,
    Rgba = 2i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutChannels")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PassthroughColorLutChannels";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutChannels")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutChannels")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutChannels")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutChannels")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutChannels {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutData")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_PassthroughColorLutData {
    pub BufferSize: u32,
    pub Buffer: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutData")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PassthroughColorLutData";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutData")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutData")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutData")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutData")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughColorLutData")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+PassthroughColorLutData")]
impl crate::GlobalNamespace::OVRPlugin_PassthroughColorLutData {}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFields")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_PassthroughPreferenceFields {
    #[default]
    Flags = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFields")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFields {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PassthroughPreferenceFields";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFields")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFields {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFields")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFields {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFields")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFields {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFields")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFields {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFlags")]
#[repr(i64)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_PassthroughPreferenceFlags {
    #[default]
    DefaultToActive = 1i64,
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PassthroughPreferenceFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferenceFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferences")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_PassthroughPreferences {
    pub Fields: crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFields,
    pub Flags: crate::GlobalNamespace::OVRPlugin_PassthroughPreferenceFlags,
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferences")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferences {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PassthroughPreferences";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferences")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferences {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferences")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferences {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferences")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferences {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferences")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferences {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PassthroughPreferences")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_PassthroughPreferences {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+PassthroughPreferences")]
impl crate::GlobalNamespace::OVRPlugin_PassthroughPreferences {}
#[cfg(feature = "cordl_class_OVRPlugin+PerfMetrics")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_PerfMetrics {
    #[default]
    App_CpuTime_Float = 0i32,
    App_GpuTime_Float = 1i32,
    Compositor_CpuTime_Float = 3i32,
    Compositor_DroppedFrameCount_Int = 5i32,
    Compositor_GpuTime_Float = 4i32,
    Compositor_SpaceWarp_Mode_Int = 14i32,
    Count = 40i32,
    Device_CpuClockFrequencyInMHz_Float = 10i32,
    Device_CpuClockLevel_Int = 12i32,
    Device_CpuCore0UtilPercentage_Float = 32i32,
    Device_CpuCore1UtilPercentage_Float = 33i32,
    Device_CpuCore2UtilPercentage_Float = 34i32,
    Device_CpuCore3UtilPercentage_Float = 35i32,
    Device_CpuCore4UtilPercentage_Float = 36i32,
    Device_CpuCore5UtilPercentage_Float = 37i32,
    Device_CpuCore6UtilPercentage_Float = 38i32,
    Device_CpuCore7UtilPercentage_Float = 39i32,
    Device_GpuClockFrequencyInMHz_Float = 11i32,
    Device_GpuClockLevel_Int = 13i32,
    EnumSize = 2147483647i32,
    System_CpuUtilAveragePercentage_Float = 8i32,
    System_CpuUtilWorstPercentage_Float = 9i32,
    System_GpuUtilPercentage_Float = 7i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+PerfMetrics")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PerfMetrics {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PerfMetrics";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PerfMetrics")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PerfMetrics {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PerfMetrics")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PerfMetrics {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PerfMetrics")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PerfMetrics {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PerfMetrics")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PerfMetrics {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PinnedArray_1")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_PinnedArray_1<T: quest_hook::libil2cpp::Type> {
    pub _handle: crate::System::Runtime::InteropServices::GCHandle,
    __cordl_phantom_T: std::marker::PhantomData<T>,
}
#[cfg(feature = "cordl_class_OVRPlugin+PinnedArray_1")]
unsafe impl<T: quest_hook::libil2cpp::Type> quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PinnedArray`1";
    fn class() -> &'static quest_hook::libil2cpp::Il2CppClass {
        static CLASS: ::std::sync::OnceLock<
            &'static quest_hook::libil2cpp::Il2CppClass,
        > = ::std::sync::OnceLock::new();
        CLASS
            .get_or_init(|| {
                quest_hook::libil2cpp::Il2CppClass::find("", "OVRPlugin/PinnedArray`1")
                    .unwrap()
                    .make_generic::<(T)>()
                    .unwrap()
                    .unwrap()
            })
    }
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PinnedArray_1")]
unsafe impl<T: quest_hook::libil2cpp::Type> quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PinnedArray_1")]
unsafe impl<T: quest_hook::libil2cpp::Type> quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PinnedArray_1")]
unsafe impl<T: quest_hook::libil2cpp::Type> quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PinnedArray_1")]
unsafe impl<T: quest_hook::libil2cpp::Type> quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PinnedArray_1")]
unsafe impl<T: quest_hook::libil2cpp::Type> quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+PinnedArray_1")]
impl<T: quest_hook::libil2cpp::Type> crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    pub fn Dispose(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void>
    where
        T: quest_hook::libil2cpp::Type + quest_hook::libil2cpp::Type
            + quest_hook::libil2cpp::Argument + quest_hook::libil2cpp::Returned,
    {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("Dispose")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "Dispose",
                            0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
        array: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<T>>,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void>
    where
        T: quest_hook::libil2cpp::Type + quest_hook::libil2cpp::Type
            + quest_hook::libil2cpp::Argument + quest_hook::libil2cpp::Returned,
    {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (quest_hook::libil2cpp::Gc<
                            quest_hook::libil2cpp::Il2CppArray<T>,
                        >),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (array))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn op_Implicit(
        pinnedArray: crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T>,
    ) -> quest_hook::libil2cpp::Result<crate::System::IntPtr>
    where
        T: quest_hook::libil2cpp::Type + quest_hook::libil2cpp::Type
            + quest_hook::libil2cpp::Argument + quest_hook::libil2cpp::Returned,
    {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T>),
                        crate::System::IntPtr,
                        1usize,
                    >("op_Implicit")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "op_Implicit", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), (pinnedArray))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "OVRPlugin+PinnedArray_1")]
impl<T: quest_hook::libil2cpp::Type> AsRef<crate::System::IDisposable>
for crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    fn as_ref(&self) -> &crate::System::IDisposable {
        todo!()
    }
}
#[cfg(feature = "OVRPlugin+PinnedArray_1")]
impl<T: quest_hook::libil2cpp::Type> AsMut<crate::System::IDisposable>
for crate::GlobalNamespace::OVRPlugin_PinnedArray_1<T> {
    fn as_mut(&mut self) -> &mut crate::System::IDisposable {
        todo!()
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PlatformUI")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_PlatformUI {
    #[default]
    ConfirmQuit = 1i32,
    GlobalMenuTutorial = 2i32,
    None = -1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+PlatformUI")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PlatformUI {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PlatformUI";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PlatformUI")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PlatformUI {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PlatformUI")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PlatformUI {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PlatformUI")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PlatformUI {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PlatformUI")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PlatformUI {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PolygonalBoundary2DInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_PolygonalBoundary2DInternal {
    pub vertexCapacityInput: i32,
    pub vertexCountOutput: i32,
    pub vertices: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+PolygonalBoundary2DInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PolygonalBoundary2DInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PolygonalBoundary2DInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PolygonalBoundary2DInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PolygonalBoundary2DInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PolygonalBoundary2DInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PolygonalBoundary2DInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+PolygonalBoundary2DInternal")]
impl crate::GlobalNamespace::OVRPlugin_PolygonalBoundary2DInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+PoseStatef")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_PoseStatef {
    pub Pose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub Velocity: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub Acceleration: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub AngularVelocity: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub AngularAcceleration: crate::GlobalNamespace::OVRPlugin_Vector3f,
    pub Time: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+PoseStatef")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_PoseStatef {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/PoseStatef";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PoseStatef")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_PoseStatef {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PoseStatef")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_PoseStatef {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PoseStatef")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_PoseStatef {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PoseStatef")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_PoseStatef {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+PoseStatef")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_PoseStatef {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+PoseStatef")]
impl crate::GlobalNamespace::OVRPlugin_PoseStatef {}
#[cfg(feature = "cordl_class_OVRPlugin+Posef")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Posef {
    pub Orientation: crate::GlobalNamespace::OVRPlugin_Quatf,
    pub Position: crate::GlobalNamespace::OVRPlugin_Vector3f,
}
#[cfg(feature = "cordl_class_OVRPlugin+Posef")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Posef {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Posef";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Posef")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Posef {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Posef")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Posef {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Posef")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Posef {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Posef")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Posef {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Posef")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Posef {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Posef")]
impl crate::GlobalNamespace::OVRPlugin_Posef {
    pub fn ToString(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ToString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToString", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ProcessorPerformanceLevel")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_ProcessorPerformanceLevel {
    #[default]
    Boost = 3i32,
    EnumSize = 2147483647i32,
    PowerSavings = 0i32,
    SustainedHigh = 2i32,
    SustainedLow = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+ProcessorPerformanceLevel")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/ProcessorPerformanceLevel";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ProcessorPerformanceLevel")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ProcessorPerformanceLevel")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ProcessorPerformanceLevel")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+ProcessorPerformanceLevel")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_ProcessorPerformanceLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_Qpl {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Qpl {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Qpl";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_Qpl {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_Qpl {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+Qpl")]
impl crate::GlobalNamespace::OVRPlugin_Qpl {
    pub const AutoSetTimeoutMs: i32 = 0i32;
    pub const AutoSetTimestampMs: i64 = -1i64;
    pub const DefaultInstanceKey: i32 = 0i32;
    #[cfg(feature = "OVRPlugin+Qpl+ResultType")]
    pub type ResultType = crate::GlobalNamespace::Qpl_OVRPlugin_ResultType;
    pub fn CreateMarkerHandle(
        name: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        nameHandle: quest_hook::libil2cpp::ByRefMut<i32>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::ByRefMut<i32>,
                        ),
                        bool,
                        2usize,
                    >("CreateMarkerHandle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "CreateMarkerHandle", 2usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (name, nameHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn DestroyMarkerHandle(nameHandle: i32) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), bool, 1usize>("DestroyMarkerHandle")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "DestroyMarkerHandle", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (nameHandle))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn MarkerAnnotation(
        markerId: i32,
        annotationKey: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        annotationValue: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
        instanceKey: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppString,
                            >,
                            i32,
                        ),
                        quest_hook::libil2cpp::Void,
                        4usize,
                    >("MarkerAnnotation")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "MarkerAnnotation", 4usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (markerId, annotationKey, annotationValue, instanceKey),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn MarkerEnd(
        markerId: i32,
        resultTypeId: crate::GlobalNamespace::Qpl_OVRPlugin_ResultType,
        instanceKey: i32,
        timestampMs: i64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            i32,
                            crate::GlobalNamespace::Qpl_OVRPlugin_ResultType,
                            i32,
                            i64,
                        ),
                        quest_hook::libil2cpp::Void,
                        4usize,
                    >("MarkerEnd")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "MarkerEnd", 4usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info
                .invoke_unchecked(
                    (),
                    (markerId, resultTypeId, instanceKey, timestampMs),
                )?
        };
        Ok(__cordl_ret.into())
    }
    pub fn MarkerPointCached(
        markerId: i32,
        nameHandle: i32,
        instanceKey: i32,
        timestampMs: i64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, i32, i64),
                        quest_hook::libil2cpp::Void,
                        4usize,
                    >("MarkerPointCached")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "MarkerPointCached", 4usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info
                .invoke_unchecked((), (markerId, nameHandle, instanceKey, timestampMs))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn MarkerStart(
        markerId: i32,
        instanceKey: i32,
        timestampMs: i64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, i64),
                        quest_hook::libil2cpp::Void,
                        3usize,
                    >("MarkerStart")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "MarkerStart", 3usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (markerId, instanceKey, timestampMs))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl")]
impl quest_hook::libil2cpp::ObjectType for crate::GlobalNamespace::OVRPlugin_Qpl {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Quatf")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Quatf {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Quatf")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Quatf {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Quatf";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Quatf")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Quatf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Quatf")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Quatf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Quatf")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Quatf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Quatf")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Quatf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Quatf")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Quatf {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Quatf")]
impl crate::GlobalNamespace::OVRPlugin_Quatf {
    pub fn ToString(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ToString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToString", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RecenterFlags")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_RecenterFlags {
    #[default]
    Count = -2147483647i32,
    Default = 0i32,
    IgnoreAll = -2147483648i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+RecenterFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_RecenterFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/RecenterFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RecenterFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_RecenterFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RecenterFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_RecenterFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RecenterFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_RecenterFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RecenterFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_RecenterFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Rectf")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Rectf {
    pub Pos: crate::GlobalNamespace::OVRPlugin_Vector2f,
    pub Size: crate::GlobalNamespace::OVRPlugin_Sizef,
}
#[cfg(feature = "cordl_class_OVRPlugin+Rectf")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Rectf {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Rectf";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Rectf")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Rectf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Rectf")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Rectf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Rectf")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Rectf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Rectf")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Rectf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Rectf")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Rectf {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Rectf")]
impl crate::GlobalNamespace::OVRPlugin_Rectf {}
#[cfg(feature = "cordl_class_OVRPlugin+Recti")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Recti {
    pub Pos: crate::GlobalNamespace::OVRPlugin_Vector2i,
    pub Size: crate::GlobalNamespace::OVRPlugin_Sizei,
}
#[cfg(feature = "cordl_class_OVRPlugin+Recti")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Recti {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Recti";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Recti")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Recti {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Recti")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Recti {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Recti")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Recti {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Recti")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Recti {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Recti")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Recti {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Recti")]
impl crate::GlobalNamespace::OVRPlugin_Recti {}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelFlags")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_RenderModelFlags {
    #[default]
    SupportsGltf20Subset1 = 1i32,
    SupportsGltf20Subset2 = 2i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_RenderModelFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/RenderModelFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_RenderModelFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_RenderModelFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_RenderModelFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_RenderModelFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelProperties")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_RenderModelProperties {
    pub ModelName: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    pub ModelKey: u64,
    pub VendorId: u32,
    pub ModelVersion: u32,
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelProperties")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_RenderModelProperties {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/RenderModelProperties";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelProperties")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_RenderModelProperties {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelProperties")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_RenderModelProperties {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelProperties")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_RenderModelProperties {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelProperties")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_RenderModelProperties {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelProperties")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_RenderModelProperties {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+RenderModelProperties")]
impl crate::GlobalNamespace::OVRPlugin_RenderModelProperties {}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelPropertiesInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_RenderModelPropertiesInternal {
    pub ModelName: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<u8>>,
    pub ModelKey: u64,
    pub VendorId: u32,
    pub ModelVersion: u32,
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelPropertiesInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/RenderModelPropertiesInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelPropertiesInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelPropertiesInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelPropertiesInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelPropertiesInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RenderModelPropertiesInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+RenderModelPropertiesInternal")]
impl crate::GlobalNamespace::OVRPlugin_RenderModelPropertiesInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+Result")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Result {
    #[default]
    Failure = -1000i32,
    Failure_DataIsInvalid = -1008i32,
    Failure_DeprecatedOperation = -1009i32,
    Failure_ErrorInitializationFailed = -1011i32,
    Failure_ErrorLimitReached = -1010i32,
    Failure_InsufficientSize = -1007i32,
    Failure_InvalidOperation = -1003i32,
    Failure_InvalidParameter = -1001i32,
    Failure_NotInitialized = -1002i32,
    Failure_NotYetImplemented = -1005i32,
    Failure_OperationFailed = -1006i32,
    Failure_SpaceCloudStorageDisabled = -2000i32,
    Failure_SpaceLocalizationFailed = -2002i32,
    Failure_SpaceMappingInsufficient = -2001i32,
    Failure_SpaceNetworkRequestFailed = -2004i32,
    Failure_SpaceNetworkTimeout = -2003i32,
    Failure_Unsupported = -1004i32,
    Success = 0i32,
    Success_EventUnavailable = 1i32,
    Success_Pending = 2i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Result")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Result {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Result";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Result")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Result {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Result")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Result {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Result")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Result {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Result")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Result {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayout")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_RoomLayout {
    pub floorUuid: crate::System::Guid,
    pub ceilingUuid: crate::System::Guid,
    pub wallUuids: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::System::Guid>,
    >,
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayout")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_RoomLayout {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/RoomLayout";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayout")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_RoomLayout {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayout")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_RoomLayout {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayout")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_RoomLayout {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayout")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_RoomLayout {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayout")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_RoomLayout {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+RoomLayout")]
impl crate::GlobalNamespace::OVRPlugin_RoomLayout {}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayoutInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_RoomLayoutInternal {
    pub floorUuid: crate::System::Guid,
    pub ceilingUuid: crate::System::Guid,
    pub wallUuidCapacityInput: i32,
    pub wallUuidCountOutput: i32,
    pub wallUuids: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayoutInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/RoomLayoutInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayoutInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayoutInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayoutInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayoutInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+RoomLayoutInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+RoomLayoutInternal")]
impl crate::GlobalNamespace::OVRPlugin_RoomLayoutInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+SceneCaptureRequestInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SceneCaptureRequestInternal {
    pub requestByteCount: i32,
    pub request: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
}
#[cfg(feature = "cordl_class_OVRPlugin+SceneCaptureRequestInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SceneCaptureRequestInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SceneCaptureRequestInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SceneCaptureRequestInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SceneCaptureRequestInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SceneCaptureRequestInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SceneCaptureRequestInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SceneCaptureRequestInternal")]
impl crate::GlobalNamespace::OVRPlugin_SceneCaptureRequestInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+Size3f")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Size3f {
    pub w: f32,
    pub h: f32,
    pub d: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Size3f")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Size3f {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Size3f";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Size3f")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Size3f {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Size3f")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Size3f {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Size3f")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Size3f {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Size3f")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Size3f {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Size3f")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Size3f {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Size3f")]
impl crate::GlobalNamespace::OVRPlugin_Size3f {}
#[cfg(feature = "cordl_class_OVRPlugin+Sizef")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Sizef {
    pub w: f32,
    pub h: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizef")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Sizef {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Sizef";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizef")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Sizef {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizef")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Sizef {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizef")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Sizef {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizef")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Sizef {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizef")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Sizef {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Sizef")]
impl crate::GlobalNamespace::OVRPlugin_Sizef {}
#[cfg(feature = "cordl_class_OVRPlugin+Sizei")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Sizei {
    pub w: i32,
    pub h: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizei")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Sizei {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Sizei";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizei")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Sizei {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizei")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Sizei {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizei")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Sizei {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizei")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Sizei {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Sizei")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Sizei {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Sizei")]
impl crate::GlobalNamespace::OVRPlugin_Sizei {
    pub fn Equals_Il2CppObject1(
        &mut self,
        obj: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        bool,
                        1usize,
                    >("Equals")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "Equals",
                            1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked(self, (obj))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Equals_OVRPlugin_Sizei0(
        &mut self,
        other: crate::GlobalNamespace::OVRPlugin_Sizei,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (crate::GlobalNamespace::OVRPlugin_Sizei),
                        bool,
                        1usize,
                    >("Equals")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "Equals",
                            1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked(self, (other))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn GetHashCode(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), i32, 0usize>("GetHashCode")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "GetHashCode", 0usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "OVRPlugin+Sizei")]
impl AsRef<crate::System::IEquatable_1<crate::GlobalNamespace::OVRPlugin_Sizei>>
for crate::GlobalNamespace::OVRPlugin_Sizei {
    fn as_ref(
        &self,
    ) -> &crate::System::IEquatable_1<crate::GlobalNamespace::OVRPlugin_Sizei> {
        todo!()
    }
}
#[cfg(feature = "OVRPlugin+Sizei")]
impl AsMut<crate::System::IEquatable_1<crate::GlobalNamespace::OVRPlugin_Sizei>>
for crate::GlobalNamespace::OVRPlugin_Sizei {
    fn as_mut(
        &mut self,
    ) -> &mut crate::System::IEquatable_1<crate::GlobalNamespace::OVRPlugin_Sizei> {
        todo!()
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Skeleton {
    pub Type: crate::GlobalNamespace::OVRPlugin_SkeletonType,
    pub NumBones: u32,
    pub NumBoneCapsules: u32,
    pub Bones: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Bone>,
    >,
    pub BoneCapsules: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_BoneCapsule>,
    >,
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Skeleton {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Skeleton";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Skeleton {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Skeleton {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Skeleton {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Skeleton {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Skeleton {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Skeleton")]
impl crate::GlobalNamespace::OVRPlugin_Skeleton {}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Skeleton2 {
    pub Type: crate::GlobalNamespace::OVRPlugin_SkeletonType,
    pub NumBones: u32,
    pub NumBoneCapsules: u32,
    pub Bones: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_Bone>,
    >,
    pub BoneCapsules: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::GlobalNamespace::OVRPlugin_BoneCapsule>,
    >,
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Skeleton2 {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Skeleton2";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Skeleton2 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Skeleton2 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Skeleton2 {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Skeleton2 {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Skeleton2 {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Skeleton2")]
impl crate::GlobalNamespace::OVRPlugin_Skeleton2 {}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2Internal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Skeleton2Internal {
    pub Type: crate::GlobalNamespace::OVRPlugin_SkeletonType,
    pub NumBones: u32,
    pub NumBoneCapsules: u32,
    pub Bones_0: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_1: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_2: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_3: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_4: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_5: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_6: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_7: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_8: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_9: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_10: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_11: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_12: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_13: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_14: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_15: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_16: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_17: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_18: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_19: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_20: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_21: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_22: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_23: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_24: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_25: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_26: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_27: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_28: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_29: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_30: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_31: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_32: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_33: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_34: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_35: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_36: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_37: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_38: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_39: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_40: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_41: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_42: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_43: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_44: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_45: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_46: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_47: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_48: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_49: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_50: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_51: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_52: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_53: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_54: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_55: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_56: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_57: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_58: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_59: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_60: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_61: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_62: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_63: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_64: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_65: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_66: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_67: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_68: crate::GlobalNamespace::OVRPlugin_Bone,
    pub Bones_69: crate::GlobalNamespace::OVRPlugin_Bone,
    pub BoneCapsules_0: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_1: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_2: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_3: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_4: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_5: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_6: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_7: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_8: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_9: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_10: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_11: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_12: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_13: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_14: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_15: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_16: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_17: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
    pub BoneCapsules_18: crate::GlobalNamespace::OVRPlugin_BoneCapsule,
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2Internal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_Skeleton2Internal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Skeleton2Internal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2Internal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Skeleton2Internal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2Internal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Skeleton2Internal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2Internal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Skeleton2Internal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2Internal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Skeleton2Internal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Skeleton2Internal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Skeleton2Internal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Skeleton2Internal")]
impl crate::GlobalNamespace::OVRPlugin_Skeleton2Internal {}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonConstants")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SkeletonConstants {
    #[default]
    MaxBodyBones = 70i32,
    MaxBoneCapsules = 19i32,
    MaxHandBones = 24i32,
    MaxNumMicrogestures = 5i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonConstants")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SkeletonConstants {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SkeletonConstants";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonConstants")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SkeletonConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonConstants")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SkeletonConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonConstants")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SkeletonConstants {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonConstants")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SkeletonConstants {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SkeletonType {
    #[default]
    Body = 2i32,
    HandLeft = 0i32,
    HandRight = 1i32,
    None = -1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SkeletonType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SkeletonType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SkeletonType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SkeletonType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SkeletonType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SkeletonType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SkeletonType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceComponentType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SpaceComponentType {
    #[default]
    Bounded2D = 3i32,
    Bounded3D = 4i32,
    Locatable = 0i32,
    RoomLayout = 6i32,
    SemanticLabels = 5i32,
    Sharable = 2i32,
    SpaceContainer = 7i32,
    Storable = 1i32,
    TriangleMesh = 1000269000i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceComponentType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceComponentType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceComponentType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceComponentType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceComponentType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceComponentType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceComponentType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceComponentType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceComponentType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceComponentType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceComponentType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceContainerInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SpaceContainerInternal {
    pub uuidCapacityInput: i32,
    pub uuidCountOutput: i32,
    pub uuids: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceContainerInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceContainerInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceContainerInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceContainerInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceContainerInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceContainerInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceContainerInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SpaceContainerInternal")]
impl crate::GlobalNamespace::OVRPlugin_SpaceContainerInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoComponents")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SpaceFilterInfoComponents {
    pub Components: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            crate::GlobalNamespace::OVRPlugin_SpaceComponentType,
        >,
    >,
    pub NumComponents: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoComponents")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceFilterInfoComponents";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoComponents")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoComponents")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoComponents")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoComponents")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoComponents")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SpaceFilterInfoComponents")]
impl crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents {}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoIds")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SpaceFilterInfoIds {
    pub Ids: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<crate::System::Guid>,
    >,
    pub NumIds: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoIds")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceFilterInfoIds";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoIds")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoIds")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoIds")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoIds")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceFilterInfoIds")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SpaceFilterInfoIds")]
impl crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds {}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationFlags")]
#[repr(u64)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SpaceLocationFlags {
    #[default]
    OrientationTracked = 4u64,
    OrientationValid = 1u64,
    PositionTracked = 8u64,
    PositionValid = 2u64,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceLocationFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationf")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SpaceLocationf {
    pub locationFlags: crate::GlobalNamespace::OVRPlugin_SpaceLocationFlags,
    pub pose: crate::GlobalNamespace::OVRPlugin_Posef,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationf")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceLocationf {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceLocationf";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationf")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceLocationf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationf")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceLocationf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationf")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceLocationf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationf")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceLocationf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceLocationf")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SpaceLocationf {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SpaceLocationf")]
impl crate::GlobalNamespace::OVRPlugin_SpaceLocationf {}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryActionType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SpaceQueryActionType {
    #[default]
    Load = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryActionType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceQueryActionType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceQueryActionType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryActionType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceQueryActionType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryActionType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceQueryActionType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryActionType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceQueryActionType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryActionType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceQueryActionType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryFilterType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SpaceQueryFilterType {
    #[default]
    Components = 2i32,
    Ids = 1i32,
    None = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryFilterType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceQueryFilterType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceQueryFilterType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryFilterType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceQueryFilterType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryFilterType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceQueryFilterType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryFilterType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceQueryFilterType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryFilterType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceQueryFilterType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryInfo")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SpaceQueryInfo {
    pub QueryType: crate::GlobalNamespace::OVRPlugin_SpaceQueryType,
    pub MaxQuerySpaces: i32,
    pub Timeout: f64,
    pub Location: crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation,
    pub ActionType: crate::GlobalNamespace::OVRPlugin_SpaceQueryActionType,
    pub FilterType: crate::GlobalNamespace::OVRPlugin_SpaceQueryFilterType,
    pub IdInfo: crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoIds,
    pub ComponentsInfo: crate::GlobalNamespace::OVRPlugin_SpaceFilterInfoComponents,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryInfo")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceQueryInfo";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryInfo")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryInfo")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryInfo")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryInfo")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryInfo")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SpaceQueryInfo")]
impl crate::GlobalNamespace::OVRPlugin_SpaceQueryInfo {}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryResult")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SpaceQueryResult {
    pub space: u64,
    pub uuid: crate::System::Guid,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryResult")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceQueryResult {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceQueryResult";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryResult")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceQueryResult {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryResult")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceQueryResult {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryResult")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceQueryResult {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryResult")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceQueryResult {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryResult")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SpaceQueryResult {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SpaceQueryResult")]
impl crate::GlobalNamespace::OVRPlugin_SpaceQueryResult {}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SpaceQueryType {
    #[default]
    Action = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceQueryType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceQueryType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceQueryType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceQueryType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceQueryType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceQueryType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceQueryType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceSemanticLabelInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SpaceSemanticLabelInternal {
    pub byteCapacityInput: i32,
    pub byteCountOutput: i32,
    pub labels: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceSemanticLabelInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceSemanticLabelInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceSemanticLabelInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceSemanticLabelInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceSemanticLabelInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceSemanticLabelInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceSemanticLabelInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SpaceSemanticLabelInternal")]
impl crate::GlobalNamespace::OVRPlugin_SpaceSemanticLabelInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStorageLocation")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SpaceStorageLocation {
    #[default]
    Cloud = 2i32,
    Invalid = 0i32,
    Local = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStorageLocation")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceStorageLocation";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStorageLocation")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStorageLocation")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStorageLocation")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStorageLocation")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceStorageLocation {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStoragePersistenceMode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SpaceStoragePersistenceMode {
    #[default]
    Indefinite = 1i32,
    Invalid = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStoragePersistenceMode")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpaceStoragePersistenceMode";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStoragePersistenceMode")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStoragePersistenceMode")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStoragePersistenceMode")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpaceStoragePersistenceMode")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpaceStoragePersistenceMode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpatialAnchorCreateInfo")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_SpatialAnchorCreateInfo {
    pub BaseTracking: crate::GlobalNamespace::OVRPlugin_TrackingOrigin,
    pub PoseInSpace: crate::GlobalNamespace::OVRPlugin_Posef,
    pub Time: f64,
}
#[cfg(feature = "cordl_class_OVRPlugin+SpatialAnchorCreateInfo")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SpatialAnchorCreateInfo";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpatialAnchorCreateInfo")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpatialAnchorCreateInfo")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpatialAnchorCreateInfo")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpatialAnchorCreateInfo")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SpatialAnchorCreateInfo")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+SpatialAnchorCreateInfo")]
impl crate::GlobalNamespace::OVRPlugin_SpatialAnchorCreateInfo {}
#[cfg(feature = "cordl_class_OVRPlugin+Step")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Step {
    #[default]
    Physics = 0i32,
    Render = -1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Step")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Step {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Step";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Step")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_Step {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Step")]
unsafe impl quest_hook::libil2cpp::Parameter for crate::GlobalNamespace::OVRPlugin_Step {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Step")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_Step {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Step")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Step {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemHeadset")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SystemHeadset {
    #[default]
    Meta_Link_Quest_3 = 4104i32,
    Meta_Link_Quest_Pro = 4103i32,
    Meta_Quest_3 = 11i32,
    Meta_Quest_Pro = 10i32,
    None = 0i32,
    Oculus_Link_Quest = 4101i32,
    Oculus_Link_Quest_2 = 4102i32,
    Oculus_Quest = 8i32,
    Oculus_Quest_2 = 9i32,
    PC_Placeholder_4105 = 4105i32,
    PC_Placeholder_4106 = 4106i32,
    PC_Placeholder_4107 = 4107i32,
    Placeholder_12 = 12i32,
    Placeholder_13 = 13i32,
    Placeholder_14 = 14i32,
    Rift_CB = 4099i32,
    Rift_CV1 = 4098i32,
    Rift_DK1 = 4096i32,
    Rift_DK2 = 4097i32,
    Rift_S = 4100i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemHeadset")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SystemHeadset {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SystemHeadset";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemHeadset")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SystemHeadset {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemHeadset")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SystemHeadset {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemHeadset")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SystemHeadset {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemHeadset")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SystemHeadset {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemRegion")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_SystemRegion {
    #[default]
    China = 2i32,
    Japan = 1i32,
    Unspecified = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemRegion")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_SystemRegion {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/SystemRegion";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemRegion")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_SystemRegion {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemRegion")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_SystemRegion {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemRegion")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_SystemRegion {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+SystemRegion")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_SystemRegion {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TextureRectMatrixf")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_TextureRectMatrixf {
    pub leftRect: crate::UnityEngine::Rect,
    pub rightRect: crate::UnityEngine::Rect,
    pub leftScaleBias: crate::UnityEngine::Vector4,
    pub rightScaleBias: crate::UnityEngine::Vector4,
}
#[cfg(feature = "cordl_class_OVRPlugin+TextureRectMatrixf")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/TextureRectMatrixf";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TextureRectMatrixf")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TextureRectMatrixf")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TextureRectMatrixf")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TextureRectMatrixf")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TextureRectMatrixf")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+TextureRectMatrixf")]
impl crate::GlobalNamespace::OVRPlugin_TextureRectMatrixf {
    pub fn ToString(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ToString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToString", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TiledMultiResLevel")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_TiledMultiResLevel {
    #[default]
    EnumSize = 2147483647i32,
    LMSHigh = 3i32,
    LMSHighTop = 4i32,
    LMSLow = 1i32,
    LMSMedium = 2i32,
    Off = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+TiledMultiResLevel")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/TiledMultiResLevel";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TiledMultiResLevel")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TiledMultiResLevel")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TiledMultiResLevel")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TiledMultiResLevel")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_TiledMultiResLevel {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardFlags")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_TrackedKeyboardFlags {
    #[default]
    Connected = 8i32,
    Exists = 1i32,
    Local = 2i32,
    Remote = 4i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/TrackedKeyboardFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardPresentationStyles")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_TrackedKeyboardPresentationStyles {
    #[default]
    KeyLabel = 2i32,
    Opaque = 1i32,
    Unknown = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardPresentationStyles")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardPresentationStyles {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/TrackedKeyboardPresentationStyles";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardPresentationStyles")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardPresentationStyles {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardPresentationStyles")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardPresentationStyles {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardPresentationStyles")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardPresentationStyles {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardPresentationStyles")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardPresentationStyles {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardQueryFlags")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_TrackedKeyboardQueryFlags {
    #[default]
    Local = 2i32,
    Remote = 4i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardQueryFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/TrackedKeyboardQueryFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardQueryFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardQueryFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardQueryFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackedKeyboardQueryFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_TrackedKeyboardQueryFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Tracker")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_Tracker {
    #[default]
    Count = 4i32,
    None = -1i32,
    One = 1i32,
    Three = 3i32,
    Two = 2i32,
    Zero = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Tracker")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Tracker {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Tracker";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Tracker")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Tracker {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Tracker")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Tracker {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Tracker")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Tracker {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Tracker")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_Tracker {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingConfidence")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_TrackingConfidence {
    #[default]
    High = 1065353216i32,
    Low = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingConfidence")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_TrackingConfidence {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/TrackingConfidence";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingConfidence")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_TrackingConfidence {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingConfidence")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_TrackingConfidence {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingConfidence")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_TrackingConfidence {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingConfidence")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_TrackingConfidence {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingOrigin")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_TrackingOrigin {
    #[default]
    Count = 5i32,
    EyeLevel = 0i32,
    FloorLevel = 1i32,
    Stage = 2i32,
    View = 4i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingOrigin")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_TrackingOrigin {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/TrackingOrigin";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingOrigin")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_TrackingOrigin {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingOrigin")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_TrackingOrigin {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingOrigin")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_TrackingOrigin {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TrackingOrigin")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_TrackingOrigin {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TriangleMeshInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_TriangleMeshInternal {
    pub vertexCapacityInput: i32,
    pub vertexCountOutput: i32,
    pub vertices: crate::System::IntPtr,
    pub indexCapacityInput: i32,
    pub indexCountOutput: i32,
    pub indices: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+TriangleMeshInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/TriangleMeshInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TriangleMeshInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TriangleMeshInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TriangleMeshInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TriangleMeshInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+TriangleMeshInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+TriangleMeshInternal")]
impl crate::GlobalNamespace::OVRPlugin_TriangleMeshInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+UnityOpenXR")]
#[repr(C)]
#[derive(Debug)]
pub struct OVRPlugin_UnityOpenXR {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_OVRPlugin+UnityOpenXR")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_UnityOpenXR {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/UnityOpenXR";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+UnityOpenXR")]
impl std::ops::Deref for crate::GlobalNamespace::OVRPlugin_UnityOpenXR {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+UnityOpenXR")]
impl std::ops::DerefMut for crate::GlobalNamespace::OVRPlugin_UnityOpenXR {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "OVRPlugin+UnityOpenXR")]
impl crate::GlobalNamespace::OVRPlugin_UnityOpenXR {
    pub fn HookGetInstanceProcAddr(
        func: crate::System::IntPtr,
    ) -> quest_hook::libil2cpp::Result<crate::System::IntPtr> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::System::IntPtr),
                        crate::System::IntPtr,
                        1usize,
                    >("HookGetInstanceProcAddr")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "HookGetInstanceProcAddr", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::System::IntPtr = unsafe {
            cordl_method_info.invoke_unchecked((), (func))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn OnAppSpaceChange(
        xrSpace: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("OnAppSpaceChange")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnAppSpaceChange", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSpace))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnInstanceCreate(xrInstance: u64) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), bool, 1usize>("OnInstanceCreate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnInstanceCreate", 1usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe {
            cordl_method_info.invoke_unchecked((), (xrInstance))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnInstanceDestroy(
        xrInstance: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("OnInstanceDestroy")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnInstanceDestroy", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrInstance))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnSessionBegin(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("OnSessionBegin")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnSessionBegin", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnSessionCreate(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("OnSessionCreate")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnSessionCreate", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnSessionDestroy(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("OnSessionDestroy")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnSessionDestroy", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnSessionEnd(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("OnSessionEnd")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnSessionEnd", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnSessionExiting(
        xrSession: u64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("OnSessionExiting")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnSessionExiting", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (xrSession))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnSessionStateChange(
        oldState: i32,
        newState: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("OnSessionStateChange")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "OnSessionStateChange", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (oldState, newState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetClientVersion() -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Void,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        quest_hook::libil2cpp::Void,
                        0usize,
                    >("SetClientVersion")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "SetClientVersion", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+UnityOpenXR")]
impl quest_hook::libil2cpp::ObjectType
for crate::GlobalNamespace::OVRPlugin_UnityOpenXR {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2f")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Vector2f {
    pub x: f32,
    pub y: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2f")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Vector2f {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Vector2f";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2f")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Vector2f {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2f")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Vector2f {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2f")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Vector2f {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2f")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Vector2f {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2f")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Vector2f {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Vector2f")]
impl crate::GlobalNamespace::OVRPlugin_Vector2f {}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2i")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Vector2i {
    pub x: i32,
    pub y: i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2i")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Vector2i {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Vector2i";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2i")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Vector2i {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2i")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Vector2i {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2i")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Vector2i {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2i")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Vector2i {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector2i")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Vector2i {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Vector2i")]
impl crate::GlobalNamespace::OVRPlugin_Vector2i {}
#[cfg(feature = "cordl_class_OVRPlugin+Vector3f")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Vector3f {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector3f")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Vector3f {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Vector3f";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector3f")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Vector3f {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector3f")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Vector3f {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector3f")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Vector3f {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector3f")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Vector3f {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector3f")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Vector3f {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Vector3f")]
impl crate::GlobalNamespace::OVRPlugin_Vector3f {
    pub fn ToString(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ToString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToString", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4f")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Vector4f {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4f")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Vector4f {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Vector4f";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4f")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Vector4f {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4f")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Vector4f {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4f")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Vector4f {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4f")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Vector4f {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4f")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Vector4f {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Vector4f")]
impl crate::GlobalNamespace::OVRPlugin_Vector4f {
    pub fn ToString(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ToString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToString", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4s")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_Vector4s {
    pub x: i16,
    pub y: i16,
    pub z: i16,
    pub w: i16,
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4s")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_Vector4s {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Vector4s";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4s")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_Vector4s {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4s")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_Vector4s {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4s")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_Vector4s {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4s")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_Vector4s {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Vector4s")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_Vector4s {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+Vector4s")]
impl crate::GlobalNamespace::OVRPlugin_Vector4s {
    pub fn ToString(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
    > {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (),
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppString>,
                        0usize,
                    >("ToString")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "ToString", 0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppString,
        > = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardCreateInfo")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardCreateInfo {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardCreateInfo")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardCreateInfo";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardCreateInfo")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardCreateInfo")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardCreateInfo")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardCreateInfo")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardCreateInfo")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardCreateInfo")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardCreateInfo {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputInfo")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardInputInfo {
    pub inputSource: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputSource,
    pub inputPose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub inputState: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputStateFlags,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputInfo")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardInputInfo";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputInfo")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputInfo")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputInfo")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputInfo")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputInfo")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardInputInfo")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputInfo {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputSource")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_VirtualKeyboardInputSource {
    #[default]
    ControllerDirectLeft = 5i32,
    ControllerDirectRight = 6i32,
    ControllerRayLeft = 1i32,
    ControllerRayRight = 2i32,
    EnumSize = 2147483647i32,
    HandDirectIndexTipLeft = 7i32,
    HandDirectIndexTipRight = 8i32,
    HandRayLeft = 3i32,
    HandRayRight = 4i32,
    Invalid = 0i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputSource")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputSource {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardInputSource";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputSource")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputSource {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputSource")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputSource {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputSource")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputSource {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputSource")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputSource {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputStateFlags")]
#[repr(u64)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_VirtualKeyboardInputStateFlags {
    #[default]
    IsPressed = 1u64,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputStateFlags")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputStateFlags {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardInputStateFlags";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputStateFlags")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputStateFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputStateFlags")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputStateFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputStateFlags")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputStateFlags {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardInputStateFlags")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardInputStateFlags {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationInfo")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardLocationInfo {
    pub locationType: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationType,
    pub pose: crate::GlobalNamespace::OVRPlugin_Posef,
    pub scale: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationInfo")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardLocationInfo";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationInfo")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationInfo")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationInfo")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationInfo")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationInfo")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardLocationInfo")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationInfo {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_VirtualKeyboardLocationType {
    #[default]
    Custom = 0i32,
    Direct = 2i32,
    Far = 1i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardLocationType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardLocationType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationState")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardModelAnimationState {
    pub AnimationIndex: i32,
    pub Fraction: f32,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationState")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardModelAnimationState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationState")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardModelAnimationState")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStates")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardModelAnimationStates {
    pub States: quest_hook::libil2cpp::Gc<
        quest_hook::libil2cpp::Il2CppArray<
            crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationState,
        >,
    >,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStates")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardModelAnimationStates";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStates")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStates")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStates")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStates")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStates")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardModelAnimationStates")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStates {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardModelAnimationStatesInternal {
    pub StateCapacityInput: u32,
    pub StateCountOutput: u32,
    pub StatesBuffer: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardModelAnimationStatesInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardModelAnimationStatesInternal")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelAnimationStatesInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelVisibility")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardModelVisibility {
    pub _visible: crate::GlobalNamespace::OVRPlugin_Bool,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelVisibility")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardModelVisibility";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelVisibility")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelVisibility")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelVisibility")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelVisibility")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardModelVisibility")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardModelVisibility")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardModelVisibility {
    pub fn get_Visible(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), bool, 0usize>("get_Visible")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_Visible", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn set_Visible(
        &mut self,
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<
                        (bool),
                        quest_hook::libil2cpp::Void,
                        1usize,
                    >("set_Visible")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "set_Visible", 1usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardSpaceCreateInfo {
    pub locationType: crate::GlobalNamespace::OVRPlugin_VirtualKeyboardLocationType,
    pub pose: crate::GlobalNamespace::OVRPlugin_Posef,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardSpaceCreateInfo";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardSpaceCreateInfo")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardSpaceCreateInfo {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureData")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardTextureData {
    pub TextureWidth: u32,
    pub TextureHeight: u32,
    pub BufferCapacityInput: u32,
    pub BufferCountOutput: u32,
    pub Buffer: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureData")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardTextureData";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureData")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureData")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureData")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureData")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureData")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardTextureData")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureData {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIds")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardTextureIds {
    pub TextureIds: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<u64>>,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIds")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardTextureIds";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIds")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIds")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIds")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIds")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIds")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardTextureIds")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIds {}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIdsInternal")]
#[repr(C)]
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OVRPlugin_VirtualKeyboardTextureIdsInternal {
    pub TextureIdCapacityInput: u32,
    pub TextureIdCountOutput: u32,
    pub TextureIdsBuffer: crate::System::IntPtr,
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIdsInternal")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/VirtualKeyboardTextureIdsInternal";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIdsInternal")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIdsInternal")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIdsInternal")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIdsInternal")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+VirtualKeyboardTextureIdsInternal")]
unsafe impl quest_hook::libil2cpp::ThisArgument
for crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal {
    type Type = Self;
    fn matches(method: &quest_hook::libil2cpp::MethodInfo) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_this_argument(method)
    }
    fn invokable(&mut self) -> *mut std::ffi::c_void {
        unsafe { quest_hook::libil2cpp::value_box(self) as *mut std::ffi::c_void }
    }
}
#[cfg(feature = "OVRPlugin+VirtualKeyboardTextureIdsInternal")]
impl crate::GlobalNamespace::OVRPlugin_VirtualKeyboardTextureIdsInternal {}
#[cfg(feature = "cordl_class_OVRPlugin+XrApi")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OVRPlugin_XrApi {
    #[default]
    CAPI = 1i32,
    EnumSize = 2147483647i32,
    OpenXR = 3i32,
    Unknown = 0i32,
    VRAPI = 2i32,
}
#[cfg(feature = "cordl_class_OVRPlugin+XrApi")]
unsafe impl quest_hook::libil2cpp::Type for crate::GlobalNamespace::OVRPlugin_XrApi {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/XrApi";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+XrApi")]
unsafe impl quest_hook::libil2cpp::Argument for crate::GlobalNamespace::OVRPlugin_XrApi {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+XrApi")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::OVRPlugin_XrApi {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+XrApi")]
unsafe impl quest_hook::libil2cpp::Returned for crate::GlobalNamespace::OVRPlugin_XrApi {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+XrApi")]
unsafe impl quest_hook::libil2cpp::Return for crate::GlobalNamespace::OVRPlugin_XrApi {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl+ResultType")]
#[repr(i16)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Qpl_OVRPlugin_ResultType {
    #[default]
    Cancel = 4i16,
    Fail = 3i16,
    Success = 2i16,
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl+ResultType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::GlobalNamespace::Qpl_OVRPlugin_ResultType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "";
    const CLASS_NAME: &'static str = "OVRPlugin/Qpl/ResultType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl+ResultType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::GlobalNamespace::Qpl_OVRPlugin_ResultType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl+ResultType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::GlobalNamespace::Qpl_OVRPlugin_ResultType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Parameter>::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Parameter>::Actual {
        self
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl+ResultType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::GlobalNamespace::Qpl_OVRPlugin_ResultType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "cordl_class_OVRPlugin+Qpl+ResultType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::GlobalNamespace::Qpl_OVRPlugin_ResultType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> <Self as quest_hook::libil2cpp::Return>::Actual {
        self
    }
    fn from_actual(actual: <Self as quest_hook::libil2cpp::Return>::Actual) -> Self {
        actual
    }
}
