#[cfg(feature = "Tayx+Graphy+GraphyManager")]
#[repr(C)]
#[derive(Debug)]
pub struct GraphyManager {
    __cordl_parent: crate::Tayx::Graphy::Utils::G_Singleton_1<
        quest_hook::libil2cpp::Gc<crate::Tayx::Graphy::GraphyManager>,
    >,
    pub m_graphyMode: crate::Tayx::Graphy::GraphyManager_Mode,
    pub m_enableOnStartup: bool,
    pub m_keepAlive: bool,
    pub m_background: bool,
    pub m_backgroundColor: crate::UnityEngine::Color,
    pub m_enableHotkeys: bool,
    pub m_toggleModeKeyCode: crate::UnityEngine::InputSystem::Key,
    pub m_toggleModeCtrl: bool,
    pub m_toggleModeAlt: bool,
    pub m_toggleActiveKeyCode: crate::UnityEngine::InputSystem::Key,
    pub m_toggleActiveCtrl: bool,
    pub m_toggleActiveAlt: bool,
    pub m_graphModulePosition: crate::Tayx::Graphy::GraphyManager_ModulePosition,
    pub m_fpsModuleState: crate::Tayx::Graphy::GraphyManager_ModuleState,
    pub m_goodFpsColor: crate::UnityEngine::Color,
    pub m_goodFpsThreshold: i32,
    pub m_cautionFpsColor: crate::UnityEngine::Color,
    pub m_cautionFpsThreshold: i32,
    pub m_criticalFpsColor: crate::UnityEngine::Color,
    pub m_fpsGraphResolution: i32,
    pub m_fpsTextUpdateRate: i32,
    pub m_ramModuleState: crate::Tayx::Graphy::GraphyManager_ModuleState,
    pub m_allocatedRamColor: crate::UnityEngine::Color,
    pub m_reservedRamColor: crate::UnityEngine::Color,
    pub m_monoRamColor: crate::UnityEngine::Color,
    pub m_ramGraphResolution: i32,
    pub m_ramTextUpdateRate: i32,
    pub m_audioModuleState: crate::Tayx::Graphy::GraphyManager_ModuleState,
    pub m_findAudioListenerInCameraIfNull: crate::Tayx::Graphy::GraphyManager_LookForAudioListener,
    pub m_audioListener: quest_hook::libil2cpp::Gc<crate::UnityEngine::AudioListener>,
    pub m_audioGraphColor: crate::UnityEngine::Color,
    pub m_audioGraphResolution: i32,
    pub m_audioTextUpdateRate: i32,
    pub m_FFTWindow: crate::UnityEngine::FFTWindow,
    pub m_spectrumSize: i32,
    pub m_advancedModulePosition: crate::Tayx::Graphy::GraphyManager_ModulePosition,
    pub m_advancedModuleState: crate::Tayx::Graphy::GraphyManager_ModuleState,
    pub m_initialized: bool,
    pub m_active: bool,
    pub m_focused: bool,
    pub m_fpsManager: quest_hook::libil2cpp::Gc<crate::Tayx::Graphy::Fps::G_FpsManager>,
    pub m_ramManager: quest_hook::libil2cpp::Gc<crate::Tayx::Graphy::Ram::G_RamManager>,
    pub m_audioManager: quest_hook::libil2cpp::Gc<
        crate::Tayx::Graphy::Audio::G_AudioManager,
    >,
    pub m_advancedData: quest_hook::libil2cpp::Gc<
        crate::Tayx::Graphy::Advanced::G_AdvancedData,
    >,
    pub m_fpsMonitor: quest_hook::libil2cpp::Gc<crate::Tayx::Graphy::Fps::G_FpsMonitor>,
    pub m_ramMonitor: quest_hook::libil2cpp::Gc<crate::Tayx::Graphy::Ram::G_RamMonitor>,
    pub m_audioMonitor: quest_hook::libil2cpp::Gc<
        crate::Tayx::Graphy::Audio::G_AudioMonitor,
    >,
    pub m_modulePresetState: crate::Tayx::Graphy::GraphyManager_ModulePreset,
}
#[cfg(feature = "Tayx+Graphy+GraphyManager")]
unsafe impl quest_hook::libil2cpp::Type for crate::Tayx::Graphy::GraphyManager {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "Tayx.Graphy";
    const CLASS_NAME: &'static str = "GraphyManager";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager")]
impl std::ops::Deref for crate::Tayx::Graphy::GraphyManager {
    type Target = crate::Tayx::Graphy::Utils::G_Singleton_1<
        quest_hook::libil2cpp::Gc<crate::Tayx::Graphy::GraphyManager>,
    >;
    fn deref(&self) -> &Self::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager")]
impl std::ops::DerefMut for crate::Tayx::Graphy::GraphyManager {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager")]
impl crate::Tayx::Graphy::GraphyManager {
    #[cfg(feature = "Tayx+Graphy+GraphyManager+LookForAudioListener")]
    pub type LookForAudioListener = crate::Tayx::Graphy::GraphyManager_LookForAudioListener;
    #[cfg(feature = "Tayx+Graphy+GraphyManager+Mode")]
    pub type Mode = crate::Tayx::Graphy::GraphyManager_Mode;
    #[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePosition")]
    pub type ModulePosition = crate::Tayx::Graphy::GraphyManager_ModulePosition;
    #[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePreset")]
    pub type ModulePreset = crate::Tayx::Graphy::GraphyManager_ModulePreset;
    #[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleState")]
    pub type ModuleState = crate::Tayx::Graphy::GraphyManager_ModuleState;
    #[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleType")]
    pub type ModuleType = crate::Tayx::Graphy::GraphyManager_ModuleType;
    pub fn CheckFor1KeyPress(
        &mut self,
        key: crate::UnityEngine::InputSystem::Key,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::InputSystem::Key),
                bool,
                1usize,
            >("CheckFor1KeyPress")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "CheckFor1KeyPress", 1usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked(self, (key))? };
        Ok(__cordl_ret.into())
    }
    pub fn CheckFor2KeyPress(
        &mut self,
        key1: crate::UnityEngine::InputSystem::Key,
        key2: crate::UnityEngine::InputSystem::Key,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    crate::UnityEngine::InputSystem::Key,
                    crate::UnityEngine::InputSystem::Key,
                ),
                bool,
                2usize,
            >("CheckFor2KeyPress")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "CheckFor2KeyPress", 2usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked(self, (key1, key2))? };
        Ok(__cordl_ret.into())
    }
    pub fn CheckFor3KeyPress(
        &mut self,
        key1: crate::UnityEngine::InputSystem::Key,
        key2: crate::UnityEngine::InputSystem::Key,
        key3: crate::UnityEngine::InputSystem::Key,
    ) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    crate::UnityEngine::InputSystem::Key,
                    crate::UnityEngine::InputSystem::Key,
                    crate::UnityEngine::InputSystem::Key,
                ),
                bool,
                3usize,
            >("CheckFor3KeyPress")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "CheckFor3KeyPress", 3usize
                )
            });
        let __cordl_ret: bool = unsafe {
            method.invoke_unchecked(self, (key1, key2, key3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn CheckForHotkeyPresses(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                quest_hook::libil2cpp::Void,
                0usize,
            >("CheckForHotkeyPresses")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "CheckForHotkeyPresses", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Disable(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("Disable")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "Disable", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Enable(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("Enable")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "Enable", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Init(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("Init")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "Init", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn OnApplicationFocus(
        &mut self,
        isFocused: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (bool),
                quest_hook::libil2cpp::Void,
                1usize,
            >("OnApplicationFocus")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "OnApplicationFocus", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (isFocused))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn OnDestroy(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("OnDestroy")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "OnDestroy", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn RefreshAllParameters(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                quest_hook::libil2cpp::Void,
                0usize,
            >("RefreshAllParameters")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "RefreshAllParameters", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetModuleMode(
        &mut self,
        moduleType: crate::Tayx::Graphy::GraphyManager_ModuleType,
        moduleState: crate::Tayx::Graphy::GraphyManager_ModuleState,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    crate::Tayx::Graphy::GraphyManager_ModuleType,
                    crate::Tayx::Graphy::GraphyManager_ModuleState,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("SetModuleMode")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "SetModuleMode", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (moduleType, moduleState))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetModulePosition(
        &mut self,
        moduleType: crate::Tayx::Graphy::GraphyManager_ModuleType,
        modulePosition: crate::Tayx::Graphy::GraphyManager_ModulePosition,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (
                    crate::Tayx::Graphy::GraphyManager_ModuleType,
                    crate::Tayx::Graphy::GraphyManager_ModulePosition,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("SetModulePosition")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "SetModulePosition", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (moduleType, modulePosition))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn SetPreset(
        &mut self,
        modulePreset: crate::Tayx::Graphy::GraphyManager_ModulePreset,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_ModulePreset),
                quest_hook::libil2cpp::Void,
                1usize,
            >("SetPreset")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "SetPreset", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (modulePreset))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Start(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("Start")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "Start", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ToggleActive(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("ToggleActive")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "ToggleActive", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn ToggleModes(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("ToggleModes")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "ToggleModes", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn Update(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>("Update")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "Update", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn UpdateAllParameters(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                quest_hook::libil2cpp::Void,
                0usize,
            >("UpdateAllParameters")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "UpdateAllParameters", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), ".ctor", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_AdvancedModulePosition(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        crate::Tayx::Graphy::GraphyManager_ModulePosition,
    > {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::Tayx::Graphy::GraphyManager_ModulePosition,
                0usize,
            >("get_AdvancedModulePosition")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AdvancedModulePosition", 0usize
                )
            });
        let __cordl_ret: crate::Tayx::Graphy::GraphyManager_ModulePosition = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_AdvancedModuleState(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::Tayx::Graphy::GraphyManager_ModuleState> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::Tayx::Graphy::GraphyManager_ModuleState,
                0usize,
            >("get_AdvancedModuleState")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AdvancedModuleState", 0usize
                )
            });
        let __cordl_ret: crate::Tayx::Graphy::GraphyManager_ModuleState = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_AllocatedRam(&mut self) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), f32, 0usize>("get_AllocatedRam")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AllocatedRam", 0usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_AllocatedRamColor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Color> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::UnityEngine::Color,
                0usize,
            >("get_AllocatedRamColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AllocatedRamColor", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Color = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_AudioGraphColor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Color> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), crate::UnityEngine::Color, 0usize>("get_AudioGraphColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AudioGraphColor", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Color = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_AudioGraphResolution(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_AudioGraphResolution")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AudioGraphResolution", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_AudioListener(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<crate::UnityEngine::AudioListener>,
    > {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                quest_hook::libil2cpp::Gc<crate::UnityEngine::AudioListener>,
                0usize,
            >("get_AudioListener")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AudioListener", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<crate::UnityEngine::AudioListener> = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_AudioModuleState(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::Tayx::Graphy::GraphyManager_ModuleState> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::Tayx::Graphy::GraphyManager_ModuleState,
                0usize,
            >("get_AudioModuleState")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AudioModuleState", 0usize
                )
            });
        let __cordl_ret: crate::Tayx::Graphy::GraphyManager_ModuleState = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_AudioTextUpdateRate(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_AudioTextUpdateRate")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AudioTextUpdateRate", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_AverageFPS(&mut self) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), f32, 0usize>("get_AverageFPS")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_AverageFPS", 0usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_Background(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), bool, 0usize>("get_Background")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_Background", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_BackgroundColor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Color> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), crate::UnityEngine::Color, 0usize>("get_BackgroundColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_BackgroundColor", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Color = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_CautionFPSColor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Color> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), crate::UnityEngine::Color, 0usize>("get_CautionFPSColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_CautionFPSColor", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Color = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_CautionFPSThreshold(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_CautionFPSThreshold")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_CautionFPSThreshold", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_CriticalFPSColor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Color> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), crate::UnityEngine::Color, 0usize>("get_CriticalFPSColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_CriticalFPSColor", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Color = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_CurrentFPS(&mut self) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), f32, 0usize>("get_CurrentFPS")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_CurrentFPS", 0usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_EnableOnStartup(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), bool, 0usize>("get_EnableOnStartup")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_EnableOnStartup", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_FftWindow(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::FFTWindow> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), crate::UnityEngine::FFTWindow, 0usize>("get_FftWindow")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_FftWindow", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::FFTWindow = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_FindAudioListenerInCameraIfNull(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        crate::Tayx::Graphy::GraphyManager_LookForAudioListener,
    > {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::Tayx::Graphy::GraphyManager_LookForAudioListener,
                0usize,
            >("get_FindAudioListenerInCameraIfNull")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_FindAudioListenerInCameraIfNull", 0usize
                )
            });
        let __cordl_ret: crate::Tayx::Graphy::GraphyManager_LookForAudioListener = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_FpsGraphResolution(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_FpsGraphResolution")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_FpsGraphResolution", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_FpsModuleState(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::Tayx::Graphy::GraphyManager_ModuleState> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::Tayx::Graphy::GraphyManager_ModuleState,
                0usize,
            >("get_FpsModuleState")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_FpsModuleState", 0usize
                )
            });
        let __cordl_ret: crate::Tayx::Graphy::GraphyManager_ModuleState = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_FpsTextUpdateRate(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_FpsTextUpdateRate")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_FpsTextUpdateRate", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_GoodFPSColor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Color> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), crate::UnityEngine::Color, 0usize>("get_GoodFPSColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_GoodFPSColor", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Color = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_GoodFPSThreshold(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_GoodFPSThreshold")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_GoodFPSThreshold", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_GraphModulePosition(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        crate::Tayx::Graphy::GraphyManager_ModulePosition,
    > {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::Tayx::Graphy::GraphyManager_ModulePosition,
                0usize,
            >("get_GraphModulePosition")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_GraphModulePosition", 0usize
                )
            });
        let __cordl_ret: crate::Tayx::Graphy::GraphyManager_ModulePosition = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_GraphyMode(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::Tayx::Graphy::GraphyManager_Mode> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::Tayx::Graphy::GraphyManager_Mode,
                0usize,
            >("get_GraphyMode")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_GraphyMode", 0usize
                )
            });
        let __cordl_ret: crate::Tayx::Graphy::GraphyManager_Mode = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_KeepAlive(&mut self) -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), bool, 0usize>("get_KeepAlive")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_KeepAlive", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_MaxDB(&mut self) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), f32, 0usize>("get_MaxDB")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_MaxDB", 0usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_MaxFPS(&mut self) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), f32, 0usize>("get_MaxFPS")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_MaxFPS", 0usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_MinFPS(&mut self) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), f32, 0usize>("get_MinFPS")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_MinFPS", 0usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_MonoRam(&mut self) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), f32, 0usize>("get_MonoRam")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_MonoRam", 0usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_MonoRamColor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Color> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), crate::UnityEngine::Color, 0usize>("get_MonoRamColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_MonoRamColor", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Color = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_RamGraphResolution(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_RamGraphResolution")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_RamGraphResolution", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_RamModuleState(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::Tayx::Graphy::GraphyManager_ModuleState> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                crate::Tayx::Graphy::GraphyManager_ModuleState,
                0usize,
            >("get_RamModuleState")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_RamModuleState", 0usize
                )
            });
        let __cordl_ret: crate::Tayx::Graphy::GraphyManager_ModuleState = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_RamTextUpdateRate(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_RamTextUpdateRate")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_RamTextUpdateRate", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_ReservedRam(&mut self) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), f32, 0usize>("get_ReservedRam")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_ReservedRam", 0usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_ReservedRamColor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<crate::UnityEngine::Color> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), crate::UnityEngine::Color, 0usize>("get_ReservedRamColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_ReservedRamColor", 0usize
                )
            });
        let __cordl_ret: crate::UnityEngine::Color = unsafe {
            method.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_Spectrum(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<
        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<f32>>,
    > {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (),
                quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppArray<f32>>,
                0usize,
            >("get_Spectrum")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_Spectrum", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Gc<
            quest_hook::libil2cpp::Il2CppArray<f32>,
        > = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_SpectrumSize(&mut self) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), i32, 0usize>("get_SpectrumSize")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "get_SpectrumSize", 0usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn set_AdvancedModulePosition(
        &mut self,
        value: crate::Tayx::Graphy::GraphyManager_ModulePosition,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_ModulePosition),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_AdvancedModulePosition")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_AdvancedModulePosition", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_AdvancedModuleState(
        &mut self,
        value: crate::Tayx::Graphy::GraphyManager_ModuleState,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_ModuleState),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_AdvancedModuleState")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_AdvancedModuleState", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_AllocatedRamColor(
        &mut self,
        value: crate::UnityEngine::Color,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Color),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_AllocatedRamColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_AllocatedRamColor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_AudioGraphColor(
        &mut self,
        value: crate::UnityEngine::Color,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Color),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_AudioGraphColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_AudioGraphColor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_AudioGraphResolution(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_AudioGraphResolution")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_AudioGraphResolution", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_AudioListener(
        &mut self,
        value: quest_hook::libil2cpp::Gc<crate::UnityEngine::AudioListener>,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (quest_hook::libil2cpp::Gc<crate::UnityEngine::AudioListener>),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_AudioListener")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_AudioListener", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_AudioModuleState(
        &mut self,
        value: crate::Tayx::Graphy::GraphyManager_ModuleState,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_ModuleState),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_AudioModuleState")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_AudioModuleState", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_AudioTextUpdateRate(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_AudioTextUpdateRate")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_AudioTextUpdateRate", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_Background(
        &mut self,
        value: bool,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<(bool), quest_hook::libil2cpp::Void, 1usize>("set_Background")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_Background", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_BackgroundColor(
        &mut self,
        value: crate::UnityEngine::Color,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Color),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_BackgroundColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_BackgroundColor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_CautionFPSColor(
        &mut self,
        value: crate::UnityEngine::Color,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Color),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_CautionFPSColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_CautionFPSColor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_CautionFPSThreshold(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_CautionFPSThreshold")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_CautionFPSThreshold", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_CriticalFPSColor(
        &mut self,
        value: crate::UnityEngine::Color,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Color),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_CriticalFPSColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_CriticalFPSColor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_FftWindow(
        &mut self,
        value: crate::UnityEngine::FFTWindow,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::FFTWindow),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_FftWindow")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_FftWindow", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_FindAudioListenerInCameraIfNull(
        &mut self,
        value: crate::Tayx::Graphy::GraphyManager_LookForAudioListener,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_LookForAudioListener),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_FindAudioListenerInCameraIfNull")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_FindAudioListenerInCameraIfNull", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_FpsGraphResolution(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_FpsGraphResolution")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_FpsGraphResolution", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_FpsModuleState(
        &mut self,
        value: crate::Tayx::Graphy::GraphyManager_ModuleState,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_ModuleState),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_FpsModuleState")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_FpsModuleState", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_FpsTextUpdateRate(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_FpsTextUpdateRate")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_FpsTextUpdateRate", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_GoodFPSColor(
        &mut self,
        value: crate::UnityEngine::Color,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Color),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_GoodFPSColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_GoodFPSColor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_GoodFPSThreshold(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_GoodFPSThreshold")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_GoodFPSThreshold", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_GraphModulePosition(
        &mut self,
        value: crate::Tayx::Graphy::GraphyManager_ModulePosition,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_ModulePosition),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_GraphModulePosition")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_GraphModulePosition", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_GraphyMode(
        &mut self,
        value: crate::Tayx::Graphy::GraphyManager_Mode,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_Mode),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_GraphyMode")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_GraphyMode", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_MonoRamColor(
        &mut self,
        value: crate::UnityEngine::Color,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Color),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_MonoRamColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_MonoRamColor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_RamGraphResolution(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_RamGraphResolution")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_RamGraphResolution", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_RamModuleState(
        &mut self,
        value: crate::Tayx::Graphy::GraphyManager_ModuleState,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::Tayx::Graphy::GraphyManager_ModuleState),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_RamModuleState")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_RamModuleState", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_RamTextUpdateRate(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_RamTextUpdateRate")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_RamTextUpdateRate", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_ReservedRamColor(
        &mut self,
        value: crate::UnityEngine::Color,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (crate::UnityEngine::Color),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_ReservedRamColor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_ReservedRamColor", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn set_SpectrumSize(
        &mut self,
        value: i32,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <crate::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type>::class()
            .find_method::<
                (i32),
                quest_hook::libil2cpp::Void,
                1usize,
            >("set_SpectrumSize")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}", <
                    crate ::Tayx::Graphy::GraphyManager as quest_hook::libil2cpp::Type >
                    ::class(), "set_SpectrumSize", 1usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, (value))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager")]
impl quest_hook::libil2cpp::ObjectType for crate::Tayx::Graphy::GraphyManager {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+LookForAudioListener")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum GraphyManager_LookForAudioListener {
    #[default]
    ALWAYS = 0i32,
    NEVER = 2i32,
    ON_SCENE_LOAD = 1i32,
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+LookForAudioListener")]
unsafe impl quest_hook::libil2cpp::Type
for crate::Tayx::Graphy::GraphyManager_LookForAudioListener {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "Tayx.Graphy";
    const CLASS_NAME: &'static str = "GraphyManager/LookForAudioListener";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+LookForAudioListener")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::Tayx::Graphy::GraphyManager_LookForAudioListener {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+LookForAudioListener")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::Tayx::Graphy::GraphyManager_LookForAudioListener {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+LookForAudioListener")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::Tayx::Graphy::GraphyManager_LookForAudioListener {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+LookForAudioListener")]
unsafe impl quest_hook::libil2cpp::Return
for crate::Tayx::Graphy::GraphyManager_LookForAudioListener {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+Mode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum GraphyManager_Mode {
    #[default]
    FULL = 0i32,
    LIGHT = 1i32,
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+Mode")]
unsafe impl quest_hook::libil2cpp::Type for crate::Tayx::Graphy::GraphyManager_Mode {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "Tayx.Graphy";
    const CLASS_NAME: &'static str = "GraphyManager/Mode";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+Mode")]
unsafe impl quest_hook::libil2cpp::Argument for crate::Tayx::Graphy::GraphyManager_Mode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+Mode")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::Tayx::Graphy::GraphyManager_Mode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+Mode")]
unsafe impl quest_hook::libil2cpp::Returned for crate::Tayx::Graphy::GraphyManager_Mode {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+Mode")]
unsafe impl quest_hook::libil2cpp::Return for crate::Tayx::Graphy::GraphyManager_Mode {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePosition")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum GraphyManager_ModulePosition {
    #[default]
    BOTTOM_LEFT = 3i32,
    BOTTOM_RIGHT = 2i32,
    FREE = 4i32,
    TOP_LEFT = 1i32,
    TOP_RIGHT = 0i32,
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePosition")]
unsafe impl quest_hook::libil2cpp::Type
for crate::Tayx::Graphy::GraphyManager_ModulePosition {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "Tayx.Graphy";
    const CLASS_NAME: &'static str = "GraphyManager/ModulePosition";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePosition")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::Tayx::Graphy::GraphyManager_ModulePosition {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePosition")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::Tayx::Graphy::GraphyManager_ModulePosition {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePosition")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::Tayx::Graphy::GraphyManager_ModulePosition {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePosition")]
unsafe impl quest_hook::libil2cpp::Return
for crate::Tayx::Graphy::GraphyManager_ModulePosition {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePreset")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum GraphyManager_ModulePreset {
    #[default]
    FPS_BASIC = 0i32,
    FPS_BASIC_ADVANCED_FULL = 11i32,
    FPS_FULL = 2i32,
    FPS_FULL_RAM_FULL = 5i32,
    FPS_FULL_RAM_FULL_AUDIO_FULL = 9i32,
    FPS_FULL_RAM_FULL_AUDIO_FULL_ADVANCED_FULL = 10i32,
    FPS_FULL_RAM_FULL_AUDIO_TEXT = 8i32,
    FPS_FULL_RAM_TEXT = 4i32,
    FPS_FULL_RAM_TEXT_AUDIO_TEXT = 7i32,
    FPS_TEXT = 1i32,
    FPS_TEXT_RAM_TEXT = 3i32,
    FPS_TEXT_RAM_TEXT_AUDIO_TEXT = 6i32,
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePreset")]
unsafe impl quest_hook::libil2cpp::Type
for crate::Tayx::Graphy::GraphyManager_ModulePreset {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "Tayx.Graphy";
    const CLASS_NAME: &'static str = "GraphyManager/ModulePreset";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePreset")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::Tayx::Graphy::GraphyManager_ModulePreset {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePreset")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::Tayx::Graphy::GraphyManager_ModulePreset {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePreset")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::Tayx::Graphy::GraphyManager_ModulePreset {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModulePreset")]
unsafe impl quest_hook::libil2cpp::Return
for crate::Tayx::Graphy::GraphyManager_ModulePreset {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleState")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum GraphyManager_ModuleState {
    #[default]
    BACKGROUND = 3i32,
    BASIC = 2i32,
    FULL = 0i32,
    OFF = 4i32,
    TEXT = 1i32,
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleState")]
unsafe impl quest_hook::libil2cpp::Type
for crate::Tayx::Graphy::GraphyManager_ModuleState {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "Tayx.Graphy";
    const CLASS_NAME: &'static str = "GraphyManager/ModuleState";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleState")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::Tayx::Graphy::GraphyManager_ModuleState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleState")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::Tayx::Graphy::GraphyManager_ModuleState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleState")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::Tayx::Graphy::GraphyManager_ModuleState {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleState")]
unsafe impl quest_hook::libil2cpp::Return
for crate::Tayx::Graphy::GraphyManager_ModuleState {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum GraphyManager_ModuleType {
    #[default]
    ADVANCED = 3i32,
    AUDIO = 2i32,
    FPS = 0i32,
    RAM = 1i32,
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleType")]
unsafe impl quest_hook::libil2cpp::Type
for crate::Tayx::Graphy::GraphyManager_ModuleType {
    type Held<'a> = Self;
    type HeldRaw = Self;
    const NAMESPACE: &'static str = "Tayx.Graphy";
    const CLASS_NAME: &'static str = "GraphyManager/ModuleType";
    fn matches_value_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && ty
                .class()
                .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        !ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.is_ref()
            && <Self as quest_hook::libil2cpp::Type>::class()
                .is_assignable_from(ty.class())
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleType")]
unsafe impl quest_hook::libil2cpp::Argument
for crate::Tayx::Graphy::GraphyManager_ModuleType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_argument(ty)
    }
    fn invokable(&mut self) -> *mut ::std::ffi::c_void {
        self as *mut Self as *mut ::std::ffi::c_void
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleType")]
unsafe impl quest_hook::libil2cpp::Parameter
for crate::Tayx::Graphy::GraphyManager_ModuleType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_value_parameter(ty)
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleType")]
unsafe impl quest_hook::libil2cpp::Returned
for crate::Tayx::Graphy::GraphyManager_ModuleType {
    type Type = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_returned(ty)
    }
    fn from_object(object: Option<&mut quest_hook::libil2cpp::Il2CppObject>) -> Self {
        unsafe {
            quest_hook::libil2cpp::raw::unbox(
                quest_hook::libil2cpp::WrapRaw::raw(object.unwrap()),
            )
        }
    }
}
#[cfg(feature = "Tayx+Graphy+GraphyManager+ModuleType")]
unsafe impl quest_hook::libil2cpp::Return
for crate::Tayx::Graphy::GraphyManager_ModuleType {
    type Actual = Self;
    fn matches(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::matches_return(ty)
    }
    fn into_actual(self) -> Self::Actual {
        self
    }
    fn from_actual(actual: Self::Actual) -> Self {
        actual
    }
}
