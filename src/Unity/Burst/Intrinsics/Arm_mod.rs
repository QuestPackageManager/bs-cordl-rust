#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
#[repr(C)]
#[derive(Debug)]
pub struct Arm {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
unsafe impl quest_hook::libil2cpp::Type for crate::Unity::Burst::Intrinsics::Arm {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "Unity.Burst.Intrinsics";
    const CLASS_NAME: &'static str = "Arm";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl std::ops::Deref for crate::Unity::Burst::Intrinsics::Arm {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl std::ops::DerefMut for crate::Unity::Burst::Intrinsics::Arm {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl crate::Unity::Burst::Intrinsics::Arm {
    #[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
    pub type Neon = crate::Unity::Burst::Intrinsics::Arm_Neon;
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl quest_hook::libil2cpp::ObjectType for crate::Unity::Burst::Intrinsics::Arm {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
#[repr(C)]
#[derive(Debug)]
pub struct Arm_Neon {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
unsafe impl quest_hook::libil2cpp::Type for crate::Unity::Burst::Intrinsics::Arm_Neon {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "Unity.Burst.Intrinsics";
    const CLASS_NAME: &'static str = "Arm/Neon";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl std::ops::Deref for crate::Unity::Burst::Intrinsics::Arm_Neon {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl std::ops::DerefMut for crate::Unity::Burst::Intrinsics::Arm_Neon {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl crate::Unity::Burst::Intrinsics::Arm_Neon {
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn __crc32b(a0: u32, a1: u8) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u8), u32, 2usize>("__crc32b")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "__crc32b", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cb(a0: u32, a1: u8) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u8), u32, 2usize>("__crc32cb")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "__crc32cb", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cd(a0: u32, a1: u64) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u64), u32, 2usize>("__crc32cd")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "__crc32cd", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32ch(a0: u32, a1: u16) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u16), u32, 2usize>("__crc32ch")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "__crc32ch", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cw(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u32), u32, 2usize>("__crc32cw")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "__crc32cw", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32d(a0: u32, a1: u64) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u64), u32, 2usize>("__crc32d")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "__crc32d", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32h(a0: u32, a1: u16) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u16), u32, 2usize>("__crc32h")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "__crc32h", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32w(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u32), u32, 2usize>("__crc32w")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "__crc32w", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), ".ctor",
                            0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked(self, ())?
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonArmv82FeaturesSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (),
                        bool,
                        0usize,
                    >("get_IsNeonArmv82FeaturesSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_IsNeonArmv82FeaturesSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonCryptoSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonCryptoSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_IsNeonCryptoSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonDotProdSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonDotProdSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_IsNeonDotProdSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonRDMASupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonRDMASupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_IsNeonRDMASupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "get_IsNeonSupported", 0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vaba_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaba_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vaba_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaba_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vaba_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vaba_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vaba_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaba_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vaba_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaba_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vaba_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vaba_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_high_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_high_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_high_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_high_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabal_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabal_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabaq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabaq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabaq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabaq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabaq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabaq_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabaq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabaq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabaq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabaq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vabaq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabaq_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vabd_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabd_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vabd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vabd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabd_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vabd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabd_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vabd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vabd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vabd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabd_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vabd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabd_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vabd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vabd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), f64, 2usize>("vabdd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_high_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_high_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_high_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_high_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdl_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vabdq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabdq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabds_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), f32, 2usize>("vabds_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabds_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vabs_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i64, 1usize>("vabsd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vadd_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vadd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vadd_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vadd_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vadd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vadd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vadd_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vadd_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vadd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vadd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vaddd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vaddd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vaddhn_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vaddhn_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vaddhn_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_high_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vaddhn_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_high_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vaddhn_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_high_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vaddhn_high_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_high_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vaddhn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vaddhn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vaddhn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vaddhn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vaddhn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vaddhn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddhn_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_high_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_high_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_high_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_high_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddl_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i32,
                        1usize,
                    >("vaddlv_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlv_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i64,
                        1usize,
                    >("vaddlv_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlv_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i16,
                        1usize,
                    >("vaddlv_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlv_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u32,
                        1usize,
                    >("vaddlv_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlv_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u64,
                        1usize,
                    >("vaddlv_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlv_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u16,
                        1usize,
                    >("vaddlv_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlv_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i32,
                        1usize,
                    >("vaddlvq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlvq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i64,
                        1usize,
                    >("vaddlvq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlvq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i16,
                        1usize,
                    >("vaddlvq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlvq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u32,
                        1usize,
                    >("vaddlvq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlvq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u64,
                        1usize,
                    >("vaddlvq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlvq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u16,
                        1usize,
                    >("vaddlvq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddlvq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vaddv_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddv_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i16,
                        1usize,
                    >("vaddv_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddv_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i32,
                        1usize,
                    >("vaddv_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddv_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i8,
                        1usize,
                    >("vaddv_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddv_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u16,
                        1usize,
                    >("vaddv_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddv_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u32,
                        1usize,
                    >("vaddv_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddv_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u8,
                        1usize,
                    >("vaddv_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddv_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f32,
                        1usize,
                    >("vaddvq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vaddvq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i16,
                        1usize,
                    >("vaddvq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i32,
                        1usize,
                    >("vaddvq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i64,
                        1usize,
                    >("vaddvq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i8,
                        1usize,
                    >("vaddvq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u16,
                        1usize,
                    >("vaddvq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u32,
                        1usize,
                    >("vaddvq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u64,
                        1usize,
                    >("vaddvq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u8,
                        1usize,
                    >("vaddvq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddvq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_high_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_high_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_high_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_high_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaddw_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaddw_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaesdq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaesdq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaesdq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaeseq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vaeseq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaeseq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaesimcq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vaesimcq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaesimcq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaesmcq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vaesmcq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaesmcq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vand_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vand_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vand_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vand_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vand_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vand_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vand_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vand_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vand_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vand_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vand_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vand_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vand_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vand_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vand_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vand_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vandq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vandq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vandq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vandq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vandq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vandq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vandq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vandq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vandq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vandq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vandq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vandq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vandq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vandq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vandq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vandq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vbic_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbic_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vbic_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbic_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vbic_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbic_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vbic_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vbic_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vbic_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbic_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vbic_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbic_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vbic_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbic_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vbic_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vbic_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vbicq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbicq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vbicq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbicq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vbicq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbicq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vbicq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbicq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vbicq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbicq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vbicq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbicq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vbicq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbicq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vbicq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbicq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbsl_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbsl_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbsl_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbsl_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbsl_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vbsl_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbsl_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbsl_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbsl_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vbsl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vbsl_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vbslq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vbslq_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcage_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcage_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcage_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcage_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcage_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcage_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaged_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcaged_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcaged_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcageq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcageq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcageq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcageq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcageq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcageq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcages_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcages_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcages_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcagt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcagt_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcagt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcagt_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcagtd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcagtd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcagtq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcagtq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcagtq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcagtq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcagts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcagts_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcale_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcale_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcale_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcale_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcale_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcale_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaled_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcaled_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcaled_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaleq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcaleq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcaleq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaleq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcaleq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcaleq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcales_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcales_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcales_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcalt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcalt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcalt_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcalt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcalt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcalt_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcaltd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcaltd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcaltq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcaltq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcaltq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcaltq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcalts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcalts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcalts_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vceq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vceq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vceq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vceqd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vceqd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vceqd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vceqq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqs_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vceqs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqs_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vceqzd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vceqzd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_u64(a0: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), u64, 1usize>("vceqzd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzd_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vceqzs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcge_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcge_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcge_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcge_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcge_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcge_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcge_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcge_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcge_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcge_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcge_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcged_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcged_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vcged_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcged_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vcged_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcged_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgeq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgeq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcges_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcges_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcges_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcgezd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vcgezd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcgezs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgt_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgt_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgt_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgt_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgt_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcgt_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgt_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgt_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgt_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcgt_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcgt_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcgtd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vcgtd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vcgtd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcgtq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcgts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgts_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcgtzd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vcgtzd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcgtzs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcle_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcle_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcle_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcle_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcle_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcle_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcle_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcle_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcle_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcle_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcle_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcled_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcled_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vcled_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcled_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vcled_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcled_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcleq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcleq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcles_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcles_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcles_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vclezd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vclezd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vclezs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcls_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcls_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcls_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcls_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcls_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclsq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclsq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclsq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclsq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclsq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclsq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclt_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclt_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclt_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclt_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclt_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vclt_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclt_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclt_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclt_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vclt_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vclt_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcltd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vcltd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vcltd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcltq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vclts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclts_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcltzd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vcltzd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcltzs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclz_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclz_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vclz_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclz_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclz_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vclz_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcnt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcnt_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcnt_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcnt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcnt_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcnt_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcntq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcntq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcntq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcntq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcntq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcntq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_f16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_f16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcombine_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcombine_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_s64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_s8", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_u64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_lane_u8", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_s64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_s8", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_u64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vcopy_laneq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopy_laneq_u8", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_s64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_s8", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_u64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_lane_u8", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_s64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_s8", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_u64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vcopyq_laneq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcopyq_laneq_u8", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_f16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_f16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s8(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u8(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcreate_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcreate_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f32_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f32_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f32_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f32_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvt_f64_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f64_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f64_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f64_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_high_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvt_high_f32_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_high_f32_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_high_f64_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvt_high_f64_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_high_f64_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_f32_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_f32_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_f64_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_f64_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_s32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_s64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_u32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_u64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvta_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvta_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvta_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvta_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvta_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvta_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvta_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvta_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtad_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtad_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtad_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtad_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtad_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtad_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtaq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtaq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtaq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtaq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtaq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtaq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtaq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtaq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtas_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvtas_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtas_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtas_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvtas_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtas_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_f64_s64(a0: i64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), f64, 1usize>("vcvtd_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtd_f64_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_f64_u64(a0: u64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), f64, 1usize>("vcvtd_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtd_f64_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_f64_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), f64, 2usize>("vcvtd_n_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtd_n_f64_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_f64_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), f64, 2usize>("vcvtd_n_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtd_n_f64_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_s64_f64(a0: f64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, i32), i64, 2usize>("vcvtd_n_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtd_n_s64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_u64_f64(a0: f64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, i32), u64, 2usize>("vcvtd_n_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtd_n_u64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtd_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtd_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtd_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtd_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtm_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtm_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtm_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtm_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtm_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtm_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtm_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtm_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtmd_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmd_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtmd_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmd_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtmq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtmq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtmq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtmq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtms_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvtms_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtms_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtms_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvtms_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtms_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtn_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtn_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtn_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtn_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtn_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtn_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtn_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtn_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtnd_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnd_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtnd_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnd_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtnq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtnq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtnq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtnq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtns_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvtns_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtns_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtns_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvtns_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtns_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtp_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtp_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtp_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtp_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtp_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtp_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtp_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtp_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtpd_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpd_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtpd_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpd_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtpq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtpq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtpq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtpq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtps_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvtps_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtps_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtps_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvtps_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtps_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_f32_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_f32_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_f64_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_f64_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_f32_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_f32_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_f64_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_f64_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_s32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_s64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_u32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_u64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_f32_s32(a0: i32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), f32, 1usize>("vcvts_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvts_f32_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_f32_u32(a0: u32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), f32, 1usize>("vcvts_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvts_f32_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_f32_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), f32, 2usize>("vcvts_n_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvts_n_f32_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_f32_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), f32, 2usize>("vcvts_n_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvts_n_f32_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_s32_f32(a0: f32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, i32), i32, 2usize>("vcvts_n_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvts_n_s32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_u32_f32(a0: f32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, i32), u32, 2usize>("vcvts_n_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvts_n_u32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvts_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvts_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvts_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvts_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtx_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtx_f32_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtx_f32_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtx_high_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtx_high_f32_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtx_high_f32_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtxd_f32_f64(a0: f64) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), f32, 1usize>("vcvtxd_f32_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtxd_f32_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdiv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdiv_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdiv_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdiv_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdiv_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdiv_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdivq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdivq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdivq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdivq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdivq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdivq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vdot_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdot_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vdot_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdot_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vdot_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdot_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vdot_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdot_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vdot_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdot_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vdot_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdot_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vdotq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdotq_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vdotq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdotq_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vdotq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdotq_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vdotq_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdotq_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vdotq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdotq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vdotq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdotq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i8),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u16),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u8),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vdup_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_n_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        i8,
                        2usize,
                    >("vdupb_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupb_lane_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        u8,
                        2usize,
                    >("vdupb_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupb_lane_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i8,
                        2usize,
                    >("vdupb_laneq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupb_laneq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u8,
                        2usize,
                    >("vdupb_laneq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupb_laneq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        2usize,
                    >("vdupd_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_lane_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        i64,
                        2usize,
                    >("vdupd_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_lane_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        u64,
                        2usize,
                    >("vdupd_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_lane_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        2usize,
                    >("vdupd_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_laneq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        2usize,
                    >("vdupd_laneq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_laneq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u64,
                        2usize,
                    >("vdupd_laneq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_laneq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        2usize,
                    >("vduph_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vduph_lane_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        u16,
                        2usize,
                    >("vduph_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vduph_lane_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        2usize,
                    >("vduph_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vduph_laneq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u16,
                        2usize,
                    >("vduph_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vduph_laneq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i8),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u16),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u8),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vdupq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_n_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        2usize,
                    >("vdups_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_lane_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        2usize,
                    >("vdups_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_lane_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        u32,
                        2usize,
                    >("vdups_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_lane_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        2usize,
                    >("vdups_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_laneq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        2usize,
                    >("vdups_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_laneq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u32,
                        2usize,
                    >("vdups_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_laneq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("veor_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veor_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("veor_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veor_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("veor_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veor_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("veor_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "veor_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("veor_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veor_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("veor_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veor_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("veor_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veor_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("veor_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "veor_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("veorq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veorq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("veorq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veorq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("veorq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veorq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("veorq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veorq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("veorq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veorq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("veorq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veorq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("veorq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veorq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("veorq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "veorq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vext_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vext_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vext_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vext_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vext_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vext_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vext_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vext_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vext_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vext_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vext_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vextq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vextq_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vfma_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfma_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vfma_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfma_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vfma_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfma_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vfma_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfma_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vfma_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfma_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vfma_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfma_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            f32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vfma_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfma_n_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            f64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vfma_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfma_n_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmad_lane_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        4usize,
                    >("vfmad_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmad_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmad_laneq_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        4usize,
                    >("vfmad_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmad_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vfmaq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmaq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vfmaq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmaq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vfmaq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmaq_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vfmaq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmaq_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vfmaq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmaq_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vfmaq_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmaq_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            f32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vfmaq_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmaq_n_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            f64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vfmaq_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmaq_n_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmas_lane_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        4usize,
                    >("vfmas_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmas_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmas_laneq_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        4usize,
                    >("vfmas_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmas_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vfms_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfms_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vfms_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfms_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vfms_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfms_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vfms_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfms_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vfms_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfms_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vfms_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfms_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            f32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vfms_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfms_n_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            f64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vfms_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfms_n_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsd_lane_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        4usize,
                    >("vfmsd_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsd_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsd_laneq_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        4usize,
                    >("vfmsd_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsd_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vfmsq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vfmsq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vfmsq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsq_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vfmsq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsq_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vfmsq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsq_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vfmsq_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsq_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            f32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vfmsq_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsq_n_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            f64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vfmsq_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsq_n_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmss_lane_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        4usize,
                    >("vfmss_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmss_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmss_laneq_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        4usize,
                    >("vfmss_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmss_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        2usize,
                    >("vget_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        2usize,
                    >("vget_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        2usize,
                    >("vget_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        2usize,
                    >("vget_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        i64,
                        2usize,
                    >("vget_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        i8,
                        2usize,
                    >("vget_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        u16,
                        2usize,
                    >("vget_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        u32,
                        2usize,
                    >("vget_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        u64,
                        2usize,
                    >("vget_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        u8,
                        2usize,
                    >("vget_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_lane_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        2usize,
                    >("vgetq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        2usize,
                    >("vgetq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        2usize,
                    >("vgetq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        2usize,
                    >("vgetq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        2usize,
                    >("vgetq_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i8,
                        2usize,
                    >("vgetq_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u16,
                        2usize,
                    >("vgetq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u32,
                        2usize,
                    >("vgetq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u64,
                        2usize,
                    >("vgetq_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u8,
                        2usize,
                    >("vgetq_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhadd_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhadd_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhadd_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhadd_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhadd_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhadd_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhaddq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhaddq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhaddq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhaddq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhaddq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhaddq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhaddq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhaddq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhaddq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhaddq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhaddq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhaddq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhsub_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsub_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhsub_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsub_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhsub_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsub_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhsub_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsub_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhsub_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsub_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vhsub_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsub_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhsubq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsubq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhsubq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsubq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhsubq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsubq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhsubq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsubq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhsubq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsubq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vhsubq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vhsubq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vld1_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vld1_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmax_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmax_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmax_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmax_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmax_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmax_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmax_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmax_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmax_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmax_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmax_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmax_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmax_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmax_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmax_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmax_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmaxnm_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxnm_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmaxnm_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxnm_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxnmq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxnmq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxnmq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxnmq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vmaxnmv_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxnmv_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f32,
                        1usize,
                    >("vmaxnmvq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxnmvq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vmaxnmvq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxnmvq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmaxq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vmaxv_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxv_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i16,
                        1usize,
                    >("vmaxv_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxv_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i32,
                        1usize,
                    >("vmaxv_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxv_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i8,
                        1usize,
                    >("vmaxv_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxv_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u16,
                        1usize,
                    >("vmaxv_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxv_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u32,
                        1usize,
                    >("vmaxv_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxv_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u8,
                        1usize,
                    >("vmaxv_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxv_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f32,
                        1usize,
                    >("vmaxvq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxvq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vmaxvq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxvq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i16,
                        1usize,
                    >("vmaxvq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxvq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i32,
                        1usize,
                    >("vmaxvq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxvq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i8,
                        1usize,
                    >("vmaxvq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxvq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u16,
                        1usize,
                    >("vmaxvq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxvq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u32,
                        1usize,
                    >("vmaxvq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxvq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u8,
                        1usize,
                    >("vmaxvq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmaxvq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmin_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmin_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmin_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmin_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmin_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmin_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmin_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmin_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmin_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmin_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmin_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmin_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmin_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmin_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmin_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmin_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vminnm_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminnm_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vminnm_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminnm_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminnmq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminnmq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminnmq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminnmq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vminnmv_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminnmv_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f32,
                        1usize,
                    >("vminnmvq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminnmvq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vminnmvq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminnmvq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vminq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vminv_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminv_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i16,
                        1usize,
                    >("vminv_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminv_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i32,
                        1usize,
                    >("vminv_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminv_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        i8,
                        1usize,
                    >("vminv_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminv_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u16,
                        1usize,
                    >("vminv_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminv_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u32,
                        1usize,
                    >("vminv_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminv_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        u8,
                        1usize,
                    >("vminv_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminv_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f32,
                        1usize,
                    >("vminvq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminvq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vminvq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminvq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i16,
                        1usize,
                    >("vminvq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminvq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i32,
                        1usize,
                    >("vminvq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminvq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i8,
                        1usize,
                    >("vminvq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminvq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u16,
                        1usize,
                    >("vminvq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminvq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u32,
                        1usize,
                    >("vminvq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminvq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u8,
                        1usize,
                    >("vminvq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vminvq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmla_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            f32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_n_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            u16,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            u32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmla_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmla_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmla_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmla_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_high_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_high_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_high_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_high_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_high_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_high_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_high_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_high_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            u16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            u32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_high_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlal_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            u16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            u32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlal_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlal_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlaq_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            f32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_n_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            u16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            u32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlaq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlaq_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vmls_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            f32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_n_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            u16,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            u32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmls_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmls_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmls_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmls_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_high_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_high_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_high_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_high_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_high_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_high_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_high_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_high_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            u16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            u32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_high_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsl_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            u16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            u32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsl_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_lane_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_lane_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_laneq_u16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vmlsq_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_laneq_u32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            f32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_n_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            u16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            u32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmlsq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmlsq_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i8),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u16),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u8),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmov_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmov_n_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmovn_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmovn_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmovn_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_high_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmovn_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_high_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmovn_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_high_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmovn_high_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_high_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i8),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u16),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u8),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovq_n_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_lane_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_lane_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_laneq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_laneq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_laneq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmul_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_laneq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, f32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, f64),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, u16),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, u32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmul_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmul_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmuld_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        3usize,
                    >("vmuld_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmuld_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmuld_laneq_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        3usize,
                    >("vmuld_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmuld_laneq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_high_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_high_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_high_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_lane_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_high_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_lane_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_high_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_high_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_high_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_laneq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_high_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_laneq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, u16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, u32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_lane_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_lane_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_laneq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmull_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_laneq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, u16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, u32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_lane_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_lane_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_laneq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_laneq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_laneq_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulq_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_laneq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, f32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, f64),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, u16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, u32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmuls_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        3usize,
                    >("vmuls_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmuls_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmuls_laneq_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        3usize,
                    >("vmuls_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmuls_laneq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmulx_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulx_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmulx_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulx_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmulx_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulx_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmulx_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulx_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmulx_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulx_laneq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vmulx_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulx_laneq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), f64, 2usize>("vmulxd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        3usize,
                    >("vmulxd_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxd_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_laneq_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        3usize,
                    >("vmulxd_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxd_laneq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulxq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulxq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulxq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxq_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulxq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxq_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulxq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxq_laneq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vmulxq_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxq_laneq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), f32, 2usize>("vmulxs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxs_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        3usize,
                    >("vmulxs_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxs_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_laneq_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        3usize,
                    >("vmulxs_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxs_laneq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvn_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvn_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmvn_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvn_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvn_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmvn_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vneg_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i64, 1usize>("vnegd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorn_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorn_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorn_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorn_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vorn_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorn_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorn_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorn_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorn_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vorn_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vornq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vornq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vornq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vornq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vornq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vornq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vornq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vornq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vornq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vornq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vornq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vornq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vornq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vornq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vornq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vornq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorr_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorr_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorr_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorr_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorr_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorr_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorr_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vorr_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorr_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorr_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorr_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorr_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorr_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorr_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vorr_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vorr_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vorrq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorrq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vorrq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorrq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vorrq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorrq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vorrq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorrq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vorrq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorrq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vorrq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorrq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vorrq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorrq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vorrq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vorrq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadal_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadal_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadal_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadal_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadal_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadal_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadal_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadal_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadal_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadal_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadal_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadal_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpadalq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadalq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpadalq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadalq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpadalq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadalq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpadalq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadalq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpadalq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadalq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpadalq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadalq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadd_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadd_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadd_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadd_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadd_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadd_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadd_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadd_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vpaddd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        i64,
                        1usize,
                    >("vpaddd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        u64,
                        1usize,
                    >("vpaddd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddd_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpaddq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadds_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vpadds_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpadds_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmax_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmax_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmax_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmax_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmax_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmax_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmax_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmax_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmax_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmax_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmax_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmax_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmax_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmax_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmaxnm_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxnm_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxnmq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxnmq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxnmq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxnmq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vpmaxnmqd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxnmqd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vpmaxnms_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxnms_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpmaxq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vpmaxqd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxqd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxs_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vpmaxs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmaxs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmin_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmin_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmin_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmin_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmin_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmin_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmin_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmin_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmin_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmin_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmin_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmin_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpmin_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmin_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vpminnm_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminnm_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminnmq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminnmq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminnmq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminnmq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vpminnmqd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminnmqd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vpminnms_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminnms_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vpminq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        f64,
                        1usize,
                    >("vpminqd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpminqd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmins_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        f32,
                        1usize,
                    >("vpmins_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpmins_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqabs_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabs_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqabs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabs_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqabs_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabs_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqabs_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabs_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsb_s8(a0: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8), i8, 1usize>("vqabsb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsb_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i64, 1usize>("vqabsd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), i16, 1usize>("vqabsh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsh_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqabsq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqabsq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqabsq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqabsq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabss_s32(a0: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), i32, 1usize>("vqabss_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabss_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadd_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadd_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqadd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadd_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadd_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadd_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqadd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadd_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i8), i8, 2usize>("vqaddb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddb_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddb_u8(a0: u8, a1: u8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, u8), u8, 2usize>("vqaddb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddb_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vqaddd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vqaddd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqaddh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddh_u16(a0: u16, a1: u16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, u16), u16, 2usize>("vqaddh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddh_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqaddq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqaddq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqaddq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqaddq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqaddq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqaddq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqaddq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqaddq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqaddq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadds_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqadds_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadds_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadds_u32(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u32), u32, 2usize>("vqadds_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqadds_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlal_high_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_high_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlal_high_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_high_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlal_high_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_high_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlal_high_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_high_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlal_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlal_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlal_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlal_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlal_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlal_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlal_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlal_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlal_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlal_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlal_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlal_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlal_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_lane_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        4usize,
                    >("vqdmlalh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlalh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_laneq_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        4usize,
                    >("vqdmlalh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlalh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_s16(
        a0: i32,
        a1: i16,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i16, i16), i32, 3usize>("vqdmlalh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlalh_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_lane_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i64,
                        4usize,
                    >("vqdmlals_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlals_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_laneq_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        4usize,
                    >("vqdmlals_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlals_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_s32(
        a0: i64,
        a1: i32,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32, i32), i64, 3usize>("vqdmlals_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlals_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlsl_high_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_high_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlsl_high_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_high_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlsl_high_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_high_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlsl_high_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_high_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlsl_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlsl_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlsl_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlsl_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlsl_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlsl_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlsl_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqdmlsl_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i16,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlsl_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlsl_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlsl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmlsl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsl_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_lane_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        4usize,
                    >("vqdmlslh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlslh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_laneq_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        4usize,
                    >("vqdmlslh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlslh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_s16(
        a0: i32,
        a1: i16,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i16, i16), i32, 3usize>("vqdmlslh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlslh_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_lane_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i64,
                        4usize,
                    >("vqdmlsls_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsls_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_laneq_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        4usize,
                    >("vqdmlsls_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsls_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_s32(
        a0: i64,
        a1: i32,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32, i32), i64, 3usize>("vqdmlsls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsls_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqdmulh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqdmulh_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqdmulh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqdmulh_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqdmulh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqdmulh_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqdmulh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqdmulh_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        3usize,
                    >("vqdmulhh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhh_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        3usize,
                    >("vqdmulhh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhh_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqdmulhh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmulhq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmulhq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmulhq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmulhq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmulhq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmulhq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmulhq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmulhq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        3usize,
                    >("vqdmulhs_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhs_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        3usize,
                    >("vqdmulhs_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhs_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqdmulhs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhs_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmull_high_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmull_high_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmull_high_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmull_high_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmull_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmull_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmull_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqdmull_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        3usize,
                    >("vqdmullh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmullh_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        3usize,
                    >("vqdmullh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmullh_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i32, 2usize>("vqdmullh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmullh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i64,
                        3usize,
                    >("vqdmulls_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulls_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        3usize,
                    >("vqdmulls_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulls_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i64, 2usize>("vqdmulls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulls_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovn_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovn_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovn_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_high_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovn_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_high_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovn_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_high_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovn_high_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_high_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i32, 1usize>("vqmovnd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovnd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnd_u64(a0: u64) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), u32, 1usize>("vqmovnd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovnd_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), i8, 1usize>("vqmovnh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovnh_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnh_u16(a0: u16) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16), u8, 1usize>("vqmovnh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovnh_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovns_s32(a0: i32) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), i16, 1usize>("vqmovns_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovns_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovns_u32(a0: u32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), u16, 1usize>("vqmovns_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovns_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovun_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovun_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqmovun_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_high_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovun_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovun_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovun_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovund_s64(a0: i64) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u32, 1usize>("vqmovund_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovund_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovunh_s16(a0: i16) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), u8, 1usize>("vqmovunh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovunh_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovuns_s32(a0: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), u16, 1usize>("vqmovuns_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovuns_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqneg_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqneg_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqneg_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqneg_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqneg_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqneg_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqneg_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqneg_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegb_s8(a0: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8), i8, 1usize>("vqnegb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegb_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i64, 1usize>("vqnegd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegd_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), i16, 1usize>("vqnegh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegh_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqnegq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqnegq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqnegq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqnegq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegs_s32(a0: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), i32, 1usize>("vqnegs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegs_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vqrdmlah_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlah_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vqrdmlah_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlah_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vqrdmlah_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlah_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vqrdmlah_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlah_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqrdmlah_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlah_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqrdmlah_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlah_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_lane_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        4usize,
                    >("vqrdmlahh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_laneq_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        4usize,
                    >("vqrdmlahh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_s16(
        a0: i16,
        a1: i16,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16, i16), i16, 3usize>("vqrdmlahh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahh_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqrdmlahq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahq_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqrdmlahq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahq_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqrdmlahq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahq_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqrdmlahq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahq_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrdmlahq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrdmlahq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahs_lane_s32(
        a0: i32,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        4usize,
                    >("vqrdmlahs_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahs_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahs_s32(
        a0: i32,
        a1: i32,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32, i32), i32, 3usize>("vqrdmlahs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahs_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vqrdmlsh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlsh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vqrdmlsh_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlsh_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vqrdmlsh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlsh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        4usize,
                    >("vqrdmlsh_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlsh_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqrdmlsh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlsh_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqrdmlsh_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlsh_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_lane_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        4usize,
                    >("vqrdmlshh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_laneq_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        4usize,
                    >("vqrdmlshh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_s16(
        a0: i16,
        a1: i16,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16, i16), i16, 3usize>("vqrdmlshh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshh_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqrdmlshq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshq_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqrdmlshq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshq_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqrdmlshq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshq_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        4usize,
                    >("vqrdmlshq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshq_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrdmlshq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrdmlshq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshs_lane_s32(
        a0: i32,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        4usize,
                    >("vqrdmlshs_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshs_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshs_s32(
        a0: i32,
        a1: i32,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32, i32), i32, 3usize>("vqrdmlshs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshs_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqrdmulh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqrdmulh_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqrdmulh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqrdmulh_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrdmulh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrdmulh_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrdmulh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrdmulh_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        3usize,
                    >("vqrdmulhh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhh_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        3usize,
                    >("vqrdmulhh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhh_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqrdmulhh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrdmulhq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrdmulhq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrdmulhq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrdmulhq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrdmulhq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrdmulhq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrdmulhq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrdmulhq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        3usize,
                    >("vqrdmulhs_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhs_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        3usize,
                    >("vqrdmulhs_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhs_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqrdmulhs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhs_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshl_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshl_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshl_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshl_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshl_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshl_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshl_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshl_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i8), i8, 2usize>("vqrshlb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlb_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, i8), u8, 2usize>("vqrshlb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlb_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vqrshld_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshld_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vqrshld_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshld_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqrshlh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i16), u16, 2usize>("vqrshlh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlh_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrshlq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrshlq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrshlq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrshlq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrshlq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrshlq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrshlq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrshlq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshlq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqrshls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshls_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshls_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u32, 2usize>("vqrshls_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshls_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrn_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrn_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrn_high_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_high_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrn_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_high_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrn_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_high_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrn_high_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_high_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i32, 2usize>("vqrshrnd_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrnd_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u32, 2usize>("vqrshrnd_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrnd_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), i8, 2usize>("vqrshrnh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrnh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i32), u8, 2usize>("vqrshrnh_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrnh_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i16, 2usize>("vqrshrns_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrns_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrns_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u16, 2usize>("vqrshrns_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrns_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrun_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrun_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqrshrun_high_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_high_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrun_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrun_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrun_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrund_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), u32, 2usize>("vqrshrund_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrund_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrunh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), u8, 2usize>("vqrshrunh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrunh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshruns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), u16, 2usize>("vqrshruns_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshruns_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_n_s8(a0: i8, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i32), i8, 2usize>("vqshlb_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlb_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_n_u8(a0: u8, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, i32), u8, 2usize>("vqshlb_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlb_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i8), i8, 2usize>("vqshlb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlb_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, i8), u8, 2usize>("vqshlb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlb_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i64, 2usize>("vqshld_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshld_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u64, 2usize>("vqshld_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshld_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vqshld_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshld_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vqshld_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshld_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), i16, 2usize>("vqshlh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i32), u16, 2usize>("vqshlh_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlh_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqshlh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i16), u16, 2usize>("vqshlh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlh_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqshls_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshls_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u32, 2usize>("vqshls_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshls_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqshls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshls_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u32, 2usize>("vqshls_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshls_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshlu_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlu_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshlu_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlu_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshlu_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlu_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshlu_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlu_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlub_n_s8(a0: i8, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i32), u8, 2usize>("vqshlub_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlub_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlud_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), u64, 2usize>("vqshlud_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlud_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), u16, 2usize>("vqshluh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshluq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshluq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshluq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshluq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlus_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), u32, 2usize>("vqshlus_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlus_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrn_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrn_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrn_high_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_high_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrn_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_high_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrn_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_high_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrn_high_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_high_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i32, 2usize>("vqshrnd_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrnd_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u32, 2usize>("vqshrnd_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrnd_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), i8, 2usize>("vqshrnh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrnh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i32), u8, 2usize>("vqshrnh_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrnh_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i16, 2usize>("vqshrns_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrns_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrns_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u16, 2usize>("vqshrns_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrns_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrun_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrun_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqshrun_high_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_high_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrun_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrun_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrun_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrund_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), u32, 2usize>("vqshrund_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrund_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrunh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), u8, 2usize>("vqshrunh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrunh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshruns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), u16, 2usize>("vqshruns_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshruns_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqsub_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsub_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqsub_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsub_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqsub_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsub_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqsub_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsub_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqsub_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsub_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqsub_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsub_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqsub_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsub_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqsub_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsub_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i8), i8, 2usize>("vqsubb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubb_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubb_u8(a0: u8, a1: u8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, u8), u8, 2usize>("vqsubb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubb_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vqsubd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vqsubd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqsubh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubh_u16(a0: u16, a1: u16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, u16), u16, 2usize>("vqsubh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubh_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqsubq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqsubq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqsubq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqsubq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqsubq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqsubq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqsubq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqsubq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqsubs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubs_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubs_u32(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u32), u32, 2usize>("vqsubs_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqsubs_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqtbl1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqtbl1_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqtbl1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqtbl1_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqtbl1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqtbl1q_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqtbl1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqtbl1q_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqtbx1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqtbx1_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vqtbx1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqtbx1_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqtbx1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqtbx1q_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vqtbx1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqtbx1q_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vraddhn_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vraddhn_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vraddhn_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_high_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vraddhn_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_high_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vraddhn_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_high_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vraddhn_high_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_high_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vraddhn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vraddhn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vraddhn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vraddhn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vraddhn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vraddhn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vraddhn_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrbit_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrbit_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrbit_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrbit_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrbit_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrbit_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrbitq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrbitq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrbitq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrbitq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrbitq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrbitq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrecpe_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpe_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrecpe_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpe_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrecpe_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpe_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecped_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), f64, 1usize>("vrecped_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecped_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrecpeq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpeq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrecpeq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpeq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrecpeq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpeq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpes_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), f32, 1usize>("vrecpes_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpes_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecps_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrecps_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecps_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecps_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrecps_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecps_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), f64, 2usize>("vrecpsd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpsd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrecpsq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpsq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrecpsq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpsq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpss_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), f32, 2usize>("vrecpss_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpss_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpxd_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), f64, 1usize>("vrecpxd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpxd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpxs_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), f32, 1usize>("vrecpxs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpxs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev16_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev16_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev16_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev16_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev16q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev16q_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev16q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev16q_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev32_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev32_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev32_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev32_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev32q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32q_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev32q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32q_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev32q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32q_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev32q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32q_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrhadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhadd_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrhadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhadd_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrhadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhadd_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrhadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhadd_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrhadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhadd_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrhadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhadd_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrhaddq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhaddq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrhaddq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhaddq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrhaddq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhaddq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrhaddq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhaddq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrhaddq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhaddq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrhaddq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrhaddq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrnd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrnd_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrnd_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrnd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrnd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrnd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrnda_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrnda_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrnda_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrnda_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrnda_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrnda_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndaq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndaq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndaq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndaq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndi_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndi_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndi_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndi_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndi_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndi_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndiq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndiq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndiq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndiq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndiq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndiq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndm_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndm_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndm_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndm_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndmq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndmq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndmq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndmq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndn_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndn_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndn_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndn_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndn_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndn_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndnq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndnq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndnq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndnq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndnq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndnq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndns_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), f32, 1usize>("vrndns_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndns_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndp_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndp_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndp_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndp_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndp_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndp_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndpq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndpq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndpq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndpq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndpq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndpq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndx_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndx_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndx_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndx_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndx_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndx_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndxq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndxq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndxq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndxq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshl_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshl_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshl_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshl_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshl_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshl_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshl_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshl_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vrshld_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshld_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vrshld_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshld_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshlq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshlq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshlq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshlq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshlq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshlq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshlq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshlq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshlq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshlq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshlq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshlq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshlq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshlq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshlq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshlq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i64, 2usize>("vrshrd_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrd_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u64, 2usize>("vrshrd_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrd_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrshrn_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrshrn_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrshrn_high_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_high_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrshrn_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_high_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrshrn_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_high_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrshrn_high_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_high_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrsqrte_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrte_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrsqrte_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrte_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrsqrte_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrte_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrted_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), f64, 1usize>("vrsqrted_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrted_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrsqrteq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrteq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrsqrteq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrteq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrsqrteq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrteq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtes_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), f32, 1usize>("vrsqrtes_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrtes_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrts_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrsqrts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrts_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrts_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrsqrts_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrts_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), f64, 2usize>("vrsqrtsd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrtsd_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrsqrtsq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrtsq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrsqrtsq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrtsq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtss_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), f32, 2usize>("vrsqrtss_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrtss_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vrsra_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsra_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vrsra_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsra_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vrsra_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsra_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vrsra_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsra_n_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vrsra_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsra_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vrsra_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsra_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vrsra_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsra_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vrsra_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsra_n_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsrad_n_s64(
        a0: i64,
        a1: i64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64, i32), i64, 3usize>("vrsrad_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsrad_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsrad_n_u64(
        a0: u64,
        a1: u64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64, i32), u64, 3usize>("vrsrad_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsrad_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsraq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsraq_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsraq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsraq_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsraq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsraq_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsraq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsraq_n_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsraq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsraq_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsraq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsraq_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsraq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsraq_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsraq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsraq_n_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsubhn_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsubhn_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsubhn_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_high_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsubhn_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_high_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsubhn_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_high_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vrsubhn_high_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_high_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrsubhn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrsubhn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrsubhn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrsubhn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrsubhn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrsubhn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsubhn_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s64(
        a0: i64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s8(
        a0: i8,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i8, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u16(
        a0: u16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u16, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u32(
        a0: u32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u64(
        a0: u64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u8(
        a0: u8,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u8, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s64(
        a0: i64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s8(
        a0: i8,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i8, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u16(
        a0: u16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u16, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u32(
        a0: u32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u64(
        a0: u64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u8(
        a0: u8,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u8, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1cq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            u32,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsha1cq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha1cq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1h_u32(a0: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), u32, 1usize>("vsha1h_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha1h_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1mq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            u32,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsha1mq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha1mq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1pq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            u32,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsha1pq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha1pq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1su0q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsha1su0q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha1su0q_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1su1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsha1su1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha1su1q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256h2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsha256h2q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha256h2q_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256hq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsha256hq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha256hq_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256su0q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsha256su0q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha256su0q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256su1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsha256su1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsha256su1q_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vshl_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vshl_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i64, 2usize>("vshld_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshld_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u64, 2usize>("vshld_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshld_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vshld_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshld_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vshld_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshld_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i64, 2usize>("vshrd_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrd_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u64, 2usize>("vshrd_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrd_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vshrn_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_high_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vshrn_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_high_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vshrn_high_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_high_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vshrn_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_high_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vshrn_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_high_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vshrn_high_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_high_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsli_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsli_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsli_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsli_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsli_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsli_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsli_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsli_n_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsli_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsli_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsli_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsli_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsli_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsli_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsli_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsli_n_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vslid_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64, i32), i64, 3usize>("vslid_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vslid_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vslid_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64, i32), u64, 3usize>("vslid_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vslid_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsliq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsliq_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsliq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsliq_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsliq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsliq_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsliq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsliq_n_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsliq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsliq_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsliq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsliq_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsliq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsliq_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsliq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsliq_n_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsqadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqadd_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsqadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqadd_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsqadd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqadd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsqadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqadd_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, i8), u8, 2usize>("vsqaddb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqaddb_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddd_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vsqaddd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqaddd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i16), u16, 2usize>("vsqaddh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqaddh_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsqaddq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqaddq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsqaddq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqaddq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsqaddq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqaddq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsqaddq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqaddq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadds_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u32, 2usize>("vsqadds_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqadds_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vsqrt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqrt_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vsqrt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqrt_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vsqrtq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqrtq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vsqrtq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqrtq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsra_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsra_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsra_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsra_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsra_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsra_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsra_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsra_n_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsra_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsra_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsra_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsra_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsra_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsra_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsra_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsra_n_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsrad_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64, i32), i64, 3usize>("vsrad_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsrad_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsrad_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64, i32), u64, 3usize>("vsrad_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsrad_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsraq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsraq_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsraq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsraq_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsraq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsraq_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsraq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsraq_n_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsraq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsraq_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsraq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsraq_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsraq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsraq_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsraq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsraq_n_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsri_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsri_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsri_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsri_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsri_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsri_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsri_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsri_n_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsri_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsri_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsri_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsri_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsri_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsri_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vsri_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsri_n_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsrid_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64, i32), i64, 3usize>("vsrid_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsrid_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsrid_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64, i32), u64, 3usize>("vsrid_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsrid_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsriq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsriq_n_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsriq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsriq_n_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsriq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsriq_n_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsriq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsriq_n_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsriq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsriq_n_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsriq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsriq_n_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsriq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsriq_n_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                            i32,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsriq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsriq_n_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vst1_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vst1_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            quest_hook::libil2cpp::Gc<
                                quest_hook::libil2cpp::Il2CppObject,
                            >,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        quest_hook::libil2cpp::Void,
                        2usize,
                    >("vst1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vst1q_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsub_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsub_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsub_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsub_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsub_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vsub_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsub_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsub_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsub_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsub_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vsub_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vsubd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vsubd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsubhn_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_high_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsubhn_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_high_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsubhn_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_high_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsubhn_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_high_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsubhn_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_high_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsubhn_high_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_high_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsubhn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsubhn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsubhn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsubhn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsubhn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vsubhn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubhn_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_high_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_high_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_high_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_high_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubl_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_high_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_high_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_high_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_high_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_high_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_high_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vsubw_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsubw_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtbl1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtbl1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtbl1_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtbl1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtbl1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtbl1_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtbx1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vtbx1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtbx1_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtbx1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vtbx1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtbx1_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1, a2))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn1q_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn2_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn2_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn2_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn2_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn2_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn2_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtrn2_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtrn2q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtrn2q_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtst_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtst_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtst_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtst_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtst_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtst_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtst_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vtst_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtst_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtst_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtst_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtst_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtst_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtst_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vtst_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vtst_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vtstd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vtstd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstd_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtstq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtstq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtstq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtstq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtstq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtstq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtstq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vtstq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vtstq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuqadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqadd_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuqadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqadd_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuqadd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqadd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuqadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqadd_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddb_s8(a0: i8, a1: u8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, u8), i8, 2usize>("vuqaddb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqaddb_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddd_s64(a0: i64, a1: u64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, u64), i64, 2usize>("vuqaddd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqaddd_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddh_s16(a0: i16, a1: u16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, u16), i16, 2usize>("vuqaddh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqaddh_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuqaddq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqaddq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuqaddq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqaddq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuqaddq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqaddq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuqaddq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqaddq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadds_s32(a0: i32, a1: u32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, u32), i32, 2usize>("vuqadds_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuqadds_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp1q_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp2_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp2_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp2_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp2_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp2_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp2_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vuzp2_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vuzp2q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vuzp2q_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip1q_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip2_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip2_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip2_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip2_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip2_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip2_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v64,
                            crate::Unity::Burst::Intrinsics::v64,
                        ),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vzip2_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> = std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo = METHOD
            .get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (
                            crate::Unity::Burst::Intrinsics::v128,
                            crate::Unity::Burst::Intrinsics::v128,
                        ),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vzip2q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vzip2q_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            cordl_method_info.invoke_unchecked((), (a0, a1))?
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl quest_hook::libil2cpp::ObjectType for crate::Unity::Burst::Intrinsics::Arm_Neon {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
