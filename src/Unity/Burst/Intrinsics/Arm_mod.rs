#[cfg(feature = "cordl_class_Unity+Burst+Intrinsics+Arm")]
#[repr(C)]
#[cfg_attr(feature = "derive_Debug", derive(Debug))]
pub struct Arm {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_Unity+Burst+Intrinsics+Arm")]
unsafe impl quest_hook::libil2cpp::Type for crate::Unity::Burst::Intrinsics::Arm {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "Unity.Burst.Intrinsics";
    const CLASS_NAME: &'static str = "Arm";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class()
            .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl std::ops::Deref for crate::Unity::Burst::Intrinsics::Arm {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl std::ops::DerefMut for crate::Unity::Burst::Intrinsics::Arm {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl crate::Unity::Burst::Intrinsics::Arm {
    #[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
    pub type Neon = crate::Unity::Burst::Intrinsics::Arm_Neon;
}
#[cfg(feature = "cordl_class_Unity+Burst+Intrinsics+Arm")]
impl quest_hook::libil2cpp::ObjectType for crate::Unity::Burst::Intrinsics::Arm {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "cordl_class_Unity+Burst+Intrinsics+Arm+Neon")]
#[repr(C)]
#[cfg_attr(feature = "derive_Debug", derive(Debug))]
pub struct Arm_Neon {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "cordl_class_Unity+Burst+Intrinsics+Arm+Neon")]
unsafe impl quest_hook::libil2cpp::Type for crate::Unity::Burst::Intrinsics::Arm_Neon {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "Unity.Burst.Intrinsics";
    const CLASS_NAME: &'static str = "Arm/Neon";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class()
            .is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl std::ops::Deref for crate::Unity::Burst::Intrinsics::Arm_Neon {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &<Self as std::ops::Deref>::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl std::ops::DerefMut for crate::Unity::Burst::Intrinsics::Arm_Neon {
    fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl crate::Unity::Burst::Intrinsics::Arm_Neon {
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self =
            <Self as quest_hook::libil2cpp::Type>::class().instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn __crc32b(a0: u32, a1: u8) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u8), u32, 2usize>("__crc32b")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "__crc32b",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cb(a0: u32, a1: u8) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u8), u32, 2usize>("__crc32cb")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "__crc32cb",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cd(a0: u32, a1: u64) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u64), u32, 2usize>("__crc32cd")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "__crc32cd",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32ch(a0: u32, a1: u16) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u16), u32, 2usize>("__crc32ch")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "__crc32ch",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cw(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u32), u32, 2usize>("__crc32cw")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "__crc32cw",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32d(a0: u32, a1: u64) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u64), u32, 2usize>("__crc32d")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "__crc32d",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32h(a0: u32, a1: u16) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u16), u32, 2usize>("__crc32h")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "__crc32h",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32w(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u32), u32, 2usize>("__crc32w")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "__crc32w",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(&mut self) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            ".ctor",
                            0usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked(self, ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonArmv82FeaturesSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonArmv82FeaturesSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "get_IsNeonArmv82FeaturesSupported",
                            0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonCryptoSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonCryptoSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "get_IsNeonCryptoSupported",
                            0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonDotProdSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonDotProdSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "get_IsNeonDotProdSupported",
                            0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonRDMASupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonRDMASupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "get_IsNeonRDMASupported",
                            0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonSupported() -> quest_hook::libil2cpp::Result<bool> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(), bool, 0usize>("get_IsNeonSupported")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "get_IsNeonSupported",
                            0usize
                        )
                    })
            });
        let __cordl_ret: bool = unsafe { cordl_method_info.invoke_unchecked((), ())? };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vaba_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaba_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vaba_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaba_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vaba_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaba_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vaba_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaba_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vaba_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaba_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vaba_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaba_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_high_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_high_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_high_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_high_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vabal_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabal_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vabal_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabal_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabaq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabaq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabaq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabaq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vabaq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabaq_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabaq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabaq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vabaq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabaq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vabaq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabaq_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vabd_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabd_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vabd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vabd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabd_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vabd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabd_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vabd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vabd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabd_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vabd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabd_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vabd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), f64, 2usize>("vabdd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_high_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_high_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_high_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_high_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vabdl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdl_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vabdl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdl_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vabdq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vabdq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vabdq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabdq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabds_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), f32, 2usize>("vabds_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabds_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabs_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vabs_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vabs_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabsd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i64, 1usize>("vabsd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vabsd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vabsq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vabsq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vadd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vaddd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vaddd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vaddhn_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vaddhn_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vaddhn_high_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_high_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vaddhn_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_high_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vaddhn_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_high_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vaddhn_high_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_high_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vaddhn_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vaddhn_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vaddhn_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vaddhn_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vaddhn_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vaddhn_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddhn_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_high_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_high_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_high_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_high_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vaddl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddl_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vaddl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddl_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i32, 1usize>(
                        "vaddlv_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlv_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i64, 1usize>(
                        "vaddlv_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlv_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i16, 1usize>(
                        "vaddlv_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlv_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u32, 1usize>(
                        "vaddlv_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlv_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u64, 1usize>(
                        "vaddlv_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlv_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u16, 1usize>(
                        "vaddlv_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlv_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i32, 1usize>(
                        "vaddlvq_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlvq_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i64, 1usize>(
                        "vaddlvq_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlvq_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i16, 1usize>(
                        "vaddlvq_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlvq_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u32, 1usize>(
                        "vaddlvq_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlvq_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u64, 1usize>(
                        "vaddlvq_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlvq_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u16, 1usize>(
                        "vaddlvq_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddlvq_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vaddq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vaddq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vaddv_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddv_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i16, 1usize>(
                        "vaddv_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddv_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i32, 1usize>(
                        "vaddv_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddv_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s8(a0: crate::Unity::Burst::Intrinsics::v64) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i8, 1usize>(
                        "vaddv_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddv_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u16, 1usize>(
                        "vaddv_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddv_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u32, 1usize>(
                        "vaddv_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddv_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u8(a0: crate::Unity::Burst::Intrinsics::v64) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u8, 1usize>(
                        "vaddv_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddv_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f32, 1usize>(
                        "vaddvq_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vaddvq_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i16, 1usize>(
                        "vaddvq_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i32, 1usize>(
                        "vaddvq_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i64, 1usize>(
                        "vaddvq_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i8, 1usize>(
                        "vaddvq_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u16, 1usize>(
                        "vaddvq_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u32, 1usize>(
                        "vaddvq_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u64, 1usize>(
                        "vaddvq_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u8, 1usize>(
                        "vaddvq_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddvq_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_high_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_high_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_high_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_high_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vaddw_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaddw_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vaddw_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaddw_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaesdq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaesdq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaesdq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaeseq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vaeseq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vaeseq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaesimcq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vaesimcq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaesimcq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vaesmcq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vaesmcq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vaesmcq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vand_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vand_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vand_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vand_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vand_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vand_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vand_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vand_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vand_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vand_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vand_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vand_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vand_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vand_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vand_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vand_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vandq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vandq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vandq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vandq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vandq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vandq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vandq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vandq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vandq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vandq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vandq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vandq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vandq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vandq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vandq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vandq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vbic_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbic_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vbic_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbic_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vbic_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbic_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vbic_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbic_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vbic_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbic_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vbic_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbic_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vbic_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbic_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vbic_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbic_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vbicq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbicq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vbicq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbicq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vbicq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbicq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vbicq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbicq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vbicq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbicq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vbicq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbicq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vbicq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbicq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vbicq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbicq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vbsl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbsl_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vbslq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vbslq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vbslq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vbslq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vbslq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vbslq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vbslq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vbslq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vbslq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vbslq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vbslq_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcage_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcage_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcage_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcage_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcage_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcage_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcaged_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcaged_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcaged_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcageq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcageq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcageq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcageq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcageq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcageq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcages_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcages_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcages_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcagt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcagt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcagt_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcagt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcagt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcagt_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcagtd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcagtd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcagtq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcagtq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcagtq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcagtq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcagts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcagts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcagts_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcale_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcale_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcale_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcale_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcale_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcale_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcaled_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcaled_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcaled_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcaleq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcaleq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcaleq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcaleq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcaleq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcaleq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcales_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcales_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcales_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcalt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcalt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcalt_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcalt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcalt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcalt_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcaltd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcaltd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcaltq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcaltq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcaltq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcaltq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcalts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcalts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcalts_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vceq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vceqd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vceqd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vceqd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vceqq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vceqq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vceqq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vceqq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vceqq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vceqq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vceqq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vceqq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vceqq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vceqq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqs_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vceqs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqs_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vceqz_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqz_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vceqzd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqzd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vceqzd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqzd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_u64(a0: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), u64, 1usize>("vceqzd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqzd_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vceqzq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vceqzq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vceqzs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vceqzs_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcge_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcge_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcged_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcged_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vcged_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcged_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vcged_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcged_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgeq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgeq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgeq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgeq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgeq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vcgeq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgeq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgeq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgeq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vcgeq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgeq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcges_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcges_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcges_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgez_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgez_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcgezd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgezd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vcgezd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgezd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgezq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgezq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcgezs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgezs_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcgt_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgt_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcgtd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vcgtd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vcgtd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgtq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgtq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgtq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgtq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgtq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vcgtq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgtq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgtq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcgtq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vcgtq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcgts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgts_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcgtz_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtz_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcgtzd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtzd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vcgtzd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtzd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcgtzq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcgtzq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcgtzs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcgtzs_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vcle_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcle_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcled_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcled_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vcled_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcled_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vcled_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcled_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcleq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcleq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcleq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcleq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcleq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vcleq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcleq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcleq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcleq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vcleq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcleq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcles_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vcles_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcles_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclez_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclez_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vclezd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclezd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vclezd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclezd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclezq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclezq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclezs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vclezs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclezs_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcls_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcls_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcls_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcls_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcls_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclsq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclsq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclsq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclsq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclsq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclsq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vclt_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclt_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), u64, 2usize>("vcltd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vcltd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vcltd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcltq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcltq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcltq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcltq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcltq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vcltq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcltq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcltq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcltq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vcltq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), u32, 2usize>("vclts_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vclts_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcltz_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltz_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcltzd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltzd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u64, 1usize>("vcltzd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltzd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcltzq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcltzq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcltzs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcltzs_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclz_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclz_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vclz_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclz_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclz_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vclz_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vclz_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vclzq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vclzq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcnt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcnt_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcnt_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcnt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcnt_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vcnt_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcntq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcntq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcntq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcntq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcntq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcntq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_f16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_f16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcombine_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcombine_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_s64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_s8",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_u64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_lane_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_lane_u8",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_s64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_s8",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_u64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vcopy_laneq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopy_laneq_u8",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_s64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_s8",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_u64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_lane_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_lane_u8",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_s64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_s8",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_u64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vcopyq_laneq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcopyq_laneq_u8",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_f16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_f16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s8(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u8(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vcreate_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcreate_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f32_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f32_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f32_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f32_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvt_f64_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f64_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f64_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_f64_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_high_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcvt_high_f32_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvt_high_f32_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_high_f64_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvt_high_f64_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_high_f64_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_f32_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_f32_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_f64_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_f64_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_s32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_s64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_u32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vcvt_n_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_n_u64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvt_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvt_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvta_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvta_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvta_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvta_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvta_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvta_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvta_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvta_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtad_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtad_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtad_s64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtad_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtad_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtad_u64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtaq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtaq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtaq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtaq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtaq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtaq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtaq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtaq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtas_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvtas_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtas_s32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtas_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvtas_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtas_u32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_f64_s64(a0: i64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), f64, 1usize>("vcvtd_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtd_f64_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_f64_u64(a0: u64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), f64, 1usize>("vcvtd_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtd_f64_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_f64_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), f64, 2usize>("vcvtd_n_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtd_n_f64_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_f64_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), f64, 2usize>("vcvtd_n_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtd_n_f64_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_s64_f64(a0: f64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, i32), i64, 2usize>("vcvtd_n_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtd_n_s64_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_u64_f64(a0: f64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, i32), u64, 2usize>("vcvtd_n_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtd_n_u64_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtd_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtd_s64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtd_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtd_u64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtm_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtm_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtm_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtm_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtm_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtm_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtm_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtm_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtmd_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtmd_s64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtmd_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtmd_u64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtmq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtmq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtmq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtmq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtmq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtms_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvtms_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtms_s32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtms_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvtms_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtms_u32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtn_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtn_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtn_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtn_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtn_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtn_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtn_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtn_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtnd_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtnd_s64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtnd_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtnd_u64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtnq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtnq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtnq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtnq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtnq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtns_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvtns_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtns_s32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtns_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvtns_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtns_u32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtp_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtp_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtp_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtp_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtp_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtp_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtp_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtp_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), i64, 1usize>("vcvtpd_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtpd_s64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), u64, 1usize>("vcvtpd_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtpd_u64_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtpq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtpq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtpq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtpq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtpq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtps_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvtps_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtps_s32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtps_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvtps_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtps_u32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_f32_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_f32_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_f64_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_f64_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_f32_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_f32_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_f64_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_f64_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_f64_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_f64_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_s32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_s64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_u32_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vcvtq_n_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_n_u64_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_s32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_s64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_s64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_u32_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vcvtq_u64_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtq_u64_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_f32_s32(a0: i32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), f32, 1usize>("vcvts_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvts_f32_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_f32_u32(a0: u32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), f32, 1usize>("vcvts_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvts_f32_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_f32_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), f32, 2usize>("vcvts_n_f32_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvts_n_f32_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_f32_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), f32, 2usize>("vcvts_n_f32_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvts_n_f32_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_s32_f32(a0: f32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, i32), i32, 2usize>("vcvts_n_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvts_n_s32_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_u32_f32(a0: f32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, i32), u32, 2usize>("vcvts_n_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvts_n_u32_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), i32, 1usize>("vcvts_s32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvts_s32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), u32, 1usize>("vcvts_u32_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvts_u32_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtx_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vcvtx_f32_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vcvtx_f32_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtx_high_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vcvtx_high_f32_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtx_high_f32_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtxd_f32_f64(a0: f64) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), f32, 1usize>("vcvtxd_f32_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vcvtxd_f32_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdiv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vdiv_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdiv_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdiv_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vdiv_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdiv_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdivq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vdivq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdivq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdivq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vdivq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdivq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vdot_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdot_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vdot_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdot_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vdot_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdot_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vdot_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdot_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vdot_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdot_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vdot_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdot_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vdotq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdotq_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vdotq_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdotq_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vdotq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdotq_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vdotq_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdotq_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vdotq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdotq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vdotq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdotq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_lane_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vdup_laneq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdup_laneq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vdup_n_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdup_n_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), i8, 2usize>(
                        "vdupb_lane_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupb_lane_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), u8, 2usize>(
                        "vdupb_lane_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupb_lane_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128, i32), i8, 2usize>(
                        "vdupb_laneq_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupb_laneq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128, i32), u8, 2usize>(
                        "vdupb_laneq_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupb_laneq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), f64, 2usize>(
                        "vdupd_lane_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupd_lane_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), i64, 2usize>(
                        "vdupd_lane_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupd_lane_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), u64, 2usize>(
                        "vdupd_lane_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupd_lane_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        2usize,
                    >("vdupd_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_laneq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        2usize,
                    >("vdupd_laneq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_laneq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u64,
                        2usize,
                    >("vdupd_laneq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupd_laneq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), i16, 2usize>(
                        "vduph_lane_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vduph_lane_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), u16, 2usize>(
                        "vduph_lane_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vduph_lane_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        2usize,
                    >("vduph_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vduph_laneq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u16,
                        2usize,
                    >("vduph_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vduph_laneq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_lane_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vdupq_laneq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdupq_laneq_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vdupq_n_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdupq_n_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), f32, 2usize>(
                        "vdups_lane_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdups_lane_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), i32, 2usize>(
                        "vdups_lane_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdups_lane_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), u32, 2usize>(
                        "vdups_lane_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vdups_lane_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        2usize,
                    >("vdups_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_laneq_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        2usize,
                    >("vdups_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_laneq_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u32,
                        2usize,
                    >("vdups_laneq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vdups_laneq_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("veor_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veor_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("veor_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veor_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("veor_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veor_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("veor_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veor_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("veor_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veor_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("veor_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veor_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("veor_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veor_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("veor_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veor_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "veorq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veorq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "veorq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veorq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "veorq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veorq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("veorq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veorq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "veorq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veorq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "veorq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veorq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "veorq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veorq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("veorq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "veorq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vext_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vext_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vextq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vextq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vextq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vextq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vextq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vextq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vextq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vextq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vextq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vextq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vextq_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vfma_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfma_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vfma_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfma_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vfma_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfma_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vfma_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfma_lane_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vfma_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfma_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vfma_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfma_laneq_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        f32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vfma_n_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfma_n_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        f64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vfma_n_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfma_n_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmad_lane_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        4usize,
                    >("vfmad_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmad_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmad_laneq_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        4usize,
                    >("vfmad_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmad_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vfmaq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmaq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vfmaq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmaq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vfmaq_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmaq_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vfmaq_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmaq_lane_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vfmaq_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmaq_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vfmaq_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmaq_laneq_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        f32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vfmaq_n_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmaq_n_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        f64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vfmaq_n_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmaq_n_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmas_lane_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        4usize,
                    >("vfmas_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmas_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmas_laneq_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        4usize,
                    >("vfmas_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmas_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vfms_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfms_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vfms_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfms_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vfms_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfms_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vfms_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfms_lane_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vfms_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfms_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vfms_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfms_laneq_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        f32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vfms_n_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfms_n_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        f64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vfms_n_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfms_n_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsd_lane_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        4usize,
                    >("vfmsd_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsd_lane_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsd_laneq_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        4usize,
                    >("vfmsd_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmsd_laneq_f64", 4usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vfmsq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmsq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vfmsq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmsq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vfmsq_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmsq_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vfmsq_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmsq_lane_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vfmsq_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmsq_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vfmsq_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmsq_laneq_f64",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        f32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vfmsq_n_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmsq_n_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        f64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vfmsq_n_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vfmsq_n_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmss_lane_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        4usize,
                    >("vfmss_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmss_lane_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vfmss_laneq_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        4usize,
                    >("vfmss_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vfmss_laneq_f32", 4usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_high_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), f32, 2usize>(
                        "vget_lane_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), f64, 2usize>(
                        "vget_lane_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), i16, 2usize>(
                        "vget_lane_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), i32, 2usize>(
                        "vget_lane_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), i64, 2usize>(
                        "vget_lane_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), i8, 2usize>(
                        "vget_lane_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), u16, 2usize>(
                        "vget_lane_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), u32, 2usize>(
                        "vget_lane_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), u64, 2usize>(
                        "vget_lane_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64, i32), u8, 2usize>(
                        "vget_lane_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vget_lane_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vget_low_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vget_low_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        2usize,
                    >("vgetq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        2usize,
                    >("vgetq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        2usize,
                    >("vgetq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        2usize,
                    >("vgetq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        2usize,
                    >("vgetq_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128, i32), i8, 2usize>(
                        "vgetq_lane_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vgetq_lane_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u16,
                        2usize,
                    >("vgetq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u32,
                        2usize,
                    >("vgetq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        u64,
                        2usize,
                    >("vgetq_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vgetq_lane_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128, i32), u8, 2usize>(
                        "vgetq_lane_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vgetq_lane_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhadd_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhadd_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhadd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhadd_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhadd_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhadd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhaddq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhaddq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhaddq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhaddq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhaddq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhaddq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhaddq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhaddq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhaddq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhaddq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhaddq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhaddq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhsub_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsub_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhsub_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsub_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhsub_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsub_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhsub_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsub_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhsub_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsub_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vhsub_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsub_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhsubq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsubq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhsubq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsubq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhsubq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsubq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhsubq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsubq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhsubq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsubq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vhsubq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vhsubq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vld1_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vld1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vld1_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vld1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vld1q_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmax_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmax_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmax_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmax_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmax_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmax_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmax_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmax_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmax_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmax_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmax_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmax_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmax_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmax_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmax_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmax_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vmaxnm_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxnm_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vmaxnm_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxnm_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmaxnmq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxnmq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmaxnmq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxnmq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vmaxnmv_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxnmv_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f32, 1usize>(
                        "vmaxnmvq_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxnmvq_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vmaxnmvq_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxnmvq_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmaxq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmaxq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmaxq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmaxq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vmaxq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmaxq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmaxq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vmaxq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vmaxv_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxv_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i16, 1usize>(
                        "vmaxv_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxv_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i32, 1usize>(
                        "vmaxv_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxv_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s8(a0: crate::Unity::Burst::Intrinsics::v64) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i8, 1usize>(
                        "vmaxv_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxv_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u16, 1usize>(
                        "vmaxv_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxv_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u32, 1usize>(
                        "vmaxv_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxv_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u8(a0: crate::Unity::Burst::Intrinsics::v64) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u8, 1usize>(
                        "vmaxv_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxv_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f32, 1usize>(
                        "vmaxvq_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxvq_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vmaxvq_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxvq_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i16, 1usize>(
                        "vmaxvq_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxvq_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i32, 1usize>(
                        "vmaxvq_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxvq_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i8, 1usize>(
                        "vmaxvq_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxvq_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u16, 1usize>(
                        "vmaxvq_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxvq_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u32, 1usize>(
                        "vmaxvq_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxvq_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u8, 1usize>(
                        "vmaxvq_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmaxvq_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmin_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmin_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmin_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmin_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmin_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmin_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmin_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmin_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmin_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmin_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmin_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmin_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmin_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmin_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmin_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmin_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vminnm_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminnm_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vminnm_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminnm_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vminnmq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminnmq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vminnmq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminnmq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vminnmv_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminnmv_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f32, 1usize>(
                        "vminnmvq_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminnmvq_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vminnmvq_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminnmvq_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vminq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vminq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vminq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vminq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vminq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vminq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vminq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vminq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vminv_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminv_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i16, 1usize>(
                        "vminv_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminv_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i32, 1usize>(
                        "vminv_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminv_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s8(a0: crate::Unity::Burst::Intrinsics::v64) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), i8, 1usize>(
                        "vminv_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminv_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u16, 1usize>(
                        "vminv_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminv_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u32, 1usize>(
                        "vminv_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminv_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u8(a0: crate::Unity::Burst::Intrinsics::v64) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), u8, 1usize>(
                        "vminv_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminv_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f32, 1usize>(
                        "vminvq_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminvq_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vminvq_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminvq_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i16, 1usize>(
                        "vminvq_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminvq_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i32, 1usize>(
                        "vminvq_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminvq_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i8, 1usize>(
                        "vminvq_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminvq_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u16, 1usize>(
                        "vminvq_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminvq_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u32, 1usize>(
                        "vminvq_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminvq_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u8, 1usize>(
                        "vminvq_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vminvq_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmla_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmla_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmla_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        f32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmla_n_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_n_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmla_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmla_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        u16,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmla_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        u32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmla_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmla_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmla_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmla_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmla_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmla_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmla_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmla_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_high_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_high_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_high_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_high_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_high_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_high_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_high_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_high_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        u16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        u32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_high_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlal_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        u16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        u32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vmlal_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlal_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vmlal_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlal_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlaq_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        f32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_n_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_n_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        u16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        u32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vmlaq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlaq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vmlaq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlaq_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmls_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmls_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vmls_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        f32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmls_n_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_n_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmls_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmls_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        u16,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmls_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        u32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmls_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmls_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmls_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmls_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmls_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vmls_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmls_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_high_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_high_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_high_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_high_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_high_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_high_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_high_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_high_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        u16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        u32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_high_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsl_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        u16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        u32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vmlsl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsl_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vmlsl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsl_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_lane_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_lane_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_lane_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_laneq_f32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_laneq_u16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vmlsq_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_laneq_u32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        f32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_n_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_n_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        u16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        u32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vmlsq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmlsq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>("vmlsq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmlsq_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8), crate::Unity::Burst::Intrinsics::v64, 1usize>(
                        "vmov_n_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmov_n_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_high_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_high_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmovl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovl_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmovn_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovn_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmovn_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovn_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmovn_high_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovn_high_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmovn_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovn_high_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmovn_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovn_high_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmovn_high_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovn_high_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmovn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmovn_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_s16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_s32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_s8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_u16",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_u32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8), crate::Unity::Burst::Intrinsics::v128, 1usize>(
                        "vmovq_n_u8",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmovq_n_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmul_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmul_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_lane_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_lane_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_lane_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_lane_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_laneq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_laneq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_laneq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmul_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_laneq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, f32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, f64),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, u16),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, u32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vmul_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmul_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmul_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmul_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmul_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmul_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmul_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmul_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmul_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmuld_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        3usize,
                    >("vmuld_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmuld_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmuld_laneq_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        3usize,
                    >("vmuld_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmuld_laneq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_high_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_high_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_high_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_lane_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_high_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_lane_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_high_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_high_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_high_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_laneq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_high_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_laneq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, u16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, u32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_high_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_high_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_lane_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_lane_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_laneq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmull_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_laneq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, u16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, u32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmull_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmull_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vmull_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmull_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vmull_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmull_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmulq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmulq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_lane_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_lane_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_lane_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_lane_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_lane_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_lane_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_laneq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_laneq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_laneq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_laneq_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulq_laneq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_laneq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, f32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_f32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, f64),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_f64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, u16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, u32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vmulq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmulq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmulq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vmulq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmulq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmulq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vmulq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmuls_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        3usize,
                    >("vmuls_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmuls_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmuls_laneq_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        3usize,
                    >("vmuls_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmuls_laneq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmulx_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulx_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vmulx_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulx_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmulx_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulx_lane_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmulx_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulx_lane_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmulx_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulx_laneq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vmulx_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulx_laneq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), f64, 2usize>("vmulxd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulxd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        f64,
                        3usize,
                    >("vmulxd_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxd_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_laneq_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        f64,
                        3usize,
                    >("vmulxd_laneq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxd_laneq_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmulxq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulxq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vmulxq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulxq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulxq_lane_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulxq_lane_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulxq_lane_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulxq_lane_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulxq_laneq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulxq_laneq_f32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vmulxq_laneq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulxq_laneq_f64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), f32, 2usize>("vmulxs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vmulxs_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        f32,
                        3usize,
                    >("vmulxs_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxs_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_laneq_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        f32,
                        3usize,
                    >("vmulxs_laneq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmulxs_laneq_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvn_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvn_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmvn_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvn_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvn_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vmvn_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vmvn_u8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vmvnq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vmvnq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vneg_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vneg_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(), "vneg_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vnegd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i64, 1usize>("vnegd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vnegd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vnegq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vnegq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorn_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorn_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorn_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorn_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorn_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorn_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorn_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorn_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorn_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorn_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vornq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vornq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vornq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vornq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vornq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vornq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vornq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vornq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vornq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vornq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vornq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vornq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vornq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vornq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vornq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vornq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorr_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorr_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorr_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorr_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorr_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorr_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorr_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorr_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorr_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorr_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorr_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorr_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorr_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorr_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vorr_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorr_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vorrq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorrq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vorrq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorrq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vorrq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorrq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vorrq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorrq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vorrq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorrq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vorrq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorrq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vorrq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorrq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vorrq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vorrq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vpadal_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadal_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vpadal_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadal_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadal_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadal_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vpadal_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadal_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vpadal_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadal_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadal_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadal_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpadalq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadalq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpadalq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadalq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpadalq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadalq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpadalq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadalq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpadalq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadalq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpadalq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadalq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadd_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadd_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadd_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadd_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadd_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadd_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vpaddd_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), i64, 1usize>(
                        "vpaddd_s64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), u64, 1usize>(
                        "vpaddd_u64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddd_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vpaddl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddl_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vpaddlq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vpaddlq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpaddq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpaddq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpadds_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vpadds_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpadds_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmax_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmax_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmax_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmax_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmax_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmax_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmax_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmax_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmax_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmax_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmax_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmax_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmax_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmax_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vpmaxnm_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxnm_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxnmq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxnmq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxnmq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxnmq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vpmaxnmqd_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxnmqd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vpmaxnms_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxnms_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpmaxq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vpmaxqd_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxqd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxs_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vpmaxs_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmaxs_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmin_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmin_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmin_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmin_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmin_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmin_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmin_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmin_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmin_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmin_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmin_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmin_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vpmin_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmin_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vpminnm_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminnm_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminnmq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminnmq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminnmq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminnmq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vpminnmqd_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminnmqd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vpminnms_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminnms_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vpminq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpminqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v128), f64, 1usize>(
                        "vpminqd_f64",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpminqd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vpmins_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(crate::Unity::Burst::Intrinsics::v64), f32, 1usize>(
                        "vpmins_f32",
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vpmins_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqabs_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabs_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqabs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabs_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqabs_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabs_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqabs_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabs_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsb_s8(a0: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8), i8, 1usize>("vqabsb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqabsb_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i64, 1usize>("vqabsd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqabsd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), i16, 1usize>("vqabsh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqabsh_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqabsq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqabsq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqabsq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqabsq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqabsq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqabss_s32(a0: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), i32, 1usize>("vqabss_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqabss_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqadd_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadd_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqadd_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadd_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqadd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqadd_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadd_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqadd_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadd_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqadd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i8), i8, 2usize>("vqaddb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddb_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddb_u8(a0: u8, a1: u8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, u8), u8, 2usize>("vqaddb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddb_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vqaddd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vqaddd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqaddh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddh_u16(a0: u16, a1: u16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, u16), u16, 2usize>("vqaddh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddh_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqaddq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqaddq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqaddq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqaddq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqaddq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqaddq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqaddq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqaddq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqaddq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadds_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqadds_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadds_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqadds_u32(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u32), u32, 2usize>("vqadds_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqadds_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlal_high_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_high_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlal_high_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_high_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlal_high_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_high_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlal_high_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_high_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlal_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlal_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlal_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlal_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlal_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlal_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlal_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlal_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlal_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlal_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlal_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlal_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlal_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_lane_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        4usize,
                    >("vqdmlalh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlalh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_laneq_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        4usize,
                    >("vqdmlalh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlalh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_s16(a0: i32, a1: i16, a2: i16) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i16, i16), i32, 3usize>("vqdmlalh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlalh_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_lane_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i64,
                        4usize,
                    >("vqdmlals_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlals_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_laneq_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        4usize,
                    >("vqdmlals_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlals_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_s32(a0: i64, a1: i32, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32, i32), i64, 3usize>("vqdmlals_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlals_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlsl_high_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_high_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlsl_high_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_high_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlsl_high_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_high_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlsl_high_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_high_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlsl_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlsl_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlsl_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlsl_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlsl_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlsl_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlsl_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqdmlsl_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i16,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlsl_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlsl_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlsl_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmlsl_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsl_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_lane_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        4usize,
                    >("vqdmlslh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlslh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_laneq_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        4usize,
                    >("vqdmlslh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlslh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_s16(a0: i32, a1: i16, a2: i16) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i16, i16), i32, 3usize>("vqdmlslh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlslh_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_lane_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i64,
                        4usize,
                    >("vqdmlsls_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsls_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_laneq_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        4usize,
                    >("vqdmlsls_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmlsls_laneq_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_s32(a0: i64, a1: i32, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32, i32), i64, 3usize>("vqdmlsls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmlsls_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqdmulh_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulh_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqdmulh_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulh_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqdmulh_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulh_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqdmulh_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulh_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqdmulh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqdmulh_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulh_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqdmulh_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqdmulh_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulh_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        3usize,
                    >("vqdmulhh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhh_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        3usize,
                    >("vqdmulhh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhh_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqdmulhh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulhh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmulhq_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulhq_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmulhq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulhq_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmulhq_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulhq_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmulhq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulhq_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmulhq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmulhq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqdmulhq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulhq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqdmulhq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulhq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        3usize,
                    >("vqdmulhs_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhs_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        3usize,
                    >("vqdmulhs_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulhs_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqdmulhs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulhs_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmull_high_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_high_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmull_high_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_high_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmull_high_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_high_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmull_high_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_high_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_high_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqdmull_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqdmull_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmull_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmull_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmull_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqdmull_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqdmull_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmull_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqdmull_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqdmull_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmull_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        3usize,
                    >("vqdmullh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmullh_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        3usize,
                    >("vqdmullh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmullh_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i32, 2usize>("vqdmullh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmullh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i64,
                        3usize,
                    >("vqdmulls_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulls_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i64,
                        3usize,
                    >("vqdmulls_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqdmulls_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i64, 2usize>("vqdmulls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqdmulls_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovn_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovn_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovn_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovn_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovn_high_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovn_high_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovn_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovn_high_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovn_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovn_high_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovn_high_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovn_high_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovn_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovn_u64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i32, 1usize>("vqmovnd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovnd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnd_u64(a0: u64) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64), u32, 1usize>("vqmovnd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovnd_u64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), i8, 1usize>("vqmovnh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovnh_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnh_u16(a0: u16) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16), u8, 1usize>("vqmovnh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovnh_u16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovns_s32(a0: i32) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), i16, 1usize>("vqmovns_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovns_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovns_u32(a0: u32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), u16, 1usize>("vqmovns_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovns_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovun_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovun_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovun_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovun_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqmovun_high_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovun_high_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovun_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovun_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqmovun_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqmovun_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovund_s64(a0: i64) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), u32, 1usize>("vqmovund_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovund_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovunh_s16(a0: i16) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), u8, 1usize>("vqmovunh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovunh_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovuns_s32(a0: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), u16, 1usize>("vqmovuns_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqmovuns_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqneg_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqneg_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqneg_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqneg_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqneg_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqneg_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vqneg_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqneg_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegb_s8(a0: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8), i8, 1usize>("vqnegb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqnegb_s8",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64), i64, 1usize>("vqnegd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqnegd_s64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16), i16, 1usize>("vqnegh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqnegh_s16",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqnegq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegq_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqnegq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegq_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqnegq_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegq_s64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vqnegq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqnegq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegs_s32(a0: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32), i32, 1usize>("vqnegs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqnegs_s32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vqrdmlah_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlah_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vqrdmlah_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlah_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vqrdmlah_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlah_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vqrdmlah_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlah_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqrdmlah_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlah_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqrdmlah_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlah_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_lane_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        4usize,
                    >("vqrdmlahh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_laneq_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        4usize,
                    >("vqrdmlahh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_s16(a0: i16, a1: i16, a2: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16, i16), i16, 3usize>("vqrdmlahh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlahh_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqrdmlahq_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlahq_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqrdmlahq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlahq_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqrdmlahq_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlahq_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqrdmlahq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlahq_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrdmlahq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlahq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrdmlahq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlahq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahs_lane_s32(
        a0: i32,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        4usize,
                    >("vqrdmlahs_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlahs_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahs_s32(a0: i32, a1: i32, a2: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32, i32), i32, 3usize>("vqrdmlahs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlahs_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vqrdmlsh_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlsh_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vqrdmlsh_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlsh_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vqrdmlsh_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlsh_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 4usize>(
                        "vqrdmlsh_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlsh_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqrdmlsh_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlsh_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqrdmlsh_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlsh_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_lane_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        4usize,
                    >("vqrdmlshh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshh_lane_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_laneq_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        4usize,
                    >("vqrdmlshh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshh_laneq_s16", 4usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_s16(a0: i16, a1: i16, a2: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16, i16), i16, 3usize>("vqrdmlshh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlshh_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqrdmlshq_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlshq_lane_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqrdmlshq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlshq_lane_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqrdmlshq_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlshq_laneq_s16",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 4usize>(
                        "vqrdmlshq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlshq_laneq_s32",
                            4usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrdmlshq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlshq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrdmlshq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlshq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshs_lane_s32(
        a0: i32,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        4usize,
                    >("vqrdmlshs_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmlshs_lane_s32", 4usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2, a3))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshs_s32(a0: i32, a1: i32, a2: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32, i32), i32, 3usize>("vqrdmlshs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmlshs_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqrdmulh_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulh_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqrdmulh_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulh_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqrdmulh_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulh_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vqrdmulh_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulh_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i16),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrdmulh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrdmulh_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulh_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqrdmulh_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqrdmulh_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulh_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        i16,
                        3usize,
                    >("vqrdmulhh_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhh_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        i16,
                        3usize,
                    >("vqrdmulhh_laneq_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhh_laneq_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqrdmulhh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulhh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrdmulhq_lane_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulhq_lane_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrdmulhq_lane_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulhq_lane_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrdmulhq_laneq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulhq_laneq_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrdmulhq_laneq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulhq_laneq_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i16),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrdmulhq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqrdmulhq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrdmulhq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulhq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrdmulhq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulhq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        i32,
                        3usize,
                    >("vqrdmulhs_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhs_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        i32,
                        3usize,
                    >("vqrdmulhs_laneq_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrdmulhs_laneq_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqrdmulhs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrdmulhs_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqrshl_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshl_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqrshl_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshl_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqrshl_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshl_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqrshl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshl_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqrshl_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshl_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqrshl_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshl_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vqrshl_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshl_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqrshl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshl_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i8), i8, 2usize>("vqrshlb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlb_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, i8), u8, 2usize>("vqrshlb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlb_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vqrshld_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshld_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vqrshld_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshld_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqrshlh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i16), u16, 2usize>("vqrshlh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlh_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrshlq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrshlq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrshlq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrshlq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrshlq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrshlq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrshlq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqrshlq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshlq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqrshls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshls_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshls_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u32, 2usize>("vqrshls_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshls_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrn_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrn_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrn_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrn_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrn_high_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrn_high_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrn_high_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrn_high_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrn_high_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrn_high_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrn_high_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrn_high_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrn_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrn_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i32, 2usize>("vqrshrnd_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrnd_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u32, 2usize>("vqrshrnd_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrnd_n_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), i8, 2usize>("vqrshrnh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrnh_n_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i32), u8, 2usize>("vqrshrnh_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrnh_n_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i16, 2usize>("vqrshrns_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrns_n_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrns_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u16, 2usize>("vqrshrns_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrns_n_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrun_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrun_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrun_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrun_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqrshrun_high_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrun_high_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrun_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrun_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqrshrun_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqrshrun_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrund_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), u32, 2usize>("vqrshrund_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrund_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrunh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), u8, 2usize>("vqrshrunh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshrunh_n_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshruns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), u16, 2usize>("vqrshruns_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqrshruns_n_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshl_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshl_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqshl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshl_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqshl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshl_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqshl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshl_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqshl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshl_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqshl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshl_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqshl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshl_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqshl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshl_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqshl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshl_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_n_s8(a0: i8, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i32), i8, 2usize>("vqshlb_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlb_n_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_n_u8(a0: u8, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, i32), u8, 2usize>("vqshlb_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlb_n_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i8), i8, 2usize>("vqshlb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlb_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, i8), u8, 2usize>("vqshlb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlb_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i64, 2usize>("vqshld_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshld_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u64, 2usize>("vqshld_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshld_n_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vqshld_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshld_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vqshld_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshld_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), i16, 2usize>("vqshlh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlh_n_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i32), u16, 2usize>("vqshlh_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlh_n_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqshlh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i16), u16, 2usize>("vqshlh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlh_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshlq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlq_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqshlq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqshlq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqshlq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqshlq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqshlq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqshlq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqshlq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqshlq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqshls_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshls_n_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u32, 2usize>("vqshls_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshls_n_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqshls_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshls_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u32, 2usize>("vqshls_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshls_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshlu_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlu_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshlu_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlu_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshlu_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlu_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshlu_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshlu_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlub_n_s8(a0: i8, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i32), u8, 2usize>("vqshlub_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlub_n_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlud_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), u64, 2usize>("vqshlud_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlud_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), u16, 2usize>("vqshluh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshluh_n_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshluq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshluq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshluq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vqshluq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshluq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlus_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), u32, 2usize>("vqshlus_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshlus_n_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrn_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrn_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrn_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrn_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrn_high_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrn_high_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrn_high_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrn_high_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrn_high_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrn_high_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrn_high_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrn_high_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrn_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrn_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i32, 2usize>("vqshrnd_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrnd_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u32, 2usize>("vqshrnd_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrnd_n_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), i8, 2usize>("vqshrnh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrnh_n_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i32), u8, 2usize>("vqshrnh_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrnh_n_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i16, 2usize>("vqshrns_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrns_n_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrns_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u16, 2usize>("vqshrns_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrns_n_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrun_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrun_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrun_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrun_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqshrun_high_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrun_high_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrun_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrun_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vqshrun_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vqshrun_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrund_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), u32, 2usize>("vqshrund_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrund_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrunh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i32), u8, 2usize>("vqshrunh_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshrunh_n_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqshruns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), u16, 2usize>("vqshruns_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqshruns_n_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqsub_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsub_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqsub_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsub_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqsub_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsub_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqsub_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsub_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqsub_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsub_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqsub_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsub_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqsub_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsub_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqsub_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsub_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, i8), i8, 2usize>("vqsubb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubb_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubb_u8(a0: u8, a1: u8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, u8), u8, 2usize>("vqsubb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubb_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vqsubd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vqsubd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, i16), i16, 2usize>("vqsubh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubh_u16(a0: u16, a1: u16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, u16), u16, 2usize>("vqsubh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubh_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqsubq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqsubq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqsubq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqsubq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqsubq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqsubq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqsubq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqsubq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, i32), i32, 2usize>("vqsubs_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubs_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubs_u32(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, u32), u32, 2usize>("vqsubs_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqsubs_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqtbl1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqtbl1_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vqtbl1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqtbl1_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqtbl1q_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqtbl1q_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vqtbl1q_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqtbl1q_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vqtbx1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqtbx1_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vqtbx1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqtbx1_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqtbx1q_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqtbx1q_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vqtbx1q_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vqtbx1q_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vraddhn_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vraddhn_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vraddhn_high_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_high_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vraddhn_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_high_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vraddhn_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_high_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vraddhn_high_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_high_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vraddhn_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vraddhn_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vraddhn_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vraddhn_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vraddhn_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vraddhn_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vraddhn_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrbit_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrbit_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrbit_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrbit_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrbit_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrbit_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrbitq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrbitq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrbitq_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrbitq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrbitq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrbitq_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrecpe_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpe_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrecpe_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpe_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrecpe_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpe_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecped_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), f64, 1usize>("vrecped_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecped_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrecpeq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpeq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrecpeq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpeq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrecpeq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrecpeq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpes_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), f32, 1usize>("vrecpes_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecpes_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecps_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrecps_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecps_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecps_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrecps_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecps_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), f64, 2usize>("vrecpsd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecpsd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrecpsq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecpsq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrecpsq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecpsq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpss_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), f32, 2usize>("vrecpss_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecpss_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpxd_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), f64, 1usize>("vrecpxd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecpxd_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpxs_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), f32, 1usize>("vrecpxs_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrecpxs_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev16_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev16_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev16_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev16_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev16q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev16q_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev16q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev16q_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev32_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev32_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev32_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev32_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev32q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32q_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev32q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32q_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev32q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32q_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev32q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev32q_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrev64_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_s16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_s32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_s8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_u16", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrev64q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrev64q_u8", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrhadd_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhadd_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrhadd_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhadd_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrhadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhadd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrhadd_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhadd_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrhadd_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhadd_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrhadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhadd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrhaddq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhaddq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrhaddq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhaddq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrhaddq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhaddq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrhaddq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhaddq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrhaddq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhaddq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrhaddq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrhaddq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrnd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrnd_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrnd_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrnd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrnd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrnd_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrnda_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrnda_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrnda_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrnda_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrnda_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrnda_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndaq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndaq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndaq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndaq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndi_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndi_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndi_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndi_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndi_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndi_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndiq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndiq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndiq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndiq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndiq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndiq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndm_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndm_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndm_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndm_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndmq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndmq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndmq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndmq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndn_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndn_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndn_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndn_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndn_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndn_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndnq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndnq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndnq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndnq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndnq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndnq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndns_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), f32, 1usize>("vrndns_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrndns_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndp_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndp_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndp_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndp_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndp_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndp_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndpq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndpq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndpq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndpq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndpq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndpq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndx_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndx_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndx_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndx_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrndx_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndx_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndxq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndxq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrndxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrndxq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrndxq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrshl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshl_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrshl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshl_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrshl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshl_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrshl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshl_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrshl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshl_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrshl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshl_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrshl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshl_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vrshl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshl_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vrshld_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshld_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vrshld_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshld_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrshlq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshlq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrshlq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshlq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrshlq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshlq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrshlq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshlq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrshlq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshlq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrshlq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshlq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrshlq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshlq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrshlq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshlq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshr_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshr_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i64, 2usize>("vrshrd_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshrd_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u64, 2usize>("vrshrd_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshrd_n_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrshrn_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshrn_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrshrn_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshrn_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrshrn_high_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshrn_high_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrshrn_high_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshrn_high_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrshrn_high_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshrn_high_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrshrn_high_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrshrn_high_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vrshrn_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrn_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vrshrq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrshrq_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrsqrte_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrte_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrsqrte_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrte_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vrsqrte_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrte_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrted_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64), f64, 1usize>("vrsqrted_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsqrted_f64",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrsqrteq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrteq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrsqrteq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrteq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vrsqrteq_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vrsqrteq_u32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtes_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32), f32, 1usize>("vrsqrtes_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsqrtes_f32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrts_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrsqrts_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsqrts_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrts_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrsqrts_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsqrts_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f64, f64), f64, 2usize>("vrsqrtsd_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsqrtsd_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrsqrtsq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsqrtsq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vrsqrtsq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsqrtsq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtss_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(f32, f32), f32, 2usize>("vrsqrtss_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsqrtss_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: f32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vrsra_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsra_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vrsra_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsra_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vrsra_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsra_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vrsra_n_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsra_n_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vrsra_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsra_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vrsra_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsra_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vrsra_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsra_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vrsra_n_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsra_n_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsrad_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64, i32), i64, 3usize>("vrsrad_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsrad_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsrad_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64, i32), u64, 3usize>("vrsrad_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsrad_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsraq_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsraq_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsraq_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsraq_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsraq_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsraq_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsraq_n_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsraq_n_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsraq_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsraq_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsraq_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsraq_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsraq_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsraq_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsraq_n_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsraq_n_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsubhn_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsubhn_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsubhn_high_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_high_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsubhn_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_high_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsubhn_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_high_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vrsubhn_high_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_high_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrsubhn_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrsubhn_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrsubhn_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrsubhn_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrsubhn_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vrsubhn_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vrsubhn_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s64(
        a0: i64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s8(
        a0: i8,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i8, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u16(
        a0: u16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u16, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u32(
        a0: u32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u64(
        a0: u64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u8(
        a0: u8,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u8, crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        3usize,
                    >("vset_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vset_lane_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_f32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_f64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_s16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_s32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s64(
        a0: i64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i64, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_s64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s8(
        a0: i8,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (i8, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_s8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u16(
        a0: u16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u16, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_u16", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u32(
        a0: u32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u32, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_u32", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u64(
        a0: u64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u64, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_u64", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u8(
        a0: u8,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (u8, crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        3usize,
                    >("vsetq_lane_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsetq_lane_u8", 3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1cq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        u32,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsha1cq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha1cq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1h_u32(a0: u32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32), u32, 1usize>("vsha1h_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha1h_u32",
                            1usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1mq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        u32,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsha1mq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha1mq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1pq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        u32,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsha1pq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha1pq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1su0q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsha1su0q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha1su0q_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1su1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsha1su1q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha1su1q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256h2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsha256h2q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha256h2q_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256hq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsha256hq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha256hq_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256su0q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsha256su0q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha256su0q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256su1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsha256su1q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsha256su1q_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshl_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshl_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vshl_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshl_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vshl_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshl_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vshl_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshl_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vshl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshl_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vshl_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshl_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vshl_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshl_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vshl_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshl_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vshl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshl_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i64, 2usize>("vshld_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshld_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u64, 2usize>("vshld_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshld_n_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vshld_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshld_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vshld_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshld_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_high_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_high_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshll_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshll_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshlq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshlq_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vshlq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshlq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vshlq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshlq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vshlq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshlq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vshlq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshlq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vshlq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshlq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vshlq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshlq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vshlq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshlq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vshlq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshlq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshr_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshr_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i32), i64, 2usize>("vshrd_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshrd_n_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i32), u64, 2usize>("vshrd_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshrd_n_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vshrn_high_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshrn_high_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vshrn_high_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshrn_high_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vshrn_high_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshrn_high_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vshrn_high_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshrn_high_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vshrn_high_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshrn_high_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vshrn_high_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vshrn_high_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v64,
                        2usize,
                    >("vshrn_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrn_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_s16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_s32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_s64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_s8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_u16", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_u32", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_u64", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128, i32),
                        crate::Unity::Burst::Intrinsics::v128,
                        2usize,
                    >("vshrq_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vshrq_n_u8", 2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsli_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsli_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsli_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsli_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsli_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsli_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vsli_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsli_n_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsli_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsli_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsli_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsli_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsli_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsli_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vsli_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsli_n_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vslid_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64, i32), i64, 3usize>("vslid_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vslid_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vslid_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64, i32), u64, 3usize>("vslid_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vslid_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsliq_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsliq_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsliq_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsliq_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsliq_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsliq_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsliq_n_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsliq_n_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsliq_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsliq_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsliq_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsliq_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsliq_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsliq_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsliq_n_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsliq_n_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsqadd_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqadd_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsqadd_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqadd_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsqadd_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqadd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsqadd_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqadd_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u8, i8), u8, 2usize>("vsqaddb_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqaddb_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddd_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, i64), u64, 2usize>("vsqaddd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqaddd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u16, i16), u16, 2usize>("vsqaddh_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqaddh_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsqaddq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqaddq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsqaddq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqaddq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsqaddq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqaddq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsqaddq_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqaddq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadds_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u32, i32), u32, 2usize>("vsqadds_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsqadds_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vsqrt_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqrt_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v64),
                        crate::Unity::Burst::Intrinsics::v64,
                        1usize,
                    >("vsqrt_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqrt_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vsqrtq_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqrtq_f32", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<
                        (crate::Unity::Burst::Intrinsics::v128),
                        crate::Unity::Burst::Intrinsics::v128,
                        1usize,
                    >("vsqrtq_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            < Self as quest_hook::libil2cpp::Type > ::class(),
                            "vsqrtq_f64", 1usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsra_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsra_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsra_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsra_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsra_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsra_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vsra_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsra_n_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsra_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsra_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsra_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsra_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsra_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsra_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vsra_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsra_n_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsrad_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64, i32), i64, 3usize>("vsrad_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsrad_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsrad_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64, i32), u64, 3usize>("vsrad_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsrad_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsraq_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsraq_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsraq_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsraq_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsraq_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsraq_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsraq_n_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsraq_n_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsraq_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsraq_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsraq_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsraq_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsraq_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsraq_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsraq_n_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsraq_n_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsri_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsri_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsri_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsri_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsri_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsri_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vsri_n_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsri_n_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsri_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsri_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsri_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsri_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>(
                        "vsri_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsri_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vsri_n_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsri_n_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsrid_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64, i32), i64, 3usize>("vsrid_n_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsrid_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsrid_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64, i32), u64, 3usize>("vsrid_n_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsrid_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsriq_n_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsriq_n_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsriq_n_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsriq_n_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsriq_n_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsriq_n_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsriq_n_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsriq_n_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsriq_n_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsriq_n_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsriq_n_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsriq_n_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsriq_n_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsriq_n_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                        i32,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsriq_n_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsriq_n_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), quest_hook::libil2cpp::Void, 2usize>("vst1q_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vst1q_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: quest_hook::libil2cpp::Void =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_f64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vsub_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsub_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), i64, 2usize>("vsubd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vsubd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsubhn_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_high_s16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsubhn_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_high_s32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsubhn_high_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_high_s64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsubhn_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_high_u16",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsubhn_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_high_u32",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 3usize>(
                        "vsubhn_high_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_high_u64",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsubhn_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsubhn_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsubhn_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsubhn_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsubhn_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vsubhn_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubhn_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_high_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_high_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_high_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_high_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vsubl_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubl_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vsubl_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubl_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubq_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubq_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vsubq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vsubq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_high_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_high_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_high_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_high_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_high_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_high_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_high_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_high_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_high_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_high_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_high_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_high_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vsubw_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vsubw_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vsubw_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vsubw_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtbl1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtbl1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtbl1_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtbl1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtbl1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtbl1_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtbx1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vtbx1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtbx1_s8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtbx1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 3usize>("vtbx1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtbx1_u8",
                            3usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1, a2))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn1q_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn1q_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn2_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn2_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn2_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn2_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn2_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn2_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtrn2_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtrn2q_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtrn2q_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtst_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtst_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtst_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtst_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtst_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtst_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtst_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtst_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtst_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtst_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtst_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtst_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtst_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtst_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vtst_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtst_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, i64), u64, 2usize>("vtstd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(u64, u64), u64, 2usize>("vtstd_u64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstd_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: u64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtstq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtstq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtstq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vtstq_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtstq_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstq_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtstq_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstq_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vtstq_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstq_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>("vtstq_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vtstq_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vuqadd_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqadd_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vuqadd_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqadd_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>(
                        "vuqadd_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqadd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuqadd_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqadd_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddb_s8(a0: i8, a1: u8) -> quest_hook::libil2cpp::Result<i8> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i8, u8), i8, 2usize>("vuqaddb_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqaddb_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i8 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddd_s64(a0: i64, a1: u64) -> quest_hook::libil2cpp::Result<i64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i64, u64), i64, 2usize>("vuqaddd_s64")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqaddd_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i64 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddh_s16(a0: i16, a1: u16) -> quest_hook::libil2cpp::Result<i16> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i16, u16), i16, 2usize>("vuqaddh_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqaddh_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i16 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuqaddq_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqaddq_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuqaddq_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqaddq_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuqaddq_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqaddq_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuqaddq_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqaddq_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadds_s32(a0: i32, a1: u32) -> quest_hook::libil2cpp::Result<i32> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(i32, u32), i32, 2usize>("vuqadds_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuqadds_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: i32 = unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp1q_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp1q_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp2_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp2_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp2_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp2_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp2_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp2_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vuzp2_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vuzp2q_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vuzp2q_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip1_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip1_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip1_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip1_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip1_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip1_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip1_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip1q_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip1q_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip2_f32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip2_s16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip2_s32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip2_s8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip2_u16")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip2_u32")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v64,
                        crate::Unity::Burst::Intrinsics::v64,
                    ), crate::Unity::Burst::Intrinsics::v64, 2usize>("vzip2_u8")
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_f32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_f32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_f64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_f64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_s16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_s16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_s32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_s32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_s64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_s64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_s8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_s8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_u16"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_u16",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_u32"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_u32",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_u64"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_u64",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static METHOD: std::sync::OnceLock<&'static quest_hook::libil2cpp::MethodInfo> =
            std::sync::OnceLock::new();
        let cordl_method_info: &'static quest_hook::libil2cpp::MethodInfo =
            METHOD.get_or_init(|| {
                <Self as quest_hook::libil2cpp::Type>::class()
                    .find_static_method::<(
                        crate::Unity::Burst::Intrinsics::v128,
                        crate::Unity::Burst::Intrinsics::v128,
                    ), crate::Unity::Burst::Intrinsics::v128, 2usize>(
                        "vzip2q_u8"
                    )
                    .unwrap_or_else(|e| {
                        panic!(
                            "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                            <Self as quest_hook::libil2cpp::Type>::class(),
                            "vzip2q_u8",
                            2usize
                        )
                    })
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 =
            unsafe { cordl_method_info.invoke_unchecked((), (a0, a1))? };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "cordl_class_Unity+Burst+Intrinsics+Arm+Neon")]
impl quest_hook::libil2cpp::ObjectType for crate::Unity::Burst::Intrinsics::Arm_Neon {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
